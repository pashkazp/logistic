import * as tslib_1 from "tslib";
import { AsyncIterableX } from '../asynciterable';
import { forEach } from './foreach';
var DebounceAsyncIterable = (function (_super) {
    tslib_1.__extends(DebounceAsyncIterable, _super);
    function DebounceAsyncIterable(source, time) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._time = time;
        return _this;
    }
    DebounceAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var _this = this;
            var noValue, lastItem, deferred, resolver, done, hasError, error, reset, run;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        done = false;
                        hasError = false;
                        reset = function (hasNoValue) {
                            noValue = hasNoValue;
                            lastItem = undefined;
                            deferred = new Promise(function (r) { return resolver = r; });
                        };
                        run = function () {
                            if (lastItem === undefined) {
                                noValue = true;
                                return;
                            }
                            var item = lastItem;
                            var res = resolver;
                            reset(false);
                            setTimeout(run, _this._time);
                            res(item);
                        };
                        reset(true);
                        forEach(this._source, function (item) {
                            lastItem = item;
                            if (noValue) {
                                run();
                            }
                        })
                            .then(function () { return done = true; })
                            .catch(function (err) { hasError = true; error = err; });
                        _a.label = 1;
                    case 1:
                        if (!1) return [3 /*break*/, 4];
                        if (done) {
                            return [3 /*break*/, 4];
                        }
                        if (hasError) {
                            throw error;
                        }
                        return [4 /*yield*/, tslib_1.__await(deferred)];
                    case 2: return [4 /*yield*/, _a.sent()];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return DebounceAsyncIterable;
}(AsyncIterableX));
export function debounce(source, time) {
    return new DebounceAsyncIterable(source, time);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvZGVib3VuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXBDO0lBQTZDLGlEQUF1QjtJQUlsRSwrQkFBWSxNQUE4QixFQUFFLElBQVk7UUFBeEQsWUFDRSxpQkFBTyxTQUdSO1FBRkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsS0FBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7O0lBQ3BCLENBQUM7SUFFTSxnQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQTdCOzs7Ozs7O3dCQUtNLElBQUksR0FBWSxLQUFLLENBQUM7d0JBQ3RCLFFBQVEsR0FBWSxLQUFLLENBQUM7d0JBR3hCLEtBQUssR0FBRyxVQUFDLFVBQW1COzRCQUNoQyxPQUFPLEdBQUcsVUFBVSxDQUFDOzRCQUNyQixRQUFRLEdBQUcsU0FBUyxDQUFDOzRCQUNyQixRQUFRLEdBQUcsSUFBSSxPQUFPLENBQVUsVUFBQSxDQUFDLElBQUksT0FBQSxRQUFRLEdBQUcsQ0FBQyxFQUFaLENBQVksQ0FBQyxDQUFDO3dCQUNyRCxDQUFDLENBQUM7d0JBRUksR0FBRyxHQUFHOzRCQUNWLEVBQUUsQ0FBQyxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dDQUMzQixPQUFPLEdBQUcsSUFBSSxDQUFDO2dDQUNmLE1BQU0sQ0FBQzs0QkFDVCxDQUFDOzRCQUVELElBQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQzs0QkFDdEIsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDOzRCQUNyQixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7NEJBQ2IsVUFBVSxDQUFDLEdBQUcsRUFBRSxLQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7NEJBQzVCLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDWixDQUFDLENBQUM7d0JBRUYsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQUEsSUFBSTs0QkFDeEIsUUFBUSxHQUFHLElBQUksQ0FBQzs0QkFDaEIsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQ0FBQyxHQUFHLEVBQUUsQ0FBQzs0QkFBQyxDQUFDO3dCQUN6QixDQUFDLENBQUM7NkJBQ0QsSUFBSSxDQUFDLGNBQU0sT0FBQSxJQUFJLEdBQUcsSUFBSSxFQUFYLENBQVcsQ0FBQzs2QkFDdkIsS0FBSyxDQUFDLFVBQUEsR0FBRyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs2QkFFMUMsQ0FBQzt3QkFDTixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzRCQUFDLE1BQU0sa0JBQUE7d0JBQUMsQ0FBQzt3QkFDcEIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzs0QkFBQyxNQUFNLEtBQUssQ0FBQzt3QkFBQyxDQUFDO3dCQUN4QixxQ0FBTSxRQUFTLEdBQUE7NEJBQXJCLHFCQUFNLFNBQWUsRUFBQTs7d0JBQXJCLFNBQXFCLENBQUM7Ozs7OztLQUV6QjtJQUNILDRCQUFDO0FBQUQsQ0FwREEsQUFvREMsQ0FwRDRDLGNBQWMsR0FvRDFEO0FBRUQsTUFBTSxtQkFBNEIsTUFBOEIsRUFBRSxJQUFZO0lBQzVFLE1BQU0sQ0FBQyxJQUFJLHFCQUFxQixDQUFVLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxRCxDQUFDIiwiZmlsZSI6ImFzeW5jaXRlcmFibGUvZGVib3VuY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuaW1wb3J0IHsgZm9yRWFjaCB9IGZyb20gJy4vZm9yZWFjaCc7XG5cbmNsYXNzIERlYm91bmNlQXN5bmNJdGVyYWJsZTxUU291cmNlPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF90aW1lOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LCB0aW1lOiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBub1ZhbHVlOiBib29sZWFuO1xuICAgIGxldCBsYXN0SXRlbTogVFNvdXJjZSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgZGVmZXJyZWQ6IFByb21pc2U8VFNvdXJjZT47XG4gICAgbGV0IHJlc29sdmVyOiAodmFsdWU/OiBUU291cmNlIHwgUHJvbWlzZUxpa2U8VFNvdXJjZT4gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gICAgbGV0IGRvbmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBsZXQgaGFzRXJyb3I6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBsZXQgZXJyb3I6IGFueTtcblxuICAgIGNvbnN0IHJlc2V0ID0gKGhhc05vVmFsdWU6IGJvb2xlYW4pID0+IHtcbiAgICAgIG5vVmFsdWUgPSBoYXNOb1ZhbHVlO1xuICAgICAgbGFzdEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICBkZWZlcnJlZCA9IG5ldyBQcm9taXNlPFRTb3VyY2U+KHIgPT4gcmVzb2x2ZXIgPSByKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgaWYgKGxhc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9WYWx1ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRlbSA9IGxhc3RJdGVtO1xuICAgICAgY29uc3QgcmVzID0gcmVzb2x2ZXI7XG4gICAgICByZXNldChmYWxzZSk7XG4gICAgICBzZXRUaW1lb3V0KHJ1biwgdGhpcy5fdGltZSk7XG4gICAgICByZXMoaXRlbSk7XG4gICAgfTtcblxuICAgIHJlc2V0KHRydWUpO1xuICAgIGZvckVhY2godGhpcy5fc291cmNlLCBpdGVtID0+IHtcbiAgICAgIGxhc3RJdGVtID0gaXRlbTtcbiAgICAgIGlmIChub1ZhbHVlKSB7IHJ1bigpOyB9XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiBkb25lID0gdHJ1ZSlcbiAgICAuY2F0Y2goZXJyID0+IHsgaGFzRXJyb3IgPSB0cnVlOyBlcnJvciA9IGVycjsgfSk7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgaWYgKGRvbmUpIHsgYnJlYWs7IH1cbiAgICAgIGlmIChoYXNFcnJvcikgeyB0aHJvdyBlcnJvcjsgfVxuICAgICAgeWllbGQgYXdhaXQgZGVmZXJyZWQhO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VFNvdXJjZT4oc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LCB0aW1lOiBudW1iZXIpOiBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG4gIHJldHVybiBuZXcgRGVib3VuY2VBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSwgdGltZSk7XG59XG4iXX0=
