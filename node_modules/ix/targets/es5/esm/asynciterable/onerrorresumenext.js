import * as tslib_1 from "tslib";
import { AsyncIterableX } from '../asynciterable';
var OnErrorResumeNextAsyncIterable = (function (_super) {
    tslib_1.__extends(OnErrorResumeNextAsyncIterable, _super);
    function OnErrorResumeNextAsyncIterable(source) {
        var _this = _super.call(this) || this;
        _this._source = source;
        return _this;
    }
    OnErrorResumeNextAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var _a, _b, item, it, next, e_1, e_2_1, e_2, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 10, 11, 12]);
                        _a = tslib_1.__values(this._source), _b = _a.next();
                        _d.label = 1;
                    case 1:
                        if (!!_b.done) return [3 /*break*/, 9];
                        item = _b.value;
                        it = item[Symbol.asyncIterator]();
                        _d.label = 2;
                    case 2:
                        if (!1) return [3 /*break*/, 8];
                        next = void 0;
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, tslib_1.__await(it.next())];
                    case 4:
                        next = _d.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _d.sent();
                        return [3 /*break*/, 8];
                    case 6:
                        if (next.done) {
                            return [3 /*break*/, 8];
                        }
                        return [4 /*yield*/, next.value];
                    case 7:
                        _d.sent();
                        return [3 /*break*/, 2];
                    case 8:
                        _b = _a.next();
                        return [3 /*break*/, 1];
                    case 9: return [3 /*break*/, 12];
                    case 10:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 12];
                    case 11:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    return OnErrorResumeNextAsyncIterable;
}(AsyncIterableX));
export function onErrorResumeNext(source) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return new OnErrorResumeNextAsyncIterable(tslib_1.__spread([source], args));
}
export function onErrorResumeNextStatic() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    return new OnErrorResumeNextAsyncIterable(source);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvb25lcnJvcnJlc3VtZW5leHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVsRDtJQUFzRCwwREFBdUI7SUFHM0Usd0NBQVksTUFBd0M7UUFBcEQsWUFDRSxpQkFBTyxTQUVSO1FBREMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7O0lBQ3hCLENBQUM7SUFFTSx5Q0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQTdCOzs7Ozs7O3dCQUNtQixLQUFBLGlCQUFBLElBQUksQ0FBQyxPQUFPLENBQUE7Ozs7d0JBQXBCLElBQUk7d0JBQ1AsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQzs7OzZCQUMvQixDQUFDO3dCQUNGLElBQUksU0FBQSxDQUFDOzs7O3dCQUVBLHFDQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBQTs7d0JBQXRCLElBQUksR0FBRyxTQUFlLENBQUM7Ozs7d0JBRXZCLHdCQUFNOzt3QkFHUixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs0QkFBQyxNQUFNLGtCQUFBO3dCQUFDLENBQUM7d0JBQ3pCLHFCQUFNLElBQUksQ0FBQyxLQUFLLEVBQUE7O3dCQUFoQixTQUFnQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUd0QjtJQUNILHFDQUFDO0FBQUQsQ0F4QkEsQUF3QkMsQ0F4QnFELGNBQWMsR0F3Qm5FO0FBRUQsTUFBTSw0QkFBK0IsTUFBd0I7SUFBRSxjQUEyQjtTQUEzQixVQUEyQixFQUEzQixxQkFBMkIsRUFBM0IsSUFBMkI7UUFBM0IsNkJBQTJCOztJQUN4RixNQUFNLENBQUMsSUFBSSw4QkFBOEIsbUJBQUssTUFBTSxHQUFLLElBQUksRUFBRSxDQUFDO0FBQ2xFLENBQUM7QUFFRCxNQUFNO0lBQXFDLGdCQUE2QjtTQUE3QixVQUE2QixFQUE3QixxQkFBNkIsRUFBN0IsSUFBNkI7UUFBN0IsMkJBQTZCOztJQUN0RSxNQUFNLENBQUMsSUFBSSw4QkFBOEIsQ0FBSSxNQUFNLENBQUMsQ0FBQztBQUN2RCxDQUFDIiwiZmlsZSI6ImFzeW5jaXRlcmFibGUvb25lcnJvcnJlc3VtZW5leHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuXG5jbGFzcyBPbkVycm9yUmVzdW1lTmV4dEFzeW5jSXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG4gIHByaXZhdGUgX3NvdXJjZTogSXRlcmFibGU8QXN5bmNJdGVyYWJsZTxUU291cmNlPj47XG5cbiAgY29uc3RydWN0b3Ioc291cmNlOiBJdGVyYWJsZTxBc3luY0l0ZXJhYmxlPFRTb3VyY2U+Pikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGxldCBpdCA9IGl0ZW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dC5kb25lKSB7IGJyZWFrOyB9XG4gICAgICAgIHlpZWxkIG5leHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dDxUPihzb3VyY2U6IEFzeW5jSXRlcmFibGU8VD4sIC4uLmFyZ3M6IEFzeW5jSXRlcmFibGU8VD5bXSk6IEFzeW5jSXRlcmFibGVYPFQ+IHtcbiAgcmV0dXJuIG5ldyBPbkVycm9yUmVzdW1lTmV4dEFzeW5jSXRlcmFibGU8VD4oW3NvdXJjZSwgLi4uYXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWM8VD4oLi4uc291cmNlOiBBc3luY0l0ZXJhYmxlPFQ+W10pOiBBc3luY0l0ZXJhYmxlWDxUPiB7XG4gIHJldHVybiBuZXcgT25FcnJvclJlc3VtZU5leHRBc3luY0l0ZXJhYmxlPFQ+KHNvdXJjZSk7XG59XG4iXX0=
