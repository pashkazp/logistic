import * as tslib_1 from "tslib";
import { AsyncIterableX } from '../asynciterable';
import { MaxRefCountList, RefCountList } from '../iterable/_refcountlist';
import { create } from './create';
var MemoizeAsyncBuffer = (function (_super) {
    tslib_1.__extends(MemoizeAsyncBuffer, _super);
    function MemoizeAsyncBuffer(source, buffer) {
        var _this = _super.call(this) || this;
        _this._stopped = false;
        _this._source = source;
        _this._buffer = buffer;
        return _this;
    }
    MemoizeAsyncBuffer.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var i, hasValue, current, next, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 13, 14]);
                        _a.label = 2;
                    case 2:
                        if (!1) return [3 /*break*/, 12];
                        hasValue = false, current = {};
                        if (!(i >= this._buffer.count)) return [3 /*break*/, 7];
                        if (!!this._stopped) return [3 /*break*/, 6];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, tslib_1.__await(this._source.next())];
                    case 4:
                        next = _a.sent();
                        hasValue = !next.done;
                        if (hasValue) {
                            current = next.value;
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        this._error = e_1;
                        this._stopped = true;
                        return [3 /*break*/, 6];
                    case 6:
                        if (this._stopped) {
                            throw this._error;
                        }
                        if (hasValue) {
                            this._buffer.push(current);
                        }
                        return [3 /*break*/, 8];
                    case 7:
                        hasValue = true;
                        _a.label = 8;
                    case 8:
                        if (!hasValue) return [3 /*break*/, 10];
                        return [4 /*yield*/, this._buffer.get(i)];
                    case 9:
                        _a.sent();
                        return [3 /*break*/, 11];
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        i++;
                        return [3 /*break*/, 2];
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        this._buffer.done();
                        return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    return MemoizeAsyncBuffer;
}(AsyncIterableX));
export function memoize(source, readerCount, selector) {
    if (readerCount === void 0) { readerCount = -1; }
    if (readerCount === -1 && !selector) {
        return new MemoizeAsyncBuffer(source[Symbol.asyncIterator](), new MaxRefCountList());
    }
    if (readerCount !== -1 && !selector) {
        return new MemoizeAsyncBuffer(source[Symbol.asyncIterator](), new RefCountList(readerCount));
    }
    return create(function () { return selector(memoize(source, readerCount))[Symbol.asyncIterator](); });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvbWVtb2l6ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2xELE9BQU8sRUFBaUIsZUFBZSxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3pGLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFbEM7SUFBb0MsOENBQWlCO0lBTW5ELDRCQUFZLE1BQXdCLEVBQUUsTUFBd0I7UUFBOUQsWUFDRSxpQkFBTyxTQUdSO1FBTk8sY0FBUSxHQUFZLEtBQUssQ0FBQztRQUloQyxLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7SUFDeEIsQ0FBQztJQUVNLDZCQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBN0I7Ozs7Ozt3QkFDTSxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7NkJBRUQsQ0FBQzt3QkFDRixRQUFRLEdBQUcsS0FBSyxFQUFFLE9BQU8sR0FBTSxFQUFFLENBQUM7NkJBQ2xDLENBQUEsQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFBLEVBQXZCLHdCQUF1Qjs2QkFDckIsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFkLHdCQUFjOzs7O3dCQUVILHFDQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUE7O3dCQUFoQyxJQUFJLEdBQUcsU0FBeUI7d0JBQ3BDLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7d0JBQ3RCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7NEJBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7d0JBQUMsQ0FBQzs7Ozt3QkFFdkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFDLENBQUM7d0JBQ2hCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDOzs7d0JBSXpCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzRCQUNsQixNQUFNLElBQUksQ0FBQyxNQUFNLENBQUM7d0JBQ3BCLENBQUM7d0JBRUQsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzs0QkFBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFBQyxDQUFDOzs7d0JBRTdDLFFBQVEsR0FBRyxJQUFJLENBQUM7Ozs2QkFHZCxRQUFRLEVBQVIseUJBQVE7d0JBQ1YscUJBQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUE7O3dCQUF6QixTQUF5QixDQUFDOzs2QkFFMUIseUJBQU07O3dCQUdSLENBQUMsRUFBRSxDQUFDOzs7O3dCQUdOLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7Ozs7OztLQUV2QjtJQUNILHlCQUFDO0FBQUQsQ0FsREEsQUFrREMsQ0FsRG1DLGNBQWMsR0FrRGpEO0FBUUQsTUFBTSxrQkFDRixNQUE4QixFQUM5QixXQUF3QixFQUN4QixRQUFvRTtJQURwRSw0QkFBQSxFQUFBLGVBQXVCLENBQUM7SUFFMUIsRUFBRSxDQUFDLENBQUMsV0FBVyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNwQyxNQUFNLENBQUMsSUFBSSxrQkFBa0IsQ0FBVSxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsSUFBSSxlQUFlLEVBQVcsQ0FBQyxDQUFDO0lBQ3pHLENBQUM7SUFFRCxFQUFFLENBQUMsQ0FBQyxXQUFXLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sQ0FBQyxJQUFJLGtCQUFrQixDQUFVLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxJQUFJLFlBQVksQ0FBVSxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ2pILENBQUM7SUFFRCxNQUFNLENBQUMsTUFBTSxDQUFvQixjQUFNLE9BQUEsUUFBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBL0QsQ0FBK0QsQ0FBQyxDQUFDO0FBQzFHLENBQUMiLCJmaWxlIjoiYXN5bmNpdGVyYWJsZS9tZW1vaXplLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNJdGVyYWJsZVggfSBmcm9tICcuLi9hc3luY2l0ZXJhYmxlJztcbmltcG9ydCB7IElSZWZDb3VudExpc3QsIE1heFJlZkNvdW50TGlzdCwgUmVmQ291bnRMaXN0IH0gZnJvbSAnLi4vaXRlcmFibGUvX3JlZmNvdW50bGlzdCc7XG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICcuL2NyZWF0ZSc7XG5cbmNsYXNzIE1lbW9pemVBc3luY0J1ZmZlcjxUPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFQ+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBBc3luY0l0ZXJhdG9yPFQ+O1xuICBwcml2YXRlIF9idWZmZXI6IElSZWZDb3VudExpc3Q8VD47XG4gIHByaXZhdGUgX2Vycm9yOiBhbnk7XG4gIHByaXZhdGUgX3N0b3BwZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEFzeW5jSXRlcmF0b3I8VD4sIGJ1ZmZlcjogSVJlZkNvdW50TGlzdDxUPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgbGV0IGhhc1ZhbHVlID0gZmFsc2UsIGN1cnJlbnQgPSA8VD57fTtcbiAgICAgICAgaWYgKGkgPj0gdGhpcy5fYnVmZmVyLmNvdW50KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgbmV4dCA9IGF3YWl0IHRoaXMuX3NvdXJjZS5uZXh0KCk7XG4gICAgICAgICAgICAgIGhhc1ZhbHVlID0gIW5leHQuZG9uZTtcbiAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKSB7IGN1cnJlbnQgPSBuZXh0LnZhbHVlOyB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZTtcbiAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNWYWx1ZSkgeyB0aGlzLl9idWZmZXIucHVzaChjdXJyZW50KTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuX2J1ZmZlci5nZXQoaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2J1ZmZlci5kb25lKCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZTxUU291cmNlPihcbiAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgcmVhZGVyQ291bnQ/OiBudW1iZXIpOiBBc3luY0l0ZXJhYmxlWDxUU291cmNlPjtcbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplPFRTb3VyY2UsIFRSZXN1bHQ+KFxuICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICByZWFkZXJDb3VudD86IG51bWJlcixcbiAgICBzZWxlY3Rvcj86ICh2YWx1ZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPikgPT4gQXN5bmNJdGVyYWJsZTxUUmVzdWx0Pik6IEFzeW5jSXRlcmFibGVYPFRSZXN1bHQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8VFNvdXJjZSwgVFJlc3VsdCA9IFRTb3VyY2U+KFxuICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICByZWFkZXJDb3VudDogbnVtYmVyID0gLTEsXG4gICAgc2VsZWN0b3I/OiAodmFsdWU6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4pID0+IEFzeW5jSXRlcmFibGU8VFJlc3VsdD4pOiBBc3luY0l0ZXJhYmxlWDxUU291cmNlIHwgVFJlc3VsdD4ge1xuICBpZiAocmVhZGVyQ291bnQgPT09IC0xICYmICFzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgTWVtb2l6ZUFzeW5jQnVmZmVyPFRTb3VyY2U+KHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSwgbmV3IE1heFJlZkNvdW50TGlzdDxUU291cmNlPigpKTtcbiAgfVxuXG4gIGlmIChyZWFkZXJDb3VudCAhPT0gLTEgJiYgIXNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vaXplQXN5bmNCdWZmZXI8VFNvdXJjZT4oc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCBuZXcgUmVmQ291bnRMaXN0PFRTb3VyY2U+KHJlYWRlckNvdW50KSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlPFRTb3VyY2UgfCBUUmVzdWx0PigoKSA9PiBzZWxlY3RvciEobWVtb2l6ZShzb3VyY2UsIHJlYWRlckNvdW50KSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpO1xufVxuIl19
