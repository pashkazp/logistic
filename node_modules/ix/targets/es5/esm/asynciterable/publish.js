import * as tslib_1 from "tslib";
import { AsyncIterableX } from '../asynciterable';
import { RefCountList } from '../iterable/_refcountlist';
import { create } from './create';
var PublishedAsyncBuffer = (function (_super) {
    tslib_1.__extends(PublishedAsyncBuffer, _super);
    function PublishedAsyncBuffer(source) {
        var _this = _super.call(this) || this;
        _this._stopped = false;
        _this._source = source;
        _this._buffer = new RefCountList(0);
        return _this;
    }
    PublishedAsyncBuffer.prototype._getIterable = function (i) {
        return tslib_1.__asyncGenerator(this, arguments, function _getIterable_1() {
            var hasValue, current, next, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, , 12, 13]);
                        _a.label = 1;
                    case 1:
                        if (!1) return [3 /*break*/, 11];
                        hasValue = false, current = {};
                        if (!(i >= this._buffer.count)) return [3 /*break*/, 6];
                        if (!!this._stopped) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, tslib_1.__await(this._source.next())];
                    case 3:
                        next = _a.sent();
                        hasValue = !next.done;
                        if (hasValue) {
                            current = next.value;
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        this._error = e_1;
                        this._stopped = true;
                        return [3 /*break*/, 5];
                    case 5:
                        if (this._stopped) {
                            if (this._error) {
                                throw this._error;
                            }
                            else {
                                return [3 /*break*/, 11];
                            }
                        }
                        if (hasValue) {
                            this._buffer.push(current);
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        hasValue = true;
                        _a.label = 7;
                    case 7:
                        if (!hasValue) return [3 /*break*/, 9];
                        return [4 /*yield*/, this._buffer.get(i)];
                    case 8:
                        _a.sent();
                        return [3 /*break*/, 10];
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        i++;
                        return [3 /*break*/, 1];
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        this._buffer.done();
                        return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    PublishedAsyncBuffer.prototype[Symbol.asyncIterator] = function () {
        this._buffer.readerCount++;
        return this._getIterable(this._buffer.count)[Symbol.asyncIterator]();
    };
    return PublishedAsyncBuffer;
}(AsyncIterableX));
export function publish(source, selector) {
    var _this = this;
    return selector ?
        create(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, selector(publish(source))[Symbol.asyncIterator]()];
        }); }); }) :
        new PublishedAsyncBuffer(source[Symbol.asyncIterator]());
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvcHVibGlzaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRWxDO0lBQXNDLGdEQUFpQjtJQU1yRCw4QkFBWSxNQUF3QjtRQUFwQyxZQUNFLGlCQUFPLFNBR1I7UUFOTyxjQUFRLEdBQVksS0FBSyxDQUFDO1FBSWhDLEtBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUksQ0FBQyxDQUFDLENBQUM7O0lBQ3hDLENBQUM7SUFFYywyQ0FBWSxHQUEzQixVQUE0QixDQUFTOzs7Ozs7Ozs7NkJBRTFCLENBQUM7d0JBQ0YsUUFBUSxHQUFHLEtBQUssRUFBRSxPQUFPLEdBQU0sRUFBRSxDQUFDOzZCQUNsQyxDQUFBLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQSxFQUF2Qix3QkFBdUI7NkJBQ3JCLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBZCx3QkFBYzs7Ozt3QkFFSCxxQ0FBTSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFBOzt3QkFBaEMsSUFBSSxHQUFHLFNBQXlCO3dCQUNwQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO3dCQUN0QixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzRCQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO3dCQUFDLENBQUM7Ozs7d0JBRXZDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBQyxDQUFDO3dCQUNoQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQzs7O3dCQUl6QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzs0QkFDbEIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0NBQ2hCLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQzs0QkFDcEIsQ0FBQzs0QkFBQyxJQUFJLENBQUMsQ0FBQztnQ0FDTixNQUFNLG1CQUFBOzRCQUNSLENBQUM7d0JBQ0gsQ0FBQzt3QkFFRCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzRCQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUFDLENBQUM7Ozt3QkFFN0MsUUFBUSxHQUFHLElBQUksQ0FBQzs7OzZCQUdkLFFBQVEsRUFBUix3QkFBUTt3QkFDVixxQkFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQTs7d0JBQXpCLFNBQXlCLENBQUM7OzRCQUUxQix5QkFBTTs7d0JBR1IsQ0FBQyxFQUFFLENBQUM7Ozs7d0JBR04sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7Ozs7O0tBRXZCO0lBRUQsK0JBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUF0QjtRQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDM0IsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztJQUN2RSxDQUFDO0lBQ0gsMkJBQUM7QUFBRCxDQTFEQSxBQTBEQyxDQTFEcUMsY0FBYyxHQTBEbkQ7QUFNRCxNQUFNLGtCQUNGLE1BQThCLEVBQzlCLFFBQW9FO0lBRnhFLGlCQU1DO0lBSEMsTUFBTSxDQUFDLFFBQVE7UUFDYixNQUFNLENBQUM7WUFBWSxzQkFBQSxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUE7aUJBQUEsQ0FBQztRQUNyRSxJQUFJLG9CQUFvQixDQUFVLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RFLENBQUMiLCJmaWxlIjoiYXN5bmNpdGVyYWJsZS9wdWJsaXNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNJdGVyYWJsZVggfSBmcm9tICcuLi9hc3luY2l0ZXJhYmxlJztcbmltcG9ydCB7IFJlZkNvdW50TGlzdCB9IGZyb20gJy4uL2l0ZXJhYmxlL19yZWZjb3VudGxpc3QnO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi9jcmVhdGUnO1xuXG5jbGFzcyBQdWJsaXNoZWRBc3luY0J1ZmZlcjxUPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFQ+IHtcbiAgcHJpdmF0ZSBfYnVmZmVyOiBSZWZDb3VudExpc3Q8VD47XG4gIHByaXZhdGUgX3NvdXJjZTogQXN5bmNJdGVyYXRvcjxUPjtcbiAgcHJpdmF0ZSBfZXJyb3I6IGFueTtcbiAgcHJpdmF0ZSBfc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZTogQXN5bmNJdGVyYXRvcjxUPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBSZWZDb3VudExpc3Q8VD4oMCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jICpfZ2V0SXRlcmFibGUoaTogbnVtYmVyKTogQXN5bmNJdGVyYWJsZTxUPiB7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIGxldCBoYXNWYWx1ZSA9IGZhbHNlLCBjdXJyZW50ID0gPFQ+e307XG4gICAgICAgIGlmIChpID49IHRoaXMuX2J1ZmZlci5jb3VudCkge1xuICAgICAgICAgIGlmICghdGhpcy5fc3RvcHBlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IG5leHQgPSBhd2FpdCB0aGlzLl9zb3VyY2UubmV4dCgpO1xuICAgICAgICAgICAgICBoYXNWYWx1ZSA9ICFuZXh0LmRvbmU7XG4gICAgICAgICAgICAgIGlmIChoYXNWYWx1ZSkgeyBjdXJyZW50ID0gbmV4dC52YWx1ZTsgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGU7XG4gICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzVmFsdWUpIHsgdGhpcy5fYnVmZmVyLnB1c2goY3VycmVudCk7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLl9idWZmZXIuZ2V0KGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9idWZmZXIuZG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxUPiB7XG4gICAgdGhpcy5fYnVmZmVyLnJlYWRlckNvdW50Kys7XG4gICAgcmV0dXJuIHRoaXMuX2dldEl0ZXJhYmxlKHRoaXMuX2J1ZmZlci5jb3VudClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2g8VFNvdXJjZT4oc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KTogQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT47XG5leHBvcnQgZnVuY3Rpb24gcHVibGlzaDxUU291cmNlLCBUUmVzdWx0PihcbiAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICBzZWxlY3Rvcj86ICh2YWx1ZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPikgPT4gQXN5bmNJdGVyYWJsZTxUUmVzdWx0Pik6IEFzeW5jSXRlcmFibGVYPFRSZXN1bHQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2g8VFNvdXJjZSwgVFJlc3VsdD4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIHNlbGVjdG9yPzogKHZhbHVlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KSA9PiBBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+KTogQXN5bmNJdGVyYWJsZVg8VFNvdXJjZSB8IFRSZXN1bHQ+IHtcbiAgcmV0dXJuIHNlbGVjdG9yID9cbiAgICBjcmVhdGUoYXN5bmMgKCkgPT4gc2VsZWN0b3IocHVibGlzaChzb3VyY2UpKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSkgOlxuICAgIG5ldyBQdWJsaXNoZWRBc3luY0J1ZmZlcjxUU291cmNlPihzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpO1xufVxuIl19
