import * as tslib_1 from "tslib";
import { AsyncIterableX } from '../asynciterable';
import { toArray } from './toarray';
var ScanRightAsyncIterable = (function (_super) {
    tslib_1.__extends(ScanRightAsyncIterable, _super);
    function ScanRightAsyncIterable(source, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._fn = fn;
        _this._hasSeed = args.length === 1;
        _this._seed = args[0];
        return _this;
    }
    ScanRightAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var hasValue, source, offset, item, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        hasValue = false;
                        return [4 /*yield*/, tslib_1.__await(toArray(this._source))];
                    case 1:
                        source = _b.sent();
                        offset = source.length - 1;
                        _b.label = 2;
                    case 2:
                        if (!(offset >= 0)) return [3 /*break*/, 7];
                        item = source[offset];
                        if (!(hasValue || (hasValue = this._hasSeed))) return [3 /*break*/, 5];
                        _a = this;
                        return [4 /*yield*/, tslib_1.__await(this._fn(this._seed, item, offset))];
                    case 3:
                        _a._seed = _b.sent();
                        return [4 /*yield*/, this._seed];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        this._seed = item;
                        hasValue = true;
                        _b.label = 6;
                    case 6:
                        offset--;
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    return ScanRightAsyncIterable;
}(AsyncIterableX));
export function scanRight(source, accumulator) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return new (ScanRightAsyncIterable.bind.apply(ScanRightAsyncIterable, tslib_1.__spread([void 0, source, accumulator], args)))();
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvc2NhbnJpZ2h0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUVwQztJQUEyQyxrREFBaUI7SUFNMUQsZ0NBQ0ksTUFBd0IsRUFDeEIsRUFBdUQ7UUFDdkQsY0FBa0I7YUFBbEIsVUFBa0IsRUFBbEIscUJBQWtCLEVBQWxCLElBQWtCO1lBQWxCLDZCQUFrQjs7UUFIdEIsWUFJRSxpQkFBTyxTQUtSO1FBSkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsS0FBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDZCxLQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1FBQ2xDLEtBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUN2QixDQUFDO0lBRU0saUNBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUE3Qjs7Ozs7O3dCQUNNLFFBQVEsR0FBRyxLQUFLLENBQUM7d0JBQ04scUNBQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBQTs7d0JBQXBDLE1BQU0sR0FBRyxTQUEyQjt3QkFDakMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQzs7OzZCQUFFLENBQUEsTUFBTSxJQUFJLENBQUMsQ0FBQTt3QkFDeEMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzs2QkFDeEIsQ0FBQSxRQUFRLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBLEVBQXRDLHdCQUFzQzt3QkFDeEMsS0FBQSxJQUFJLENBQUE7d0JBQVMscUNBQU0sSUFBSSxDQUFDLEdBQUcsQ0FBSSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsR0FBQTs7d0JBQXhELEdBQUssS0FBSyxHQUFHLFNBQTJDLENBQUM7d0JBQ3pELHFCQUFNLElBQUksQ0FBQyxLQUFLLEVBQUE7O3dCQUFoQixTQUFnQixDQUFDOzs7d0JBRWpCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO3dCQUNsQixRQUFRLEdBQUcsSUFBSSxDQUFDOzs7d0JBUDhCLE1BQU0sRUFBRSxDQUFBOzs7Ozs7S0FVM0Q7SUFDSCw2QkFBQztBQUFELENBL0JBLEFBK0JDLENBL0IwQyxjQUFjLEdBK0J4RDtBQVNELE1BQU0sb0JBQ0YsTUFBd0IsRUFDeEIsV0FBb0U7SUFDcEUsY0FBa0I7U0FBbEIsVUFBa0IsRUFBbEIscUJBQWtCLEVBQWxCLElBQWtCO1FBQWxCLDZCQUFrQjs7SUFDcEIsTUFBTSxNQUFLLHNCQUFzQixZQUF0QixzQkFBc0IsNEJBQUMsTUFBTSxFQUFFLFdBQVcsR0FBSyxJQUFJLE1BQUU7QUFDbEUsQ0FBQyIsImZpbGUiOiJhc3luY2l0ZXJhYmxlL3NjYW5yaWdodC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5pbXBvcnQgeyB0b0FycmF5IH0gZnJvbSAnLi90b2FycmF5JztcblxuY2xhc3MgU2NhblJpZ2h0QXN5bmNJdGVyYWJsZTxULCBSPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFI+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBBc3luY0l0ZXJhYmxlPFQ+O1xuICBwcml2YXRlIF9mbjogKGFjYzogVCB8IFIsIHg6IFQsIGluZGV4OiBudW1iZXIpID0+IFIgfCBQcm9taXNlPFI+O1xuICBwcml2YXRlIF9zZWVkPzogVCB8IFI7XG4gIHByaXZhdGUgX2hhc1NlZWQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VD4sXG4gICAgICBmbjogKGFjYzogVCB8IFIsIHg6IFQsIGluZGV4OiBudW1iZXIpID0+IFIgfCBQcm9taXNlPFI+LFxuICAgICAgLi4uYXJnczogKFQgfCBSKVtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fZm4gPSBmbjtcbiAgICB0aGlzLl9oYXNTZWVkID0gYXJncy5sZW5ndGggPT09IDE7XG4gICAgdGhpcy5fc2VlZCA9IGFyZ3NbMF07XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICBjb25zdCBzb3VyY2UgPSBhd2FpdCB0b0FycmF5KHRoaXMuX3NvdXJjZSk7XG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gc291cmNlLmxlbmd0aCAtIDE7IG9mZnNldCA+PSAwOyBvZmZzZXQtLSkge1xuICAgICAgY29uc3QgaXRlbSA9IHNvdXJjZVtvZmZzZXRdO1xuICAgICAgaWYgKGhhc1ZhbHVlIHx8IChoYXNWYWx1ZSA9IHRoaXMuX2hhc1NlZWQpKSB7XG4gICAgICAgIHRoaXMuX3NlZWQgPSBhd2FpdCB0aGlzLl9mbig8Uj50aGlzLl9zZWVkLCBpdGVtLCBvZmZzZXQpO1xuICAgICAgICB5aWVsZCB0aGlzLl9zZWVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VlZCA9IGl0ZW07XG4gICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYW5SaWdodDxUPihcbiAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFQ+LFxuICBhY2N1bXVsYXRvcjogKGFjYzogVCwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFQgfCBQcm9taXNlPFQ+KTogQXN5bmNJdGVyYWJsZVg8VD47XG5leHBvcnQgZnVuY3Rpb24gc2NhblJpZ2h0PFQsIFIgPSBUPihcbiAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFQ+LFxuICBhY2N1bXVsYXRvcjogKGFjYzogUiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIgfCBQcm9taXNlPFI+LFxuICBzZWVkOiBSKTogQXN5bmNJdGVyYWJsZVg8Uj47XG5leHBvcnQgZnVuY3Rpb24gc2NhblJpZ2h0PFQsIFIgPSBUPihcbiAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VD4sXG4gICAgYWNjdW11bGF0b3I6IChhY2M6IFQgfCBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUiB8IFByb21pc2U8Uj4sXG4gICAgLi4uYXJnczogKFQgfCBSKVtdKTogQXN5bmNJdGVyYWJsZVg8VCB8IFI+IHtcbiAgcmV0dXJuIG5ldyBTY2FuUmlnaHRBc3luY0l0ZXJhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIC4uLmFyZ3MpO1xufVxuIl19
