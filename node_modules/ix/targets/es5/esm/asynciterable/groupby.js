import * as tslib_1 from "tslib";
import { AsyncIterableX } from '../asynciterable';
import { identityAsync } from '../internal/identity';
import { createGrouping } from './_grouping';
var GroupedAsyncIterable = (function (_super) {
    tslib_1.__extends(GroupedAsyncIterable, _super);
    function GroupedAsyncIterable(key, source) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this._source = source;
        return _this;
    }
    GroupedAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var _a, _b, item, e_1_1, e_1, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 5, 6, 7]);
                        _a = tslib_1.__values(this._source), _b = _a.next();
                        _d.label = 1;
                    case 1:
                        if (!!_b.done) return [3 /*break*/, 4];
                        item = _b.value;
                        return [4 /*yield*/, item];
                    case 2:
                        _d.sent();
                        _d.label = 3;
                    case 3:
                        _b = _a.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_1_1 = _d.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    return GroupedAsyncIterable;
}(AsyncIterableX));
export { GroupedAsyncIterable };
var GroupByAsyncIterable = (function (_super) {
    tslib_1.__extends(GroupByAsyncIterable, _super);
    function GroupByAsyncIterable(source, keySelector, elementSelector) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._keySelector = keySelector;
        _this._elementSelector = elementSelector;
        return _this;
    }
    GroupByAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var map, map_1, map_1_1, _a, key, values, e_2_1, e_2, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, tslib_1.__await(createGrouping(this._source, this._keySelector, this._elementSelector))];
                    case 1:
                        map = _c.sent();
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 7, 8, 9]);
                        map_1 = tslib_1.__values(map), map_1_1 = map_1.next();
                        _c.label = 3;
                    case 3:
                        if (!!map_1_1.done) return [3 /*break*/, 6];
                        _a = tslib_1.__read(map_1_1.value, 2), key = _a[0], values = _a[1];
                        return [4 /*yield*/, new GroupedAsyncIterable(key, values)];
                    case 4:
                        _c.sent();
                        _c.label = 5;
                    case 5:
                        map_1_1 = map_1.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_2_1 = _c.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (map_1_1 && !map_1_1.done && (_b = map_1.return)) _b.call(map_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    return GroupByAsyncIterable;
}(AsyncIterableX));
export { GroupByAsyncIterable };
export function groupBy(source, keySelector, elementSelector) {
    if (elementSelector === void 0) { elementSelector = identityAsync; }
    return new GroupByAsyncIterable(source, keySelector, elementSelector);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvZ3JvdXBieS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRTdDO0lBQXdELGdEQUFzQjtJQUk1RSw4QkFBWSxHQUFTLEVBQUUsTUFBd0I7UUFBL0MsWUFDRSxpQkFBTyxTQUdSO1FBRkMsS0FBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7SUFDeEIsQ0FBQztJQUVNLCtCQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBN0I7Ozs7Ozs7d0JBQ21CLEtBQUEsaUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQTs7Ozt3QkFBcEIsSUFBSTt3QkFDWCxxQkFBTSxJQUFJLEVBQUE7O3dCQUFWLFNBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FFZDtJQUNILDJCQUFDO0FBQUQsQ0FmQSxBQWVDLENBZnVELGNBQWMsR0FlckU7O0FBRUQ7SUFBaUUsZ0RBQWtEO0lBS2pILDhCQUNJLE1BQThCLEVBQzlCLFdBQXFELEVBQ3JELGVBQTZEO1FBSGpFLFlBSUUsaUJBQU8sU0FJUjtRQUhDLEtBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLEtBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2hDLEtBQUksQ0FBQyxnQkFBZ0IsR0FBRyxlQUFlLENBQUM7O0lBQzFDLENBQUM7SUFFTSwrQkFBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQTdCOzs7Ozs0QkFDYyxxQ0FBTSxjQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFBOzt3QkFBbEYsR0FBRyxHQUFHLFNBQTRFOzs7O3dCQUM5RCxRQUFBLGlCQUFBLEdBQUcsQ0FBQTs7Ozt3QkFBcEIsS0FBQSxnQ0FBYSxFQUFaLEdBQUcsUUFBQSxFQUFFLE1BQU0sUUFBQTt3QkFDbkIscUJBQU0sSUFBSSxvQkFBb0IsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLEVBQUE7O3dCQUEzQyxTQUEyQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUUvQztJQUNILDJCQUFDO0FBQUQsQ0FyQkEsQUFxQkMsQ0FyQmdFLGNBQWMsR0FxQjlFOztBQVNELE1BQU0sa0JBQ0YsTUFBOEIsRUFDOUIsV0FBcUQsRUFDckQsZUFBNkU7SUFBN0UsZ0NBQUEsRUFBQSwrQkFBNkU7SUFFL0UsTUFBTSxDQUFDLElBQUksb0JBQW9CLENBQXdCLE1BQU0sRUFBRSxXQUFXLEVBQUUsZUFBZSxDQUFDLENBQUM7QUFDL0YsQ0FBQyIsImZpbGUiOiJhc3luY2l0ZXJhYmxlL2dyb3VwYnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuaW1wb3J0IHsgaWRlbnRpdHlBc3luYyB9IGZyb20gJy4uL2ludGVybmFsL2lkZW50aXR5JztcbmltcG9ydCB7IGNyZWF0ZUdyb3VwaW5nIH0gZnJvbSAnLi9fZ3JvdXBpbmcnO1xuXG5leHBvcnQgY2xhc3MgR3JvdXBlZEFzeW5jSXRlcmFibGU8VEtleSwgVFZhbHVlPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFRWYWx1ZT4ge1xuICBwdWJsaWMgcmVhZG9ubHkga2V5OiBUS2V5O1xuICBwcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPFRWYWx1ZT47XG5cbiAgY29uc3RydWN0b3Ioa2V5OiBUS2V5LCBzb3VyY2U6IEl0ZXJhYmxlPFRWYWx1ZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICB5aWVsZCBpdGVtO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR3JvdXBCeUFzeW5jSXRlcmFibGU8VFNvdXJjZSwgVEtleSwgVFZhbHVlPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPEdyb3VwZWRBc3luY0l0ZXJhYmxlPFRLZXksIFRWYWx1ZT4+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9rZXlTZWxlY3RvcjogKHZhbHVlOiBUU291cmNlKSA9PiBUS2V5IHwgUHJvbWlzZTxUS2V5PjtcbiAgcHJpdmF0ZSBfZWxlbWVudFNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRWYWx1ZSB8IFByb21pc2U8VFZhbHVlPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+LFxuICAgICAgZWxlbWVudFNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRWYWx1ZSB8IFByb21pc2U8VFZhbHVlPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2tleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgdGhpcy5fZWxlbWVudFNlbGVjdG9yID0gZWxlbWVudFNlbGVjdG9yO1xuICB9XG5cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgbWFwID0gYXdhaXQgY3JlYXRlR3JvdXBpbmcodGhpcy5fc291cmNlLCB0aGlzLl9rZXlTZWxlY3RvciwgdGhpcy5fZWxlbWVudFNlbGVjdG9yKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZXNdIG9mIG1hcCkge1xuICAgICAgeWllbGQgbmV3IEdyb3VwZWRBc3luY0l0ZXJhYmxlKGtleSwgdmFsdWVzKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnk8VFNvdXJjZSwgVEtleT4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIGtleVNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+KTogQXN5bmNJdGVyYWJsZVg8R3JvdXBlZEFzeW5jSXRlcmFibGU8VEtleSwgVFNvdXJjZT4+O1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnk8VFNvdXJjZSwgVEtleSwgVFZhbHVlPihcbiAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICBrZXlTZWxlY3RvcjogKHZhbHVlOiBUU291cmNlKSA9PiBUS2V5IHwgUHJvbWlzZTxUS2V5PixcbiAgZWxlbWVudFNlbGVjdG9yPzogKHZhbHVlOiBUU291cmNlKSA9PiBUVmFsdWUgfCBQcm9taXNlPFRWYWx1ZT4pOiBBc3luY0l0ZXJhYmxlWDxHcm91cGVkQXN5bmNJdGVyYWJsZTxUS2V5LCBUVmFsdWU+PjtcbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5PFRTb3VyY2UsIFRLZXksIFRWYWx1ZT4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIGtleVNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+LFxuICAgIGVsZW1lbnRTZWxlY3RvcjogKHZhbHVlOiBUU291cmNlKSA9PiBUVmFsdWUgfCBQcm9taXNlPFRWYWx1ZT4gPSBpZGVudGl0eUFzeW5jKTpcbiAgICBBc3luY0l0ZXJhYmxlWDxHcm91cGVkQXN5bmNJdGVyYWJsZTxUS2V5LCBUVmFsdWU+PiB7XG4gIHJldHVybiBuZXcgR3JvdXBCeUFzeW5jSXRlcmFibGU8VFNvdXJjZSwgVEtleSwgVFZhbHVlPihzb3VyY2UsIGtleVNlbGVjdG9yLCBlbGVtZW50U2VsZWN0b3IpO1xufVxuIl19
