import { defer } from './defer';
import { empty } from './empty';
/**
 * Returns a sequence from a dictionary based on the result of evaluating a selector function.
 * @example
 * const map = new Map([
 *   [1, [1, 2, 3]],
 *   [2, [2, 3, 4]],
 *   [3, [4, 5, 6]]
 * ]);
 * const result = case(
 *   () => 2,
 *   map,
 *   [5, 6, 7]
 * );
 * const result = Ix.Iterable.case(
 *   () => 2,
 *   map,
 *   [5, 6, 7]
 * );
 * for (const item of result) {
 *   console.log(result);
 * }
 * @param {function(): TSource} selector Selector function used to pick a sequence from the given sources.
 * @param {Map<TSource, Iterable<TResult>>} sources Dictionary mapping selector values onto resulting sequences.
 * @param {Iterable<TResult>} [defaultSource] Default sequence to return in case there's no corresponding source
 * for the computed selector value.  If not specified, defaults to an empty sequence.
 * @return {Iterable<TResult>} The source sequence corresponding with the evaluated selector value; otherwise, the default source.
 */
export function _case(selector, sources, defaultSource) {
    if (defaultSource === void 0) { defaultSource = empty(); }
    return defer(function () {
        var key = selector();
        return sources.has(key) ? sources.get(key) : defaultSource;
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2Nhc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBCRztBQUNILE1BQU0sZ0JBQ0YsUUFBdUIsRUFDdkIsT0FBd0MsRUFDeEMsYUFBbUQ7SUFBbkQsOEJBQUEsRUFBQSxnQkFBbUMsS0FBSyxFQUFXO0lBQ3JELE1BQU0sQ0FBQyxLQUFLLENBQVU7UUFDcEIsSUFBTSxHQUFHLEdBQUcsUUFBUSxFQUFFLENBQUM7UUFDdkIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUUsR0FBRyxhQUFhLENBQUM7SUFDOUQsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwiZmlsZSI6Iml0ZXJhYmxlL2Nhc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5pbXBvcnQgeyBkZWZlciB9IGZyb20gJy4vZGVmZXInO1xuaW1wb3J0IHsgZW1wdHkgfSBmcm9tICcuL2VtcHR5JztcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2VxdWVuY2UgZnJvbSBhIGRpY3Rpb25hcnkgYmFzZWQgb24gdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIGEgc2VsZWN0b3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWFwID0gbmV3IE1hcChbXG4gKiAgIFsxLCBbMSwgMiwgM11dLFxuICogICBbMiwgWzIsIDMsIDRdXSxcbiAqICAgWzMsIFs0LCA1LCA2XV1cbiAqIF0pO1xuICogY29uc3QgcmVzdWx0ID0gY2FzZShcbiAqICAgKCkgPT4gMixcbiAqICAgbWFwLFxuICogICBbNSwgNiwgN11cbiAqICk7XG4gKiBjb25zdCByZXN1bHQgPSBJeC5JdGVyYWJsZS5jYXNlKFxuICogICAoKSA9PiAyLFxuICogICBtYXAsXG4gKiAgIFs1LCA2LCA3XVxuICogKTtcbiAqIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogVFNvdXJjZX0gc2VsZWN0b3IgU2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0byBwaWNrIGEgc2VxdWVuY2UgZnJvbSB0aGUgZ2l2ZW4gc291cmNlcy5cbiAqIEBwYXJhbSB7TWFwPFRTb3VyY2UsIEl0ZXJhYmxlPFRSZXN1bHQ+Pn0gc291cmNlcyBEaWN0aW9uYXJ5IG1hcHBpbmcgc2VsZWN0b3IgdmFsdWVzIG9udG8gcmVzdWx0aW5nIHNlcXVlbmNlcy5cbiAqIEBwYXJhbSB7SXRlcmFibGU8VFJlc3VsdD59IFtkZWZhdWx0U291cmNlXSBEZWZhdWx0IHNlcXVlbmNlIHRvIHJldHVybiBpbiBjYXNlIHRoZXJlJ3Mgbm8gY29ycmVzcG9uZGluZyBzb3VyY2VcbiAqIGZvciB0aGUgY29tcHV0ZWQgc2VsZWN0b3IgdmFsdWUuICBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzZXF1ZW5jZS5cbiAqIEByZXR1cm4ge0l0ZXJhYmxlPFRSZXN1bHQ+fSBUaGUgc291cmNlIHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgd2l0aCB0aGUgZXZhbHVhdGVkIHNlbGVjdG9yIHZhbHVlOyBvdGhlcndpc2UsIHRoZSBkZWZhdWx0IHNvdXJjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXNlPFRTb3VyY2UsIFRSZXN1bHQ+KFxuICAgIHNlbGVjdG9yOiAoKSA9PiBUU291cmNlLFxuICAgIHNvdXJjZXM6IE1hcDxUU291cmNlLCBJdGVyYWJsZTxUUmVzdWx0Pj4sXG4gICAgZGVmYXVsdFNvdXJjZTogSXRlcmFibGU8VFJlc3VsdD4gPSBlbXB0eTxUUmVzdWx0PigpKTogSXRlcmFibGVYPFRSZXN1bHQ+IHtcbiAgcmV0dXJuIGRlZmVyPFRSZXN1bHQ+KCgpID0+IHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RvcigpO1xuICAgIHJldHVybiBzb3VyY2VzLmhhcyhrZXkpID8gc291cmNlcy5nZXQoa2V5KSEgOiBkZWZhdWx0U291cmNlO1xuICB9KTtcbn1cbiJdfQ==
