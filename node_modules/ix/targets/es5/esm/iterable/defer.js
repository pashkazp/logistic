import * as tslib_1 from "tslib";
import { IterableX } from '../iterable';
var DeferIterable = (function (_super) {
    tslib_1.__extends(DeferIterable, _super);
    function DeferIterable(fn) {
        var _this = _super.call(this) || this;
        _this._fn = fn;
        return _this;
    }
    DeferIterable.prototype[Symbol.iterator] = function () {
        var _a, _b, item, e_1_1, e_1, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _d.trys.push([0, 5, 6, 7]);
                    _a = tslib_1.__values(this._fn()), _b = _a.next();
                    _d.label = 1;
                case 1:
                    if (!!_b.done) return [3 /*break*/, 4];
                    item = _b.value;
                    return [4 /*yield*/, item];
                case 2:
                    _d.sent();
                    _d.label = 3;
                case 3:
                    _b = _a.next();
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 7];
                case 5:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 7];
                case 6:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    };
    return DeferIterable;
}(IterableX));
/**
 * Creates an enumerable sequence based on an iterable factory function.
 * @param {function(): Iterable<T>} factory Iterable factory function.
 * @return {Iterable<T>} Sequence that will invoke the iterable factory upon a call to [Symbol.iterator]().
 */
export function defer(factory) {
    return new DeferIterable(factory);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2RlZmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXhDO0lBQStCLHlDQUFZO0lBR3pDLHVCQUFZLEVBQXFCO1FBQWpDLFlBQ0UsaUJBQU8sU0FFUjtRQURDLEtBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDOztJQUNoQixDQUFDO0lBRUEsd0JBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFsQjs7Ozs7O29CQUNtQixLQUFBLGlCQUFBLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQTs7OztvQkFBbEIsSUFBSTtvQkFDWCxxQkFBTSxJQUFJLEVBQUE7O29CQUFWLFNBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUVkO0lBQ0gsb0JBQUM7QUFBRCxDQWJBLEFBYUMsQ0FiOEIsU0FBUyxHQWF2QztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLGdCQUF5QixPQUFnQztJQUM3RCxNQUFNLENBQUMsSUFBSSxhQUFhLENBQVUsT0FBTyxDQUFDLENBQUM7QUFDN0MsQ0FBQyIsImZpbGUiOiJpdGVyYWJsZS9kZWZlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZXJhYmxlWCB9IGZyb20gJy4uL2l0ZXJhYmxlJztcblxuY2xhc3MgRGVmZXJJdGVyYWJsZTxUPiBleHRlbmRzIEl0ZXJhYmxlWDxUPiB7XG4gIHByaXZhdGUgX2ZuOiAoKSA9PiBJdGVyYWJsZTxUPjtcblxuICBjb25zdHJ1Y3RvcihmbjogKCkgPT4gSXRlcmFibGU8VD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2ZuID0gZm47XG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9mbigpKSB7XG4gICAgICB5aWVsZCBpdGVtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW51bWVyYWJsZSBzZXF1ZW5jZSBiYXNlZCBvbiBhbiBpdGVyYWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBJdGVyYWJsZTxUPn0gZmFjdG9yeSBJdGVyYWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICogQHJldHVybiB7SXRlcmFibGU8VD59IFNlcXVlbmNlIHRoYXQgd2lsbCBpbnZva2UgdGhlIGl0ZXJhYmxlIGZhY3RvcnkgdXBvbiBhIGNhbGwgdG8gW1N5bWJvbC5pdGVyYXRvcl0oKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVyPFRTb3VyY2U+KGZhY3Rvcnk6ICgpID0+IEl0ZXJhYmxlPFRTb3VyY2U+KTogSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBEZWZlckl0ZXJhYmxlPFRTb3VyY2U+KGZhY3RvcnkpO1xufVxuIl19
