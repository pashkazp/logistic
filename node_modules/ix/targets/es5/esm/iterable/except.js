import * as tslib_1 from "tslib";
import { IterableX } from '../iterable';
import { arrayIndexOf } from '../internal/arrayindexof';
import { comparer as defaultComparer } from '../internal/comparer';
var ExceptIterable = (function (_super) {
    tslib_1.__extends(ExceptIterable, _super);
    function ExceptIterable(first, second, comparer) {
        var _this = _super.call(this) || this;
        _this._first = first;
        _this._second = second;
        _this._comparer = comparer;
        return _this;
    }
    ExceptIterable.prototype[Symbol.iterator] = function () {
        var map, _a, _b, secondItem, _c, _d, firstItem, e_1_1, e_2, _e, e_1, _f;
        return tslib_1.__generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    map = [];
                    try {
                        for (_a = tslib_1.__values(this._second), _b = _a.next(); !_b.done; _b = _a.next()) {
                            secondItem = _b.value;
                            map.push(secondItem);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    _g.label = 1;
                case 1:
                    _g.trys.push([1, 6, 7, 8]);
                    _c = tslib_1.__values(this._first), _d = _c.next();
                    _g.label = 2;
                case 2:
                    if (!!_d.done) return [3 /*break*/, 5];
                    firstItem = _d.value;
                    if (!(arrayIndexOf(map, firstItem, this._comparer) === -1)) return [3 /*break*/, 4];
                    map.push(firstItem);
                    return [4 /*yield*/, firstItem];
                case 3:
                    _g.sent();
                    _g.label = 4;
                case 4:
                    _d = _c.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _g.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/];
            }
        });
    };
    return ExceptIterable;
}(IterableX));
/**
 * Produces the set difference of two sequences by using the an equality comparer to compare values.
 * @param {Iterable<T>} first A sequence whose elements that are not also in second will be returned.
 * @param {Iterable<T>} second A sequence whose elements that also occur in the first sequence will cause those
 * elements to be removed from the returned sequence.
 * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.
 * @return {Iterable<T>} A sequence that contains the set difference of the elements of two sequences.
 */
export function except(first, second, comparer) {
    if (comparer === void 0) { comparer = defaultComparer; }
    return new ExceptIterable(first, second, comparer);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2V4Y2VwdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN4QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFFBQVEsSUFBSSxlQUFlLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUVuRTtJQUFzQywwQ0FBa0I7SUFLdEQsd0JBQVksS0FBd0IsRUFBRSxNQUF5QixFQUFFLFFBQTZDO1FBQTlHLFlBQ0UsaUJBQU8sU0FJUjtRQUhDLEtBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLEtBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLEtBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDOztJQUM1QixDQUFDO0lBRUEseUJBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFsQjs7Ozs7b0JBQ00sR0FBRyxHQUFHLEVBQUUsQ0FBQzs7d0JBQ2IsR0FBRyxDQUFDLENBQW1CLEtBQUEsaUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQTs0QkFBMUIsVUFBVTs0QkFDakIsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzt5QkFDdEI7Ozs7Ozs7Ozs7OztvQkFFcUIsS0FBQSxpQkFBQSxJQUFJLENBQUMsTUFBTSxDQUFBOzs7O29CQUF4QixTQUFTO3lCQUNaLENBQUEsWUFBWSxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBLEVBQW5ELHdCQUFtRDtvQkFDckQsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDcEIscUJBQU0sU0FBUyxFQUFBOztvQkFBZixTQUFlLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FHckI7SUFDSCxxQkFBQztBQUFELENBekJBLEFBeUJDLENBekJxQyxTQUFTLEdBeUI5QztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLGlCQUNGLEtBQXdCLEVBQ3hCLE1BQXlCLEVBQ3pCLFFBQStEO0lBQS9ELHlCQUFBLEVBQUEsMEJBQStEO0lBQ2pFLE1BQU0sQ0FBQyxJQUFJLGNBQWMsQ0FBVSxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzlELENBQUMiLCJmaWxlIjoiaXRlcmFibGUvZXhjZXB0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuaW1wb3J0IHsgYXJyYXlJbmRleE9mIH0gZnJvbSAnLi4vaW50ZXJuYWwvYXJyYXlpbmRleG9mJztcbmltcG9ydCB7IGNvbXBhcmVyIGFzIGRlZmF1bHRDb21wYXJlciB9IGZyb20gJy4uL2ludGVybmFsL2NvbXBhcmVyJztcblxuY2xhc3MgRXhjZXB0SXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBwcml2YXRlIF9maXJzdDogSXRlcmFibGU8VFNvdXJjZT47XG4gIHByaXZhdGUgX3NlY29uZDogSXRlcmFibGU8VFNvdXJjZT47XG4gIHByaXZhdGUgX2NvbXBhcmVyOiAoeDogVFNvdXJjZSwgeTogVFNvdXJjZSkgPT4gYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihmaXJzdDogSXRlcmFibGU8VFNvdXJjZT4sIHNlY29uZDogSXRlcmFibGU8VFNvdXJjZT4sIGNvbXBhcmVyOiAoeDogVFNvdXJjZSwgeTogVFNvdXJjZSkgPT4gYm9vbGVhbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZmlyc3QgPSBmaXJzdDtcbiAgICB0aGlzLl9zZWNvbmQgPSBzZWNvbmQ7XG4gICAgdGhpcy5fY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgbWFwID0gW107XG4gICAgZm9yIChsZXQgc2Vjb25kSXRlbSBvZiB0aGlzLl9zZWNvbmQpIHtcbiAgICAgIG1hcC5wdXNoKHNlY29uZEl0ZW0pO1xuICAgIH1cblxuICAgIGZvciAobGV0IGZpcnN0SXRlbSBvZiB0aGlzLl9maXJzdCkge1xuICAgICAgaWYgKGFycmF5SW5kZXhPZihtYXAsIGZpcnN0SXRlbSwgdGhpcy5fY29tcGFyZXIpID09PSAtMSkge1xuICAgICAgICBtYXAucHVzaChmaXJzdEl0ZW0pO1xuICAgICAgICB5aWVsZCBmaXJzdEl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHJvZHVjZXMgdGhlIHNldCBkaWZmZXJlbmNlIG9mIHR3byBzZXF1ZW5jZXMgYnkgdXNpbmcgdGhlIGFuIGVxdWFsaXR5IGNvbXBhcmVyIHRvIGNvbXBhcmUgdmFsdWVzLlxuICogQHBhcmFtIHtJdGVyYWJsZTxUPn0gZmlyc3QgQSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgYWxzbyBpbiBzZWNvbmQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7SXRlcmFibGU8VD59IHNlY29uZCBBIHNlcXVlbmNlIHdob3NlIGVsZW1lbnRzIHRoYXQgYWxzbyBvY2N1ciBpbiB0aGUgZmlyc3Qgc2VxdWVuY2Ugd2lsbCBjYXVzZSB0aG9zZVxuICogZWxlbWVudHMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSByZXR1cm5lZCBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogVEtleSwgeTogVEtleSk6IGJvb2xlYW59IFtjb21wYXJlcl0gQ29tcGFyZXIgdXNlZCB0byBjb21wYXJlIGtleSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtJdGVyYWJsZTxUPn0gQSBzZXF1ZW5jZSB0aGF0IGNvbnRhaW5zIHRoZSBzZXQgZGlmZmVyZW5jZSBvZiB0aGUgZWxlbWVudHMgb2YgdHdvIHNlcXVlbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VwdDxUU291cmNlPihcbiAgICBmaXJzdDogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgc2Vjb25kOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICBjb21wYXJlcjogKHg6IFRTb3VyY2UsIHk6IFRTb3VyY2UpID0+IGJvb2xlYW4gPSBkZWZhdWx0Q29tcGFyZXIpOiBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IEV4Y2VwdEl0ZXJhYmxlPFRTb3VyY2U+KGZpcnN0LCBzZWNvbmQsIGNvbXBhcmVyKTtcbn1cbiJdfQ==
