import * as tslib_1 from "tslib";
import { IterableX } from '../iterable';
import { returnIterator } from '../internal/returniterator';
var CatchWithIterable = (function (_super) {
    tslib_1.__extends(CatchWithIterable, _super);
    function CatchWithIterable(source, handler) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._handler = handler;
        return _this;
    }
    CatchWithIterable.prototype[Symbol.iterator] = function () {
        var err, hasError, it, c, _a, _b, item, e_1_1, e_1, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    hasError = false, it = this._source[Symbol.iterator]();
                    _d.label = 1;
                case 1:
                    if (!1) return [3 /*break*/, 3];
                    c = {};
                    try {
                        c = it.next();
                        if (c.done) {
                            returnIterator(it);
                            return [3 /*break*/, 3];
                        }
                    }
                    catch (e) {
                        err = this._handler(e);
                        hasError = true;
                        returnIterator(it);
                        return [3 /*break*/, 3];
                    }
                    return [4 /*yield*/, c.value];
                case 2:
                    _d.sent();
                    return [3 /*break*/, 1];
                case 3:
                    if (!hasError) return [3 /*break*/, 11];
                    _d.label = 4;
                case 4:
                    _d.trys.push([4, 9, 10, 11]);
                    _a = tslib_1.__values(err), _b = _a.next();
                    _d.label = 5;
                case 5:
                    if (!!_b.done) return [3 /*break*/, 8];
                    item = _b.value;
                    return [4 /*yield*/, item];
                case 6:
                    _d.sent();
                    _d.label = 7;
                case 7:
                    _b = _a.next();
                    return [3 /*break*/, 5];
                case 8: return [3 /*break*/, 11];
                case 9:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 11];
                case 10:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 11: return [2 /*return*/];
            }
        });
    };
    return CatchWithIterable;
}(IterableX));
/**
 * Creates a sequence that corresponds to the source sequence, concatenating it with the sequence resulting from
 * calling an exception handler function in case of an error.
 * @param {Iterable<TSource>} source Source sequence
 * @param {function(error: any): Iterable<TSource>} handler Handler to invoke when an exception of the specified type occurs.
 * @return {Iterable<TSource>} Source sequence, concatenated with an exception handler result sequence in case of an error.
 */
export function catchWith(source, handler) {
    return new CatchWithIterable(source, handler);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2NhdGNod2l0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN4QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFFNUQ7SUFBeUMsNkNBQWtCO0lBSXpELDJCQUFZLE1BQXlCLEVBQUUsT0FBMEM7UUFBakYsWUFDRSxpQkFBTyxTQUdSO1FBRkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsS0FBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7O0lBQzFCLENBQUM7SUFFQSw0QkFBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQWxCOzs7OztvQkFDMEMsUUFBUSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQzs7O3lCQUN4RixDQUFDO29CQUNGLENBQUMsR0FBNEIsRUFBRSxDQUFDO29CQUVwQyxJQUFJLENBQUM7d0JBQ0gsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQzt3QkFDZCxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs0QkFDWCxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7NEJBQ25CLE1BQU0sa0JBQUE7d0JBQ1IsQ0FBQztvQkFDSCxDQUFDO29CQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ1gsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZCLFFBQVEsR0FBRyxJQUFJLENBQUM7d0JBQ2hCLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQzt3QkFDbkIsTUFBTSxrQkFBQTtvQkFDUixDQUFDO29CQUVELHFCQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUE7O29CQUFiLFNBQWEsQ0FBQzs7O3lCQUdaLFFBQVEsRUFBUix5QkFBUTs7OztvQkFDTyxLQUFBLGlCQUFBLEdBQUksQ0FBQTs7OztvQkFBWixJQUFJO29CQUNYLHFCQUFNLElBQUksRUFBQTs7b0JBQVYsU0FBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBR2hCO0lBQ0gsd0JBQUM7QUFBRCxDQXJDQSxBQXFDQyxDQXJDd0MsU0FBUyxHQXFDakQ7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLG9CQUNGLE1BQXlCLEVBQ3pCLE9BQTBDO0lBQzVDLE1BQU0sQ0FBQyxJQUFJLGlCQUFpQixDQUFVLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN6RCxDQUFDIiwiZmlsZSI6Iml0ZXJhYmxlL2NhdGNod2l0aC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZXJhYmxlWCB9IGZyb20gJy4uL2l0ZXJhYmxlJztcbmltcG9ydCB7IHJldHVybkl0ZXJhdG9yIH0gZnJvbSAnLi4vaW50ZXJuYWwvcmV0dXJuaXRlcmF0b3InO1xuXG5jbGFzcyBDYXRjaFdpdGhJdGVyYWJsZTxUU291cmNlPiBleHRlbmRzIEl0ZXJhYmxlWDxUU291cmNlPiB7XG4gIHByaXZhdGUgX3NvdXJjZTogSXRlcmFibGU8VFNvdXJjZT47XG4gIHByaXZhdGUgX2hhbmRsZXI6IChlcnJvcjogYW55KSA9PiBJdGVyYWJsZTxUU291cmNlPjtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LCBoYW5kbGVyOiAoZXJyb3I6IGFueSkgPT4gSXRlcmFibGU8VFNvdXJjZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgZXJyOiBJdGVyYWJsZTxUU291cmNlPiB8IHVuZGVmaW5lZCwgaGFzRXJyb3IgPSBmYWxzZSwgaXQgPSB0aGlzLl9zb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBsZXQgYyA9IDxJdGVyYXRvclJlc3VsdDxUU291cmNlPj57fTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYyA9IGl0Lm5leHQoKTtcbiAgICAgICAgaWYgKGMuZG9uZSkge1xuICAgICAgICAgIHJldHVybkl0ZXJhdG9yKGl0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSB0aGlzLl9oYW5kbGVyKGUpO1xuICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybkl0ZXJhdG9yKGl0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHlpZWxkIGMudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICBmb3IgKGxldCBpdGVtIG9mIGVyciEpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VxdWVuY2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc291cmNlIHNlcXVlbmNlLCBjb25jYXRlbmF0aW5nIGl0IHdpdGggdGhlIHNlcXVlbmNlIHJlc3VsdGluZyBmcm9tXG4gKiBjYWxsaW5nIGFuIGV4Y2VwdGlvbiBoYW5kbGVyIGZ1bmN0aW9uIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2UgU291cmNlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yOiBhbnkpOiBJdGVyYWJsZTxUU291cmNlPn0gaGFuZGxlciBIYW5kbGVyIHRvIGludm9rZSB3aGVuIGFuIGV4Y2VwdGlvbiBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxuICogQHJldHVybiB7SXRlcmFibGU8VFNvdXJjZT59IFNvdXJjZSBzZXF1ZW5jZSwgY29uY2F0ZW5hdGVkIHdpdGggYW4gZXhjZXB0aW9uIGhhbmRsZXIgcmVzdWx0IHNlcXVlbmNlIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXRjaFdpdGg8VFNvdXJjZT4oXG4gICAgc291cmNlOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICBoYW5kbGVyOiAoZXJyb3I6IGFueSkgPT4gSXRlcmFibGU8VFNvdXJjZT4pOiBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IENhdGNoV2l0aEl0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSwgaGFuZGxlcik7XG59XG4iXX0=
