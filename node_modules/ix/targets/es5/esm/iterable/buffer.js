import * as tslib_1 from "tslib";
import { IterableX } from '../iterable';
var BufferIterable = (function (_super) {
    tslib_1.__extends(BufferIterable, _super);
    function BufferIterable(source, count, skip) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._count = count;
        _this._skip = skip;
        return _this;
    }
    BufferIterable.prototype[Symbol.iterator] = function () {
        var buffers, i, _a, _b, item, buffers_1, buffers_1_1, buffer_1, e_1_1, e_1, _c, e_2, _d;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    buffers = [], i = 0;
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 7, 8, 9]);
                    _a = tslib_1.__values(this._source), _b = _a.next();
                    _e.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 6];
                    item = _b.value;
                    if (i % this._skip === 0) {
                        buffers.push([]);
                    }
                    try {
                        for (buffers_1 = tslib_1.__values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                            buffer_1 = buffers_1_1.value;
                            buffer_1.push(item);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (buffers_1_1 && !buffers_1_1.done && (_d = buffers_1.return)) _d.call(buffers_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!(buffers.length > 0 && buffers[0].length === this._count)) return [3 /*break*/, 4];
                    return [4 /*yield*/, buffers.shift()];
                case 3:
                    _e.sent();
                    _e.label = 4;
                case 4:
                    i++;
                    _e.label = 5;
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9:
                    if (!(buffers.length > 0)) return [3 /*break*/, 11];
                    return [4 /*yield*/, buffers.shift()];
                case 10:
                    _e.sent();
                    return [3 /*break*/, 9];
                case 11: return [2 /*return*/];
            }
        });
    };
    return BufferIterable;
}(IterableX));
/**
 * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
 * @example <caption>Creates a sequence of buffers with and without skip</caption>
 * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
 *
 * // Without skip
 * const result = buffer(source, 5);
 * const result = Ix.Iterable.from(source).buffer(5);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2, 3, 4]
 * // => [5, 6, 7, 8, 9]
 *
 * // With skip
 * const result = buffer(source, 3, 4);
 * const result = Ix.Iterable.from(source).buffer(3, 4);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2]
 * // => [4, 5, 6]
 * // => [8, 9]
 * @param {Iterabel<TSource>} source Source sequence
 * @param {number} count Number of elements for allocated buffers.
 * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults
 * to the count.
 * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements
 */
export function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferIterable(source, count, skip);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUV4QztJQUFzQywwQ0FBb0I7SUFLeEQsd0JBQVksTUFBeUIsRUFBRSxLQUFhLEVBQUUsSUFBWTtRQUFsRSxZQUNFLGlCQUFPLFNBSVI7UUFIQyxLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixLQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7SUFDcEIsQ0FBQztJQUVBLHlCQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBbEI7Ozs7O29CQUNNLE9BQU8sR0FBZ0IsRUFBRSxFQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Ozs7b0JBQ3JCLEtBQUEsaUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQTs7OztvQkFBcEIsSUFBSTtvQkFDWCxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUNuQixDQUFDOzt3QkFFRCxHQUFHLENBQUMsQ0FBZSxZQUFBLGlCQUFBLE9BQU8sQ0FBQTs0QkFBckI7NEJBQ0gsUUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzt5QkFDbkI7Ozs7Ozs7Ozt5QkFFRyxDQUFBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQSxFQUF2RCx3QkFBdUQ7b0JBQ3pELHFCQUFNLE9BQU8sQ0FBQyxLQUFLLEVBQUcsRUFBQTs7b0JBQXRCLFNBQXNCLENBQUM7OztvQkFHekIsQ0FBQyxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQUdDLENBQUEsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUE7b0JBQ3ZCLHFCQUFNLE9BQU8sQ0FBQyxLQUFLLEVBQUcsRUFBQTs7b0JBQXRCLFNBQXNCLENBQUM7Ozs7O0tBRTFCO0lBQ0gscUJBQUM7QUFBRCxDQWxDQSxBQWtDQyxDQWxDcUMsU0FBUyxHQWtDOUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRCRztBQUNILE1BQU0saUJBQ0YsTUFBeUIsRUFDekIsS0FBYSxFQUNiLElBQWE7SUFDZixFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUFDLElBQUksR0FBRyxLQUFLLENBQUM7SUFBQyxDQUFDO0lBQ3BDLE1BQU0sQ0FBQyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hELENBQUMiLCJmaWxlIjoiaXRlcmFibGUvYnVmZmVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuXG5jbGFzcyBCdWZmZXJJdGVyYWJsZTxUU291cmNlPiBleHRlbmRzIEl0ZXJhYmxlWDxUU291cmNlW10+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBJdGVyYWJsZTxUU291cmNlPjtcbiAgcHJpdmF0ZSBfY291bnQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBfc2tpcDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sIGNvdW50OiBudW1iZXIsIHNraXA6IG51bWJlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgdGhpcy5fc2tpcCA9IHNraXA7XG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IGJ1ZmZlcnM6IFRTb3VyY2VbXVtdID0gW10sICBpID0gMDtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuX3NvdXJjZSkge1xuICAgICAgaWYgKGkgJSB0aGlzLl9za2lwID09PSAwKSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGggPiAwICYmIGJ1ZmZlcnNbMF0ubGVuZ3RoID09PSB0aGlzLl9jb3VudCkge1xuICAgICAgICB5aWVsZCBidWZmZXJzLnNoaWZ0KCkhO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgd2hpbGUgKGJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgeWllbGQgYnVmZmVycy5zaGlmdCgpITtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzZXF1ZW5jZSBvZiBidWZmZXJzIG92ZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSwgd2l0aCBzcGVjaWZpZWQgbGVuZ3RoIGFuZCBwb3NzaWJsZSBvdmVybGFwLlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlcyBhIHNlcXVlbmNlIG9mIGJ1ZmZlcnMgd2l0aCBhbmQgd2l0aG91dCBza2lwPC9jYXB0aW9uPlxuICogY29uc3Qgc291cmNlID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDBdO1xuICpcbiAqIC8vIFdpdGhvdXQgc2tpcFxuICogY29uc3QgcmVzdWx0ID0gYnVmZmVyKHNvdXJjZSwgNSk7XG4gKiBjb25zdCByZXN1bHQgPSBJeC5JdGVyYWJsZS5mcm9tKHNvdXJjZSkuYnVmZmVyKDUpO1xuICogZm9yIChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfVxuICogLy8gPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiAvLyA9PiBbNSwgNiwgNywgOCwgOV1cbiAqXG4gKiAvLyBXaXRoIHNraXBcbiAqIGNvbnN0IHJlc3VsdCA9IGJ1ZmZlcihzb3VyY2UsIDMsIDQpO1xuICogY29uc3QgcmVzdWx0ID0gSXguSXRlcmFibGUuZnJvbShzb3VyY2UpLmJ1ZmZlcigzLCA0KTtcbiAqIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH1cbiAqIC8vID0+IFswLCAxLCAyXVxuICogLy8gPT4gWzQsIDUsIDZdXG4gKiAvLyA9PiBbOCwgOV1cbiAqIEBwYXJhbSB7SXRlcmFiZWw8VFNvdXJjZT59IHNvdXJjZSBTb3VyY2Ugc2VxdWVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgZWxlbWVudHMgZm9yIGFsbG9jYXRlZCBidWZmZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtza2lwXSBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZXR3ZWVuIHRoZSBzdGFydCBvZiBjb25zZWN1dGl2ZSBidWZmZXJzLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0c1xuICogdG8gdGhlIGNvdW50LlxuICogQHJldHVybiB7SXRlcmFibGVYPFRTb3VyY2U+W119IFNlcXVlbmNlIG9mIGJ1ZmZlcnMgY29udGFpbmluZyBzb3VyY2Ugc2VxdWVuY2UgZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcjxUU291cmNlPihcbiAgICBzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIGNvdW50OiBudW1iZXIsXG4gICAgc2tpcD86IG51bWJlcik6IEl0ZXJhYmxlWDxUU291cmNlW10+IHtcbiAgaWYgKHNraXAgPT0gbnVsbCkgeyBza2lwID0gY291bnQ7IH1cbiByZXR1cm4gbmV3IEJ1ZmZlckl0ZXJhYmxlKHNvdXJjZSwgY291bnQsIHNraXApO1xufVxuIl19
