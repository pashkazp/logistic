import * as tslib_1 from "tslib";
import { IterableX } from '../iterable';
var ScanIterable = (function (_super) {
    tslib_1.__extends(ScanIterable, _super);
    function ScanIterable(source, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._fn = fn;
        _this._hasSeed = args.length === 1;
        _this._seed = args[0];
        return _this;
    }
    ScanIterable.prototype[Symbol.iterator] = function () {
        var i, hasValue, _a, _b, item, e_1_1, e_1, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    i = 0, hasValue = false;
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 7, 8, 9]);
                    _a = tslib_1.__values(this._source), _b = _a.next();
                    _d.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 6];
                    item = _b.value;
                    if (!(hasValue || (hasValue = this._hasSeed))) return [3 /*break*/, 4];
                    this._seed = this._fn(this._seed, item, i++);
                    return [4 /*yield*/, this._seed];
                case 3:
                    _d.sent();
                    return [3 /*break*/, 5];
                case 4:
                    this._seed = item;
                    hasValue = true;
                    i++;
                    _d.label = 5;
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    };
    return ScanIterable;
}(IterableX));
export function scan(source, accumulator) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return new (ScanIterable.bind.apply(ScanIterable, tslib_1.__spread([void 0, source, accumulator], args)))();
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL3NjYW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFeEM7SUFBaUMsd0NBQVk7SUFNM0Msc0JBQ0ksTUFBbUIsRUFDbkIsRUFBMEM7UUFDMUMsY0FBa0I7YUFBbEIsVUFBa0IsRUFBbEIscUJBQWtCLEVBQWxCLElBQWtCO1lBQWxCLDZCQUFrQjs7UUFIdEIsWUFJRSxpQkFBTyxTQUtSO1FBSkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsS0FBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDZCxLQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1FBQ2xDLEtBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUN2QixDQUFDO0lBRUEsdUJBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFsQjs7Ozs7b0JBQ00sQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsS0FBSyxDQUFDOzs7O29CQUNYLEtBQUEsaUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQTs7OztvQkFBcEIsSUFBSTt5QkFDUCxDQUFBLFFBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUEsRUFBdEMsd0JBQXNDO29CQUN4QyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDaEQscUJBQU0sSUFBSSxDQUFDLEtBQUssRUFBQTs7b0JBQWhCLFNBQWdCLENBQUM7OztvQkFFakIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7b0JBQ2xCLFFBQVEsR0FBRyxJQUFJLENBQUM7b0JBQ2hCLENBQUMsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBR1Q7SUFDSCxtQkFBQztBQUFELENBOUJBLEFBOEJDLENBOUJnQyxTQUFTLEdBOEJ6QztBQVNELE1BQU0sZUFDRixNQUFtQixFQUNuQixXQUF1RDtJQUN2RCxjQUFrQjtTQUFsQixVQUFrQixFQUFsQixxQkFBa0IsRUFBbEIsSUFBa0I7UUFBbEIsNkJBQWtCOztJQUNwQixNQUFNLE1BQUssWUFBWSxZQUFaLFlBQVksNEJBQUMsTUFBTSxFQUFFLFdBQVcsR0FBSyxJQUFJLE1BQUU7QUFDeEQsQ0FBQyIsImZpbGUiOiJpdGVyYWJsZS9zY2FuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuXG5jbGFzcyBTY2FuSXRlcmFibGU8VCwgUj4gZXh0ZW5kcyBJdGVyYWJsZVg8Uj4ge1xuICBwcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPFQ+O1xuICBwcml2YXRlIF9mbjogKGFjYzogVCB8IFIsIHg6IFQsIGluZGV4OiBudW1iZXIpID0+IFI7XG4gIHByaXZhdGUgX3NlZWQ/OiBUIHwgUjtcbiAgcHJpdmF0ZSBfaGFzU2VlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogSXRlcmFibGU8VD4sXG4gICAgICBmbjogKGFjYzogVCB8IFIsIHg6IFQsIGluZGV4OiBudW1iZXIpID0+IFIsXG4gICAgICAuLi5hcmdzOiAoVCB8IFIpW10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX2hhc1NlZWQgPSBhcmdzLmxlbmd0aCA9PT0gMTtcbiAgICB0aGlzLl9zZWVkID0gYXJnc1swXTtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaSA9IDAsIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChoYXNWYWx1ZSB8fCAoaGFzVmFsdWUgPSB0aGlzLl9oYXNTZWVkKSkge1xuICAgICAgICB0aGlzLl9zZWVkID0gdGhpcy5fZm4oPFI+dGhpcy5fc2VlZCwgaXRlbSwgaSsrKTtcbiAgICAgICAgeWllbGQgdGhpcy5fc2VlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlZWQgPSBpdGVtO1xuICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYW48VD4oXG4gIHNvdXJjZTogSXRlcmFibGU8VD4sXG4gIGFjY3VtdWxhdG9yOiAoYWNjOiBULCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gVCk6IEl0ZXJhYmxlWDxUPjtcbmV4cG9ydCBmdW5jdGlvbiBzY2FuPFQsIFIgPSBUPihcbiAgc291cmNlOiBJdGVyYWJsZTxUPixcbiAgYWNjdW11bGF0b3I6IChhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBSLFxuICBzZWVkOiBSKTogSXRlcmFibGVYPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW48VCwgUiA9IFQ+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VD4sXG4gICAgYWNjdW11bGF0b3I6IChhY2M6IFQgfCBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUixcbiAgICAuLi5hcmdzOiAoVCB8IFIpW10pOiBJdGVyYWJsZVg8VCB8IFI+IHtcbiAgcmV0dXJuIG5ldyBTY2FuSXRlcmFibGUoc291cmNlLCBhY2N1bXVsYXRvciwgLi4uYXJncyk7XG59XG4iXX0=
