goog.module('targets.es5.cls.asynciterable.chain'); exports = {}; var module = {id: 'targets/es5/cls/asynciterable/chain.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es5.cls.asynciterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
/**
 * @template TResult
 */
var ChainAsyncIterable = (function (_super) {
    __extends(ChainAsyncIterable, _super);
    /**
     * @param {!AsyncIterable<TResult>} result
     */
    function ChainAsyncIterable(result) {
        var _this = _super.call(this) || this;
        _this._result = result;
        return _this;
    }
    /**
     * @return {!AsyncIterator<TResult>}
     */
    ChainAsyncIterable.prototype[Symbol.asyncIterator] = function () {
        return this._result[Symbol.asyncIterator]();
    };
    return ChainAsyncIterable;
}(asynciterable_1.AsyncIterableX));
function ChainAsyncIterable_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TResult>} */
    ChainAsyncIterable.prototype._result;
}
/**
 * Returns an async iterable sequence that is the result of invoking the selector on the source sequence,
 * without sharing subscriptions.  This operator allows for a fluent style of writing queries that use
 * the same sequence multiple times.
 * the source sequence as many times as needed, without sharing subscriptions to the source sequence.
 * @template TSource, TResult
 * @param {!AsyncIterable<TSource>} source
 * @param {function(!AsyncIterable<TSource>): !AsyncIterable<TResult>} selector
 * @return {!tsickle_forward_declare_1.AsyncIterableX<TResult>} An async iterable sequence that contains the elements of a sequence produced by multicasting the source
 * sequence within a selector function.
 */
function chain(source, selector) {
    return new ChainAsyncIterable(selector(source));
}
exports.chain = chain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL2NoYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRzs7QUFFSCxrREFMdUI7QUFNdkIsSUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7QUFDbkc7O0dBRUc7QUFQSDtJQUF5QyxzQ0FBd0I7SUFVakU7O09BRUc7SUFURCw0QkFBWSxNQUE4QjtRQUExQyxZQVdFLGlCQVZPLFNBWVI7UUFEQyxLQVZJLENBQUMsT0FBTyxHQUFFLE1BQU8sQ0FBQzs7SUFXeEIsQ0FBQztJQUNIOztPQUVHO0lBWEQsNkJBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUF0QjtRQWFFLE1BWk0sQ0FBQSxJQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO0lBYTlDLENBWkM7SUFDSCx5QkFBQTtBQUFBLENBWEEsQUFXQSxDQVh5Qyw4QkFBZSxHQVd4RDtBQWNBO0lBQ0Esc0NBQXNDO0lBQ3RDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7QUFDckMsQ0FBQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFqQkgsZUFtQkksTUFsQjhCLEVBbUI5QixRQWxCb0U7SUFtQnRFLE1BbEJNLENBQUEsSUFBSSxrQkFBbUIsQ0FBVSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQW1CM0QsQ0FsQkM7QUFKRCxzQkFJQyIsImZpbGUiOiJjaGFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbmltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5hc3luY2l0ZXJhYmxlXCIpO1xuLyoqXG4gKiBAdGVtcGxhdGUgVFJlc3VsdFxuICovXG5jbGFzcyBDaGFpbkFzeW5jSXRlcmFibGU8VFJlc3VsdD4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUUmVzdWx0PiB7XG5wcml2YXRlIF9yZXN1bHQ6IEFzeW5jSXRlcmFibGU8VFJlc3VsdD47XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFJlc3VsdD59IHJlc3VsdFxuICovXG5jb25zdHJ1Y3RvcihyZXN1bHQ6IEFzeW5jSXRlcmFibGU8VFJlc3VsdD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHJlc3VsdDtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshQXN5bmNJdGVyYXRvcjxUUmVzdWx0Pn1cbiAqL1xuW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIENoYWluQXN5bmNJdGVyYWJsZV90c2lja2xlX0Nsb3N1cmVfZGVjbGFyYXRpb25zKCkge1xuLyoqIEB0eXBlIHshQXN5bmNJdGVyYWJsZTxUUmVzdWx0Pn0gKi9cbkNoYWluQXN5bmNJdGVyYWJsZS5wcm90b3R5cGUuX3Jlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gdGhlIHNvdXJjZSBzZXF1ZW5jZSxcbiAqIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zLiAgVGhpcyBvcGVyYXRvciBhbGxvd3MgZm9yIGEgZmx1ZW50IHN0eWxlIG9mIHdyaXRpbmcgcXVlcmllcyB0aGF0IHVzZVxuICogdGhlIHNhbWUgc2VxdWVuY2UgbXVsdGlwbGUgdGltZXMuXG4gKiB0aGUgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IHNoYXJpbmcgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICogQHRlbXBsYXRlIFRTb3VyY2UsIFRSZXN1bHRcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbighQXN5bmNJdGVyYWJsZTxUU291cmNlPik6ICFBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+fSBzZWxlY3RvclxuICogQHJldHVybiB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuQXN5bmNJdGVyYWJsZVg8VFJlc3VsdD59IEFuIGFzeW5jIGl0ZXJhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2VcbiAqIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhaW48VFNvdXJjZSwgVFJlc3VsdD4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIHNlbGVjdG9yOiAoc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KSA9PiBBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+KTogQXN5bmNJdGVyYWJsZVg8VFJlc3VsdD4ge1xuICByZXR1cm4gbmV3IENoYWluQXN5bmNJdGVyYWJsZTxUUmVzdWx0PihzZWxlY3Rvcihzb3VyY2UpKTtcbn1cbiJdfQ==