goog.module('targets.es5.cls.asynciterable.orderby'); exports = {}; var module = {id: 'targets/es5/cls/asynciterable/orderby.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es5.cls.asynciterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
var toarray_1 = goog.require('targets.es5.cls.asynciterable.toarray');
var tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable.toarray");
var sorter_1 = goog.require('targets.es5.cls.internal.sorter');
var tsickle_forward_declare_3 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.internal.sorter");
/**
 * @abstract
 * @template TSource
 */
var OrderedAsyncIterableBaseX = (function (_super) {
    __extends(OrderedAsyncIterableBaseX, _super);
    /**
     * @param {!AsyncIterable<TSource>} source
     */
    function OrderedAsyncIterableBaseX(source) {
        var _this = _super.call(this) || this;
        _this._source = source;
        return _this;
    }
    /**
     * @return {!AsyncIterableIterator<TSource>}
     */
    OrderedAsyncIterableBaseX.prototype[Symbol.asyncIterator] = function () {
        return __asyncGenerator(this, arguments, function _a() {
            var array, len, indices, i, len_1, indices_1, indices_1_1, index, e_1_1, e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, __await(toarray_1.toArray(this._source))];
                    case 1:
                        array = _b.sent();
                        len = array.length;
                        indices = new Array(len);
                        for (i = 0, len_1 = array.length; i < len_1; i++) {
                            indices[i] = i;
                        }
                        indices.sort(this._getSorter(array));
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 7, 8, 9]);
                        indices_1 = __values(indices), indices_1_1 = indices_1.next();
                        _b.label = 3;
                    case 3:
                        if (!!indices_1_1.done) return [3 /*break*/, 6];
                        index = indices_1_1.value;
                        return [4 /*yield*/, array[index]];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        indices_1_1 = indices_1.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (indices_1_1 && !indices_1_1.done && (_a = indices_1.return)) _a.call(indices_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @template TKey
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number=} comparer
     * @return {!OrderedAsyncIterableBaseX}
     */
    OrderedAsyncIterableBaseX.prototype.thenBy = function (keySelector, comparer) {
        if (comparer === void 0) { comparer = sorter_1.sorter; }
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedAsyncIterableX(this._source, keySelector, comparer, false, this);
    };
    /**
     * @template TKey
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number=} comparer
     * @return {!OrderedAsyncIterableBaseX}
     */
    OrderedAsyncIterableBaseX.prototype.thenByDescending = function (keySelector, comparer) {
        if (comparer === void 0) { comparer = sorter_1.sorter; }
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedAsyncIterableX(this._source, keySelector, comparer, true, this);
    };
    return OrderedAsyncIterableBaseX;
}(asynciterable_1.AsyncIterableX));
exports.OrderedAsyncIterableBaseX = OrderedAsyncIterableBaseX;
function OrderedAsyncIterableBaseX_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TSource>} */
    OrderedAsyncIterableBaseX.prototype._source;
    /**
     * @abstract
     * @param {!Array<TSource>} elements
     * @param {function(number, number): number=} next
     * @return {function(number, number): number}
     */
    OrderedAsyncIterableBaseX.prototype._getSorter = function (elements, next) { };
}
/**
 * @template TKey, TSource
 */
var OrderedAsyncIterableX = (function (_super) {
    __extends(OrderedAsyncIterableX, _super);
    /**
     * @param {!AsyncIterable<TSource>} source
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number} comparer
     * @param {boolean} descending
     * @param {!OrderedAsyncIterableBaseX<TSource>=} parent
     */
    function OrderedAsyncIterableX(source, keySelector, comparer, descending, parent) {
        var _this = _super.call(this, source) || this;
        _this._keySelector = keySelector;
        _this._comparer = comparer;
        _this._descending = descending;
        _this._parent = parent;
        return _this;
    }
    /**
     * @param {!Array<TSource>} elements
     * @param {function(number, number): number=} next
     * @return {function(number, number): number}
     */
    OrderedAsyncIterableX.prototype._getSorter = function (elements, next) {
        var /** @type {!Array<TKey>} */ keys = elements.map(this._keySelector);
        var /** @type {function(TKey, TKey): number} */ comparer = this._comparer;
        var /** @type {!OrderedAsyncIterableBaseX<TSource>} */ parent = this._parent;
        var /** @type {boolean} */ descending = this._descending;
        var /** @type {function(number, number): number} */ sorter = function (x, y) {
            var /** @type {number} */ result = comparer(keys[x], keys[y]);
            if (result === 0) {
                return next ? next(x, y) : x - y;
            }
            return descending ? -result : result;
        };
        return parent ? parent._getSorter(elements, sorter) : sorter;
    };
    return OrderedAsyncIterableX;
}(OrderedAsyncIterableBaseX));
exports.OrderedAsyncIterableX = OrderedAsyncIterableX;
function OrderedAsyncIterableX_tsickle_Closure_declarations() {
    /** @type {function(TSource): TKey} */
    OrderedAsyncIterableX.prototype._keySelector;
    /** @type {function(TKey, TKey): number} */
    OrderedAsyncIterableX.prototype._comparer;
    /** @type {boolean} */
    OrderedAsyncIterableX.prototype._descending;
    /** @type {!OrderedAsyncIterableBaseX<TSource>} */
    OrderedAsyncIterableX.prototype._parent;
}
/**
 * @template TKey, TSource
 * @param {!AsyncIterable<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function orderBy(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source, keySelector, comparer, false);
}
exports.orderBy = orderBy;
/**
 * @template TKey, TSource
 * @param {!AsyncIterable<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function orderByDescending(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source, keySelector, comparer, true);
}
exports.orderByDescending = orderByDescending;
/**
 * @template TKey, TSource
 * @param {!OrderedAsyncIterableBaseX<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function thenBy(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source._source, keySelector, comparer, false, source);
}
exports.thenBy = thenBy;
/**
 * @template TKey, TSource
 * @param {!OrderedAsyncIterableBaseX<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function thenByDescending(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source._source, keySelector, comparer, true, source);
}
exports.thenByDescending = thenByDescending;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL29yZGVyYnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILGtEQUx1QjtBQU12QixJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsMkNBQTJDLENBQUMsQ0FOaEQ7QUFPbEQscUNBTmdCO0FBT2hCLElBQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtREFBbUQsQ0FBQyxDQVB0RTtBQVFwQyw2Q0FQZ0M7QUFRaEMsSUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7QUFDckc7OztHQUdHO0FBVkg7SUFBZ0UsNkNBQXdCO0lBYXhGOztPQUVHO0lBWkQsbUNBQVksTUFBOEI7UUFBMUMsWUFjRSxpQkFiTyxTQWVSO1FBREMsS0FiSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7O0lBY3hCLENBQUM7SUFDSDs7T0FFRztJQWRNLG9DQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBN0I7Ozs7OzRCQUNlLDZCQUFNLGlCQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFBOzt3QkFBcEMsS0FBTSxHQUFFLFNBQTRCO3dCQUNwQyxHQUFJLEdBQUUsS0FBTSxDQUFDLE1BQU0sQ0FBQzt3QkFDcEIsT0FBUSxHQUFFLElBQUksS0FBTSxDQUFTLEdBQUcsQ0FBQyxDQUFDO3dCQWdCdkMsR0FBRyxDQUFDLENBZkksQ0FBRSxHQUFFLENBQUUsRUFBQyxRQUFNLEtBQU0sQ0FBQyxNQUFNLEVBQUMsQ0FBRSxHQUFFLEtBQUksRUFBQyxDQUFFLEVBQUUsRUFBQyxDQUFFOzRCQWdCakQsT0FmTyxDQUFDLENBQUMsQ0FBQyxHQUFFLENBQUUsQ0FBQzt3QkFnQmpCLENBZkM7d0JBaUJELE9BZk8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7O3dCQUNs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RUFBQyxLQUFNLEVBQUMsTUFBTyxDQUFDLENBQUM7QUFrRnhHLENBQUM7QUF0RkQsd0JBc0ZDO0FBQ0Q7Ozs7OztHQU1HO0FBdEZILDBCQXdGTSxNQXZGMEMsRUF3RjFDLFdBdkZvQyxFQXdGcEMsUUF2RjBEO0lBdUYxRCx5QkFBQSxFQUFBLFdBdkY0QyxlQUFjO0lBd0Y5RCxNQXZGTSxDQUFBLElBQUkscUJBQXNCLENBQWdCLE1BQU0sQ0FBQyxPQUFPLEVBQUMsV0FBWSxFQUFDLFFBQVMsRUFBQyxJQUFLLEVBQUMsTUFBTyxDQUFDLENBQUM7QUF3RnZHLENBdkZDO0FBTEQsNENBS0MiLCJmaWxlIjoib3JkZXJieS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbmltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5hc3luY2l0ZXJhYmxlXCIpO1xuaW1wb3J0IHsgdG9BcnJheSB9IGZyb20gJy4vdG9hcnJheSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8yID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5hc3luY2l0ZXJhYmxlLnRvYXJyYXlcIik7XG5pbXBvcnQgeyBzb3J0ZXIgYXMgZGVmYXVsdFNvcnRlciB9IGZyb20gJy4uL2ludGVybmFsL3NvcnRlcic7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8zID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pbnRlcm5hbC5zb3J0ZXJcIik7XG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHRlbXBsYXRlIFRTb3VyY2VcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG4gIF9zb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT47XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFRTb3VyY2U+fVxuICovXG5hc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCAvKiogQHR5cGUgeyFBcnJheTxUU291cmNlPn0gKi8gYXJyYXkgPSBhd2FpdCB0b0FycmF5KHRoaXMuX3NvdXJjZSk7XG4gICAgY29uc3QgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCAvKiogQHR5cGUgeyFBcnJheTxudW1iZXI+fSAqLyBpbmRpY2VzID0gbmV3IEFycmF5PG51bWJlcj4obGVuKTtcbiAgICBmb3IgKGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gaSA9IDAsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuXG4gICAgaW5kaWNlcy5zb3J0KHRoaXMuX2dldFNvcnRlcihhcnJheSkpO1xuICAgIGZvciAoY29uc3QgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGluZGV4IG9mIGluZGljZXMpIHtcbiAgICAgIHlpZWxkIGFycmF5W2luZGV4XTtcbiAgICB9XG4gIH1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVh9XG4gKi9cbnRoZW5CeTxUS2V5PihcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+IHtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVzZS1iZWZvcmUtZGVjbGFyZSAqL1xuICAgIHJldHVybiBuZXcgT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+KHRoaXMuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCBmYWxzZSwgdGhpcyk7XG4gIH1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVh9XG4gKi9cbnRoZW5CeURlc2NlbmRpbmc8VEtleT4oXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPiB7XG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11c2UtYmVmb3JlLWRlY2xhcmUgKi9cbiAgICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPih0aGlzLl9zb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgdHJ1ZSwgdGhpcyk7XG4gIH1cblxuICBhYnN0cmFjdCBfZ2V0U29ydGVyKFxuICAgIGVsZW1lbnRzOiBUU291cmNlW10sXG4gICAgbmV4dD86ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyKTogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVhfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59ICovXG5PcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYLnByb3RvdHlwZS5fc291cmNlO1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHshQXJyYXk8VFNvdXJjZT59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogbnVtYmVyPX0gbmV4dFxuICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9XG4gKi9cbk9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVgucHJvdG90eXBlLl9nZXRTb3J0ZXIgPSBmdW5jdGlvbihlbGVtZW50cywgbmV4dCkge307XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRLZXksIFRTb3VyY2VcbiAqL1xuZXhwb3J0IGNsYXNzIE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPiBleHRlbmRzIE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4ge1xucHJpdmF0ZSBfa2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5O1xucHJpdmF0ZSBfY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyO1xucHJpdmF0ZSBfZGVzY2VuZGluZzogYm9vbGVhbjtcbnByaXZhdGUgX3BhcmVudD86IE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT47XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihUU291cmNlKTogVEtleX0ga2V5U2VsZWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcn0gY29tcGFyZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY2VuZGluZ1xuICogQHBhcmFtIHshT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPj19IHBhcmVudFxuICovXG5jb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlcixcbiAgICAgIGRlc2NlbmRpbmc6IGJvb2xlYW4sXG4gICAgICBwYXJlbnQ/OiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+KSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICB0aGlzLl9rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgIHRoaXMuX2NvbXBhcmVyID0gY29tcGFyZXI7XG4gICAgdGhpcy5fZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB9XG4vKipcbiAqIEBwYXJhbSB7IUFycmF5PFRTb3VyY2U+fSBlbGVtZW50c1xuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6IG51bWJlcj19IG5leHRcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogbnVtYmVyfVxuICovXG5fZ2V0U29ydGVyKFxuICAgICAgZWxlbWVudHM6IFRTb3VyY2VbXSxcbiAgICAgIG5leHQ/OiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IG51bWJlcik6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyIHtcbiAgICBjb25zdCAvKiogQHR5cGUgeyFBcnJheTxUS2V5Pn0gKi8ga2V5cyA9IGVsZW1lbnRzLm1hcCh0aGlzLl9rZXlTZWxlY3Rvcik7XG4gICAgY29uc3QgLyoqIEB0eXBlIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyfSAqLyBjb21wYXJlciA9IHRoaXMuX2NvbXBhcmVyO1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT59ICovIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICBjb25zdCAvKiogQHR5cGUge2Jvb2xlYW59ICovIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nO1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9ICovIHNvcnRlciA9ICh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICBjb25zdCAvKiogQHR5cGUge251bWJlcn0gKi8gcmVzdWx0ID0gY29tcGFyZXIoa2V5c1t4XSwga2V5c1t5XSk7XG4gICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXh0ID8gbmV4dCh4LCB5KSA6IHggLSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzY2VuZGluZyA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuX2dldFNvcnRlcihlbGVtZW50cywgc29ydGVyKSA6IHNvcnRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBPcmRlcmVkQXN5bmNJdGVyYWJsZVhfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9ICovXG5PcmRlcmVkQXN5bmNJdGVyYWJsZVgucHJvdG90eXBlLl9rZXlTZWxlY3Rvcjtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcn0gKi9cbk9yZGVyZWRBc3luY0l0ZXJhYmxlWC5wcm90b3R5cGUuX2NvbXBhcmVyO1xuLyoqIEB0eXBlIHtib29sZWFufSAqL1xuT3JkZXJlZEFzeW5jSXRlcmFibGVYLnByb3RvdHlwZS5fZGVzY2VuZGluZztcbi8qKiBAdHlwZSB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT59ICovXG5PcmRlcmVkQXN5bmNJdGVyYWJsZVgucHJvdG90eXBlLl9wYXJlbnQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRLZXksIFRTb3VyY2VcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihUU291cmNlKTogVEtleX0ga2V5U2VsZWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcj19IGNvbXBhcmVyXG4gKiBAcmV0dXJuIHshT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJCeTxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgZmFsc2UpO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVEtleSwgVFNvdXJjZVxuICogQHBhcmFtIHshQXN5bmNJdGVyYWJsZTxUU291cmNlPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSBrZXlTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyPX0gY29tcGFyZXJcbiAqIEByZXR1cm4geyFPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmRlckJ5RGVzY2VuZGluZzxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgdHJ1ZSk7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5LCBUU291cmNlXG4gKiBAcGFyYW0geyFPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRoZW5CeTxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCBmYWxzZSwgc291cmNlKTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXksIFRTb3VyY2VcbiAqIEBwYXJhbSB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihUU291cmNlKTogVEtleX0ga2V5U2VsZWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcj19IGNvbXBhcmVyXG4gKiBAcmV0dXJuIHshT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhlbkJ5RGVzY2VuZGluZzxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCB0cnVlLCBzb3VyY2UpO1xufVxuIl19