goog.module('targets.es5.cls.asynciterable.sequenceequal'); exports = {}; var module = {id: 'targets/es5/cls/asynciterable/sequenceequal.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var comparer_1 = goog.require('targets.es5.cls.internal.comparer');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.internal.comparer");
/**
 * @template T
 * @param {!AsyncIterable<T>} source
 * @param {!AsyncIterable<T>} other
 * @param {function(T, T): (boolean|!Promise<boolean>)=} comparer
 * @return {!Promise<boolean>}
 */
function sequenceEqual(source, other, comparer) {
    if (comparer === void 0) { comparer = comparer_1.comparerAsync; }
    return __awaiter(this, void 0, void 0, function () {
        var it1, it2, next1, next2, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    it1 = source[Symbol.asyncIterator](), it2 = other[Symbol.asyncIterator]();
                    _b.label = 1;
                case 1: return [4 /*yield*/, it1.next()];
                case 2:
                    if (!!(next1 = _b.sent()).done) return [3 /*break*/, 6];
                    return [4 /*yield*/, it2.next()];
                case 3:
                    _a = !(next2 = _b.sent()).done;
                    if (!_a) return [3 /*break*/, 5];
                    return [4 /*yield*/, comparer(next1.value, next2.value)];
                case 4:
                    _a = (_b.sent());
                    _b.label = 5;
                case 5:
                    if (!(_a)) {
                        return [2 /*return*/, false];
                    }
                    return [3 /*break*/, 1];
                case 6: return [4 /*yield*/, it2.next()];
                case 7: return [2 /*return*/, (_b.sent()).done];
            }
        });
    });
}
exports.sequenceEqual = sequenceEqual;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL3NlcXVlbmNlZXF1YWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILGlEQUxzQjtBQU10QixJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsK0NBQStDLENBQUMsQ0FBQztBQUN2Rzs7Ozs7O0dBTUc7QUFYSCx1QkFhSSxNQVp3QixFQWF4QixLQVp1QixFQWF2QixRQVo2RTtJQVk3RSx5QkFBQSxFQUFBLFdBWitELHdCQUFjOzs7Ozs7b0JBQzFFLEdBQUksR0FBRSxNQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUMsR0FBSSxHQUFFLEtBQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQzs7d0JBRWhFLHFCQUFNLEdBQUksQ0FBQyxJQUFJLEVBQUUsRUFBQTs7eUJBQTFCLENBQUMsQ0FBQyxLQUFLLEdBQUUsU0FBaUIsQ0FBQyxDQUFDLElBQUk7b0JBQ3RCLHFCQUFNLEdBQUksQ0FBQyxJQUFJLEVBQUUsRUFBQTs7b0JBQTFCLEtBQUEsQ0FBQyxDQUFDLEtBQUssR0FBRSxTQUFpQixDQUFDLENBQUMsSUFBSSxDQUFBOzZCQUFoQyx3QkFBZ0M7b0JBQUcscUJBQU0sUUFBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUMsS0FBTSxDQUFDLEtBQUssQ0FBQyxFQUFBOzswQkFBekMsU0FBeUM7OztvQkFZbEYsRUFBRSxDQUFDLENBWkMsQ0FBQyxJQUE4RSxDQUFDLENBQUEsQ0FBRTt3QkFhcEYsTUFaTSxnQkFBQSxLQUFNLEVBQUM7b0JBYWYsQ0FaQzs7d0JBR0sscUJBQUssR0FBSSxDQUFDLElBQUksRUFBRSxFQUFBO3dCQVl4QixzQkFaTSxDQUFFLFNBQWdCLENBQUMsQ0FBQyxJQUFJLEVBQUM7Ozs7Q0FDaEM7QUFiRCxzQ0FhQyIsImZpbGUiOiJzZXF1ZW5jZWVxdWFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuaW1wb3J0IHsgY29tcGFyZXJBc3luYyB9IGZyb20gJy4uL2ludGVybmFsL2NvbXBhcmVyJztcbmNvbnN0IHRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEgPSBnb29nLmZvcndhcmREZWNsYXJlKFwiX1VzZXJzLnB0YXlsb3IuZGV2Lml4anMuc3JjLmludGVybmFsLmNvbXBhcmVyXCIpO1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHshQXN5bmNJdGVyYWJsZTxUPn0gc291cmNlXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFQ+fSBvdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbihULCBUKTogKGJvb2xlYW58IVByb21pc2U8Ym9vbGVhbj4pPX0gY29tcGFyZXJcbiAqIEByZXR1cm4geyFQcm9taXNlPGJvb2xlYW4+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VxdWVuY2VFcXVhbDxUPihcbiAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VD4sXG4gICAgb3RoZXI6IEFzeW5jSXRlcmFibGU8VD4sXG4gICAgY29tcGFyZXI6IChmaXJzdDogVCwgc2Vjb25kOiBUKSA9PiBib29sZWFuIHwgUHJvbWlzZTxib29sZWFuPiA9IGNvbXBhcmVyQXN5bmMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgLyoqIEB0eXBlIHshQXN5bmNJdGVyYXRvcjxUPn0gKi8gaXQxID0gc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCAvKiogQHR5cGUgeyFBc3luY0l0ZXJhdG9yPFQ+fSAqLyBpdDIgPSBvdGhlcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgbGV0IC8qKiBAdHlwZSB7IUl0ZXJhdG9yUmVzdWx0PFQ+fSAqLyBuZXh0MTogSXRlcmF0b3JSZXN1bHQ8VD4sIC8qKiBAdHlwZSB7IUl0ZXJhdG9yUmVzdWx0PFQ+fSAqLyBuZXh0MjogSXRlcmF0b3JSZXN1bHQ8VD47XG4gIHdoaWxlICghKG5leHQxID0gYXdhaXQgaXQxLm5leHQoKSkuZG9uZSkge1xuICAgIGlmICghKCEobmV4dDIgPSBhd2FpdCBpdDIubmV4dCgpKS5kb25lICYmIGF3YWl0IGNvbXBhcmVyKG5leHQxLnZhbHVlLCBuZXh0Mi52YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChhd2FpdCBpdDIubmV4dCgpKS5kb25lO1xufVxuIl19