goog.module('targets.es5.cls.asynciterable._extremaby'); exports = {}; var module = {id: 'targets/es5/cls/asynciterable/_extremaby.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es5.cls.asynciterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
/**
 * @ignore
 * @template T
 * @param {T} key
 * @param {T} minValue
 * @return {!Promise<number>}
 */
function defaultCompareAsync(key, minValue) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, key > minValue ? 1 : key < minValue ? -1 : 0];
        });
    });
}
exports.defaultCompareAsync = defaultCompareAsync;
/**
 * @ignore
 * @template TSource, TKey
 */
var ExtremaByAsyncIterator = (function (_super) {
    __extends(ExtremaByAsyncIterator, _super);
    /**
     * @param {!AsyncIterable<TSource>} source
     * @param {function(TSource): (TKey|!Promise<TKey>)} keyFn
     * @param {function(TKey, TKey): (number|!Promise<number>)} cmp
     */
    function ExtremaByAsyncIterator(source, keyFn, cmp) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._keyFn = keyFn;
        _this._cmp = cmp;
        return _this;
    }
    /**
     * @return {!AsyncIterableIterator<TSource>}
     */
    ExtremaByAsyncIterator.prototype[Symbol.asyncIterator] = function () {
        return __asyncGenerator(this, arguments, function _a() {
            var result, done, next, it, current, resKey, curr, key, c;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = [];
                        it = this._source[Symbol.asyncIterator]();
                        return [4 /*yield*/, __await(it.next())];
                    case 1:
                        done = (next = _a.sent()).done;
                        if (done) {
                            throw new Error('Sequence contains no elements');
                        }
                        current = next.value;
                        return [4 /*yield*/, __await(this._keyFn(current))];
                    case 2:
                        resKey = _a.sent();
                        return [4 /*yield*/, __await(it.next())];
                    case 3:
                        done = (next = _a.sent()).done;
                        _a.label = 4;
                    case 4:
                        if (!!done) return [3 /*break*/, 8];
                        curr = next.value;
                        return [4 /*yield*/, __await(this._keyFn(curr))];
                    case 5:
                        key = _a.sent();
                        return [4 /*yield*/, __await(this._cmp(key, resKey))];
                    case 6:
                        c = _a.sent();
                        if (c === 0) {
                            result.push(curr);
                        }
                        else if (c > 0) {
                            result = [curr];
                            resKey = key;
                        }
                        return [4 /*yield*/, __await(it.next())];
                    case 7:
                        done = (next = _a.sent()).done;
                        return [3 /*break*/, 4];
                    case 8: return [5 /*yield**/, __values(__asyncDelegator(__asyncValues(result)))];
                    case 9: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 10:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return ExtremaByAsyncIterator;
}(asynciterable_1.AsyncIterableX));
function ExtremaByAsyncIterator_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TSource>} */
    ExtremaByAsyncIterator.prototype._source;
    /** @type {function(TSource): (TKey|!Promise<TKey>)} */
    ExtremaByAsyncIterator.prototype._keyFn;
    /** @type {function(TKey, TKey): (number|!Promise<number>)} */
    ExtremaByAsyncIterator.prototype._cmp;
}
/**
 * @ignore
 * @template TSource, TKey
 * @param {!AsyncIterable<TSource>} source
 * @param {function(TSource): (TKey|!Promise<TKey>)} keyFn
 * @param {function(TKey, TKey): (number|!Promise<number>)} cmp
 * @return {!tsickle_forward_declare_1.AsyncIterableX<TSource>}
 */
function extremaBy(source, keyFn, cmp) {
    return new ExtremaByAsyncIterator(source, keyFn, cmp);
}
exports.extremaBy = extremaBy;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL19leHRyZW1hYnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILGtEQUx1QjtBQU12QixJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsMkNBQTJDLENBQUMsQ0FBQztBQUNuRzs7Ozs7O0dBTUc7QUFSSCw2QkFBNkMsR0FBTSxFQUFDLFFBQVk7OztZQVU5RCxzQkFUTSxHQUFJLEdBQUUsUUFBUyxHQUFFLENBQUUsR0FBRSxHQUFJLEdBQUUsUUFBUyxHQUFFLENBQUUsQ0FBQyxHQUFFLENBQUUsRUFBQzs7O0NBVXJEO0FBWEQsa0RBV0M7QUFDRDs7O0dBR0c7QUFSSDtJQUFtRCwwQ0FBd0I7SUFhM0U7Ozs7T0FJRztJQVpELGdDQWNJLE1BYjhCLEVBYzlCLEtBYjJDLEVBYzNDLEdBYm1EO1FBSHZELFlBaUJFLGlCQWJPLFNBaUJSO1FBSEMsS0FiSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7UUFjdEIsS0FiSSxDQUFDLE1BQU0sR0FBRSxLQUFNLENBQUM7UUFjcEIsS0FiSSxDQUFDLElBQUksR0FBRSxHQUFJLENBQUM7O0lBY2xCLENBQUM7SUFDSDs7T0FFRztJQWRNLGlDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBN0I7Ozs7Ozt3QkFDSyxNQUFPLEdBQWEsRUFBRyxDQUFhO3dCQUNsQyxFQUFHLEdBQUUsSUFBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQzt3QkFDbEMsNkJBQU0sRUFBRyxDQUFDLElBQUksRUFBRSxHQUFBOzt3QkFlOUIsSUFmSSxHQUFFLENBQUUsSUFBSSxHQUFFLFNBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUM7d0JBZ0JyQyxFQUFFLENBQUMsQ0FmQyxJQUFJLENBQUMsQ0FBQSxDQUFFOzRCQWdCVCxNQWZLLElBQUksS0FBTSxDQUFDLCtCQUErQixDQUFDLENBQUM7d0JBZ0JuRCxDQWZDO3dCQUVFLE9BQVEsR0FBRSxJQUFLLENBQUMsS0FBSyxDQUFDO3dCQUNiLDZCQUFNLElBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUE7O3dCQUFwQyxNQUFPLEdBQUUsU0FBMkI7d0JBQ3pCLDZCQUFNLEVBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBQTs7d0JBZTlCLElBZkksR0FBRSxDQUFFLElBQUksR0FBRSxTQUFnQixDQUFDLENBQUMsSUFBSSxDQUFDOzs7NkJBQzlCLENBQUMsSUFBSTt3QkFDUCxJQUFLLEdBQUUsSUFBSyxDQUFDLEtBQUssQ0FBQzt3QkFDYiw2QkFBTSxJQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFBOzt3QkFBOUIsR0FBSSxHQUFFLFNBQXdCO3dCQUN4Qiw2QkFBTSxJQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBQyxNQUFPLENBQUMsR0FBQTs7d0JBQWpDLENBQUUsR0FBRSxTQUE2Qjt3QkFnQnRDLEVBQUUsQ0FBQyxDQWZDLENBQUMsS0FBSSxDQUFFLENBQUMsQ0FBQSxDQUFFOzRCQWdCWixNQWZNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQWdCcEIsQ0FmQzt3QkFBQSxJQUFLLENBQUEsRUFBQSxDQUFBLENBQUssQ0FBQyxHQUFFLENBQUUsQ0FBQyxDQUFBLENBQUU7NEJBZ0JqQixNQWZNLEdBQUUsQ0FBRSxJQUFJLENBQUMsQ0FBQzs0QkFnQmhCLE1BZk0sR0FBRSxHQUFJLENBQUM7d0JBZ0JmLENBZkM7d0JBQ2EsNkJBQU0sRUFBRyxDQUFDLElBQUksRUFBRSxHQUFBOzt3QkFlOUIsSUFmSSxHQUFFLENBQUUsSUFBSSxHQUFFLFNBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUM7OzRCQWtCdkMsc0JBQUEsU0FmTSxpQkFBQSxjQUFBLE1BQU8sQ0FBQSxDQUFBLENBQUEsRUFBQTs0QkFlYiw0Q0FBQSxTQWZhLElBQUE7O3dCQWViLFNBZmEsQ0FBQzs7Ozs7S0FDZjtJQUNILDZCQUFBO0FBQUEsQ0F6Q0EsQUF5Q0EsQ0F6Q21ELDhCQUFlLEdBeUNsRTtBQWlCQTtJQUNBLHNDQUFzQztJQUN0QyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBQ3pDLHVEQUF1RDtJQUN2RCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO0lBQ3hDLDhEQUE4RDtJQUM5RCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO0FBQ3RDLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBNUJILG1CQThCSSxNQTdCOEIsRUE4QjlCLEtBN0IyQyxFQThCM0MsR0E3Qm1EO0lBOEJyRCxNQTdCTSxDQUFBLElBQUksc0JBQXVCLENBQWdCLE1BQU0sRUFBQyxLQUFNLEVBQUMsR0FBSSxDQUFDLENBQUM7QUE4QnZFLENBN0JDO0FBTEQsOEJBS0MiLCJmaWxlIjoiX2V4dHJlbWFieS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbmltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5hc3luY2l0ZXJhYmxlXCIpO1xuLyoqXG4gKiBAaWdub3JlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBrZXlcbiAqIEBwYXJhbSB7VH0gbWluVmFsdWVcbiAqIEByZXR1cm4geyFQcm9taXNlPG51bWJlcj59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyZUFzeW5jPFQ+KGtleTogVCwgbWluVmFsdWU6IFQpOiBQcm9taXNlPG51bWJlcj4ge1xuICByZXR1cm4ga2V5ID4gbWluVmFsdWUgPyAxIDoga2V5IDwgbWluVmFsdWUgPyAtMSA6IDA7XG59XG4vKipcbiAqIEBpZ25vcmVcbiAqIEB0ZW1wbGF0ZSBUU291cmNlLCBUS2V5XG4gKi9cbmNsYXNzIEV4dHJlbWFCeUFzeW5jSXRlcmF0b3I8VFNvdXJjZSwgVEtleT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG5wcml2YXRlIF9zb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT47XG5wcml2YXRlIF9rZXlGbjogKHg6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+O1xucHJpdmF0ZSBfY21wOiAoeDogVEtleSwgeTogVEtleSkgPT4gbnVtYmVyIHwgUHJvbWlzZTxudW1iZXI+O1xuLyoqXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IChUS2V5fCFQcm9taXNlPFRLZXk+KX0ga2V5Rm5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IChudW1iZXJ8IVByb21pc2U8bnVtYmVyPil9IGNtcFxuICovXG5jb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleUZuOiAoeDogVFNvdXJjZSkgPT4gVEtleSB8IFByb21pc2U8VEtleT4sXG4gICAgICBjbXA6ICh4OiBUS2V5LCB5OiBUS2V5KSA9PiBudW1iZXIgfCBQcm9taXNlPG51bWJlcj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9rZXlGbiA9IGtleUZuO1xuICAgIHRoaXMuX2NtcCA9IGNtcDtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFRTb3VyY2U+fVxuICovXG5hc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgLyoqIEB0eXBlIHshQXJyYXk8VFNvdXJjZT59ICovIHJlc3VsdDogVFNvdXJjZVtdID0gW10sIC8qKiBAdHlwZSB7P30gKi8gZG9uZSwgLyoqIEB0eXBlIHs/fSAqLyBuZXh0O1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7IUFzeW5jSXRlcmF0b3I8VFNvdXJjZT59ICovIGl0ID0gdGhpcy5fc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGRvbmUgPSAobmV4dCA9IGF3YWl0IGl0Lm5leHQoKSkuZG9uZTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXF1ZW5jZSBjb250YWlucyBubyBlbGVtZW50cycpO1xuICAgIH1cblxuICAgIGxldCAvKiogQHR5cGUge1RTb3VyY2V9ICovIGN1cnJlbnQgPSBuZXh0LnZhbHVlO1xuICAgIGxldCAvKiogQHR5cGUge1RLZXl9ICovIHJlc0tleSA9IGF3YWl0IHRoaXMuX2tleUZuKGN1cnJlbnQpO1xuICAgIGRvbmUgPSAobmV4dCA9IGF3YWl0IGl0Lm5leHQoKSkuZG9uZTtcbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGxldCAvKiogQHR5cGUge1RTb3VyY2V9ICovIGN1cnIgPSBuZXh0LnZhbHVlO1xuICAgICAgbGV0IC8qKiBAdHlwZSB7VEtleX0gKi8ga2V5ID0gYXdhaXQgdGhpcy5fa2V5Rm4oY3Vycik7XG4gICAgICBjb25zdCAvKiogQHR5cGUge251bWJlcn0gKi8gYyA9IGF3YWl0IHRoaXMuX2NtcChrZXksIHJlc0tleSk7XG4gICAgICBpZiAoYyA9PT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChjdXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoYyA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gW2N1cnJdO1xuICAgICAgICByZXNLZXkgPSBrZXk7XG4gICAgICB9XG4gICAgICBkb25lID0gKG5leHQgPSBhd2FpdCBpdC5uZXh0KCkpLmRvbmU7XG4gICAgfVxuXG4gICAgeWllbGQqIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBFeHRyZW1hQnlBc3luY0l0ZXJhdG9yX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUgeyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSAqL1xuRXh0cmVtYUJ5QXN5bmNJdGVyYXRvci5wcm90b3R5cGUuX3NvdXJjZTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oVFNvdXJjZSk6IChUS2V5fCFQcm9taXNlPFRLZXk+KX0gKi9cbkV4dHJlbWFCeUFzeW5jSXRlcmF0b3IucHJvdG90eXBlLl9rZXlGbjtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IChudW1iZXJ8IVByb21pc2U8bnVtYmVyPil9ICovXG5FeHRyZW1hQnlBc3luY0l0ZXJhdG9yLnByb3RvdHlwZS5fY21wO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqIEB0ZW1wbGF0ZSBUU291cmNlLCBUS2V5XG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IChUS2V5fCFQcm9taXNlPFRLZXk+KX0ga2V5Rm5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IChudW1iZXJ8IVByb21pc2U8bnVtYmVyPil9IGNtcFxuICogQHJldHVybiB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyZW1hQnk8VFNvdXJjZSwgVEtleT4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIGtleUZuOiAoeDogVFNvdXJjZSkgPT4gVEtleSB8IFByb21pc2U8VEtleT4sXG4gICAgY21wOiAoeDogVEtleSwgeTogVEtleSkgPT4gbnVtYmVyIHwgUHJvbWlzZTxudW1iZXI+KTogQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IEV4dHJlbWFCeUFzeW5jSXRlcmF0b3I8VFNvdXJjZSwgVEtleT4oc291cmNlLCBrZXlGbiwgY21wKTtcbn1cbiJdfQ==