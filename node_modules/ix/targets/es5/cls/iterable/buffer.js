goog.module('targets.es5.cls.iterable.buffer'); exports = {}; var module = {id: 'targets/es5/cls/iterable/buffer.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.es5.cls.iterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
/**
 * @template TSource
 */
var BufferIterable = (function (_super) {
    __extends(BufferIterable, _super);
    /**
     * @param {!Iterable<TSource>} source
     * @param {number} count
     * @param {number} skip
     */
    function BufferIterable(source, count, skip) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._count = count;
        _this._skip = skip;
        return _this;
    }
    /**
     * @return {!IterableIterator<!Array<TSource>>}
     */
    BufferIterable.prototype[Symbol.iterator] = function () {
        var buffers, i, _a, _b, item, buffers_1, buffers_1_1, buffer_1, e_1_1, e_1, _c, e_2, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    buffers = [], i = 0;
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 7, 8, 9]);
                    _a = __values(this._source), _b = _a.next();
                    _e.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 6];
                    item = _b.value;
                    if (i % this._skip === 0) {
                        buffers.push([]);
                    }
                    try {
                        for (buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                            buffer_1 = buffers_1_1.value;
                            buffer_1.push(item);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (buffers_1_1 && !buffers_1_1.done && (_d = buffers_1.return)) _d.call(buffers_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!(buffers.length > 0 && buffers[0].length === this._count)) return [3 /*break*/, 4];
                    return [4 /*yield*/, /** @type {!Array<TSource>} */ ((buffers.shift()))];
                case 3:
                    _e.sent();
                    _e.label = 4;
                case 4:
                    i++;
                    _e.label = 5;
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9:
                    if (!(buffers.length > 0)) return [3 /*break*/, 11];
                    return [4 /*yield*/, /** @type {!Array<TSource>} */ ((buffers.shift()))];
                case 10:
                    _e.sent();
                    return [3 /*break*/, 9];
                case 11: return [2 /*return*/];
            }
        });
    };
    return BufferIterable;
}(iterable_1.IterableX));
function BufferIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<TSource>} */
    BufferIterable.prototype._source;
    /** @type {number} */
    BufferIterable.prototype._count;
    /** @type {number} */
    BufferIterable.prototype._skip;
}
/**
 * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
 * \@example <caption>Creates a sequence of buffers with and without skip</caption>
 * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
 *
 * // Without skip
 * const result = buffer(source, 5);
 * const result = Ix.Iterable.from(source).buffer(5);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2, 3, 4]
 * // => [5, 6, 7, 8, 9]
 *
 * // With skip
 * const result = buffer(source, 3, 4);
 * const result = Ix.Iterable.from(source).buffer(3, 4);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2]
 * // => [4, 5, 6]
 * // => [8, 9]
 * to the count.
 * @template TSource
 * @param {!Iterable<TSource>} source
 * @param {number} count
 * @param {number=} skip
 * @return {!tsickle_forward_declare_1.IterableX<!Array<TSource>>}
 */
function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferIterable(source, count, skip);
}
exports.buffer = buffer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9idWZmZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILHdDQUxrQjtBQU1sQixJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsc0NBQXNDLENBQUMsQ0FBQztBQUM5Rjs7R0FFRztBQVBIO0lBQXFDLGtDQUFxQjtJQVkxRDs7OztPQUlHO0lBWEQsd0JBQVksTUFBeUIsRUFBQyxLQUFjLEVBQUMsSUFBYTtRQUFsRSxZQWFFLGlCQVpPLFNBZ0JSO1FBSEMsS0FaSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7UUFhdEIsS0FaSSxDQUFDLE1BQU0sR0FBRSxLQUFNLENBQUM7UUFhcEIsS0FaSSxDQUFDLEtBQUssR0FBRSxJQUFLLENBQUM7O0lBYXBCLENBQUM7SUFDSDs7T0FFRztJQWJBLHlCQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBbEI7Ozs7O29CQUNLLE9BQVEsR0FBZSxFQUFHLEVBQUMsQ0FBRyxHQUFFLENBQUUsQ0FBQzs7OztvQkFDdEIsS0FBQSxTQUFBLElBQUssQ0FBQyxPQUFPLENBQUE7Ozs7b0JBQXJCLElBQUs7b0JBZVgsRUFBRSxDQUFDLENBZEMsQ0FBQyxHQUFFLElBQUssQ0FBQyxLQUFLLEtBQUksQ0FBRSxDQUFDLENBQUEsQ0FBRTt3QkFlekIsT0FkTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFlbkIsQ0FkQzs7d0JBZ0JELEdBQUcsQ0FBQyxDQWRjLFlBQUEsU0FBQSxPQUFRLENBQUE7NEJBQXJCOzRCQWVILFFBZE0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7eUJBQ25COzs7Ozs7Ozs7eUJBRUcsQ0FBQSxPQUFPLENBQUMsTUFBTSxHQUFFLENBQUUsSUFBRyxPQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFJLElBQUssQ0FBQyxNQUFNLENBQUEsRUFBdkQsd0JBQXVEO29CQWV6RCxxQkFBTSw4QkFBOEIsQ0FBQSxDQUFDLENBZGhDLE9BQVEsQ0FBQyxLQUFLLEVBQUEsQ0FBQSxDQUFHLEVBQUE7O29CQWN0QixTQWRzQixDQUFDOzs7b0JBaUJ6QixDQWRDLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBR0MsQ0FBQSxPQUFPLENBQUMsTUFBTSxHQUFFLENBQUUsQ0FBQTtvQkFldkIscUJBQU0sOEJBQThCLENBQUEsQ0FBQyxDQWRoQyxPQUFRLENBQUMsS0FBSyxFQUFBLENBQUEsQ0FBRyxFQUFBOztvQkFjdEIsU0Fkc0IsQ0FBQzs7Ozs7S0FFMUI7SUFDSCxxQkFBQTtBQUFBLENBbENBLEFBa0NBLENBbENxQyxvQkFBVSxHQWtDL0M7QUFnQkE7SUFDQSxpQ0FBaUM7SUFDakMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFDakMscUJBQXFCO0lBQ3JCLGNBQWMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO0lBQ2hDLHFCQUFxQjtJQUNyQixjQUFjLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztBQUMvQixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBdkJILGdCQXlCSSxNQXhCeUIsRUF5QnpCLEtBeEJhLEVBeUJiLElBeEJhO0lBeUJmLEVBQUUsQ0FBQyxDQXhCQyxJQUFJLElBQUcsSUFBSyxDQUFDLENBQUEsQ0FBRTtRQUFBLElBQUssR0FBRSxLQUFNLENBQUM7SUFBQSxDQUFFO0lBeUJwQyxNQXhCTSxDQUFBLElBQUksY0FBZSxDQUFDLE1BQU0sRUFBQyxLQUFNLEVBQUMsSUFBSyxDQUFDLENBQUM7QUF5QmhELENBeEJDO0FBTkQsd0JBTUMiLCJmaWxlIjoiYnVmZmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaXRlcmFibGVcIik7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmNsYXNzIEJ1ZmZlckl0ZXJhYmxlPFRTb3VyY2U+IGV4dGVuZHMgSXRlcmFibGVYPFRTb3VyY2VbXT4ge1xucHJpdmF0ZSBfc291cmNlOiBJdGVyYWJsZTxUU291cmNlPjtcbnByaXZhdGUgX2NvdW50OiBudW1iZXI7XG5wcml2YXRlIF9za2lwOiBudW1iZXI7XG4vKipcbiAqIEBwYXJhbSB7IUl0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtudW1iZXJ9IHNraXBcbiAqL1xuY29uc3RydWN0b3Ioc291cmNlOiBJdGVyYWJsZTxUU291cmNlPiwgY291bnQ6IG51bWJlciwgc2tpcDogbnVtYmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICB0aGlzLl9za2lwID0gc2tpcDtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshSXRlcmFibGVJdGVyYXRvcjwhQXJyYXk8VFNvdXJjZT4+fVxuICovXG4qW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IC8qKiBAdHlwZSB7IUFycmF5PCFBcnJheTxUU291cmNlPj59ICovIGJ1ZmZlcnM6IFRTb3VyY2VbXVtdID0gW10sIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAgaSA9IDA7XG4gICAgZm9yIChsZXQgLyoqIEB0eXBlIHtUU291cmNlfSAqLyBpdGVtIG9mIHRoaXMuX3NvdXJjZSkge1xuICAgICAgaWYgKGkgJSB0aGlzLl9za2lwID09PSAwKSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IC8qKiBAdHlwZSB7IUFycmF5PFRTb3VyY2U+fSAqLyBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCAmJiBidWZmZXJzWzBdLmxlbmd0aCA9PT0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgeWllbGQgLyoqIEB0eXBlIHshQXJyYXk8VFNvdXJjZT59ICovKCggYnVmZmVycy5zaGlmdCgpKSk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB5aWVsZCAvKiogQHR5cGUgeyFBcnJheTxUU291cmNlPn0gKi8oKCBidWZmZXJzLnNoaWZ0KCkpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQnVmZmVySXRlcmFibGVfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7IUl0ZXJhYmxlPFRTb3VyY2U+fSAqL1xuQnVmZmVySXRlcmFibGUucHJvdG90eXBlLl9zb3VyY2U7XG4vKiogQHR5cGUge251bWJlcn0gKi9cbkJ1ZmZlckl0ZXJhYmxlLnByb3RvdHlwZS5fY291bnQ7XG4vKiogQHR5cGUge251bWJlcn0gKi9cbkJ1ZmZlckl0ZXJhYmxlLnByb3RvdHlwZS5fc2tpcDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzZXF1ZW5jZSBvZiBidWZmZXJzIG92ZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSwgd2l0aCBzcGVjaWZpZWQgbGVuZ3RoIGFuZCBwb3NzaWJsZSBvdmVybGFwLlxuICogXFxAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGVzIGEgc2VxdWVuY2Ugb2YgYnVmZmVycyB3aXRoIGFuZCB3aXRob3V0IHNraXA8L2NhcHRpb24+XG4gKiBjb25zdCBzb3VyY2UgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMF07XG4gKiBcbiAqIC8vIFdpdGhvdXQgc2tpcFxuICogY29uc3QgcmVzdWx0ID0gYnVmZmVyKHNvdXJjZSwgNSk7XG4gKiBjb25zdCByZXN1bHQgPSBJeC5JdGVyYWJsZS5mcm9tKHNvdXJjZSkuYnVmZmVyKDUpO1xuICogZm9yIChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfVxuICogLy8gPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiAvLyA9PiBbNSwgNiwgNywgOCwgOV1cbiAqIFxuICogLy8gV2l0aCBza2lwXG4gKiBjb25zdCByZXN1bHQgPSBidWZmZXIoc291cmNlLCAzLCA0KTtcbiAqIGNvbnN0IHJlc3VsdCA9IEl4Lkl0ZXJhYmxlLmZyb20oc291cmNlKS5idWZmZXIoMywgNCk7XG4gKiBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKiAvLyA9PiBbMCwgMSwgMl1cbiAqIC8vID0+IFs0LCA1LCA2XVxuICogLy8gPT4gWzgsIDldXG4gKiB0byB0aGUgY291bnQuXG4gKiBAdGVtcGxhdGUgVFNvdXJjZVxuICogQHBhcmFtIHshSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge251bWJlcj19IHNraXBcbiAqIEByZXR1cm4geyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xLkl0ZXJhYmxlWDwhQXJyYXk8VFNvdXJjZT4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyPFRTb3VyY2U+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgY291bnQ6IG51bWJlcixcbiAgICBza2lwPzogbnVtYmVyKTogSXRlcmFibGVYPFRTb3VyY2VbXT4ge1xuICBpZiAoc2tpcCA9PSBudWxsKSB7IHNraXAgPSBjb3VudDsgfVxuIHJldHVybiBuZXcgQnVmZmVySXRlcmFibGUoc291cmNlLCBjb3VudCwgc2tpcCk7XG59XG4iXX0=