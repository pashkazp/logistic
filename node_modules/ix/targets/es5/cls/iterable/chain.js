goog.module('targets.es5.cls.iterable.chain'); exports = {}; var module = {id: 'targets/es5/cls/iterable/chain.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.es5.cls.iterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
/**
 * @template TResult
 */
var ChainIterable = (function (_super) {
    __extends(ChainIterable, _super);
    /**
     * @param {!Iterable<TResult>} result
     */
    function ChainIterable(result) {
        var _this = _super.call(this) || this;
        _this._result = result;
        return _this;
    }
    /**
     * @return {!Iterator<TResult>}
     */
    ChainIterable.prototype[Symbol.iterator] = function () {
        return this._result[Symbol.iterator]();
    };
    return ChainIterable;
}(iterable_1.IterableX));
function ChainIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<TResult>} */
    ChainIterable.prototype._result;
}
/**
 * Returns an iterable sequence that is the result of invoking the selector on the source sequence,
 * without sharing subscriptions.  This operator allows for a fluent style of writing queries that use
 * the same sequence multiple times.
 * the source sequence as many times as needed, without sharing subscriptions to the source sequence.
 * @template TSource, TResult
 * @param {!Iterable<TSource>} source
 * @param {function(!Iterable<TSource>): !Iterable<TResult>} selector
 * @return {!tsickle_forward_declare_1.IterableX<TResult>} An iterable sequence that contains the elements of a sequence produced by multicasting the source
 * sequence within a selector function.
 */
function chain(source, selector) {
    return new ChainIterable(selector(source));
}
exports.chain = chain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9jaGFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7O0FBRUgsd0NBTGtCO0FBTWxCLElBQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0FBQzlGOztHQUVHO0FBUEg7SUFBb0MsaUNBQW1CO0lBVXZEOztPQUVHO0lBVEQsdUJBQVksTUFBeUI7UUFBckMsWUFXRSxpQkFWTyxTQVlSO1FBREMsS0FWSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7O0lBV3hCLENBQUM7SUFDSDs7T0FFRztJQVhELHdCQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBakI7UUFhRSxNQVpNLENBQUEsSUFBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQWF6QyxDQVpDO0lBQ0gsb0JBQUE7QUFBQSxDQVhBLEFBV0EsQ0FYb0Msb0JBQVUsR0FXOUM7QUFjQTtJQUNBLGlDQUFpQztJQUNqQyxhQUFhLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztBQUNoQyxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQWpCSCxlQW1CSSxNQWxCeUIsRUFtQnpCLFFBbEIwRDtJQW1CNUQsTUFsQk0sQ0FBQSxJQUFJLGFBQWMsQ0FBVSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQW1CdEQsQ0FsQkM7QUFKRCxzQkFJQyIsImZpbGUiOiJjaGFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbmltcG9ydCB7IEl0ZXJhYmxlWCB9IGZyb20gJy4uL2l0ZXJhYmxlJztcbmNvbnN0IHRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEgPSBnb29nLmZvcndhcmREZWNsYXJlKFwiX1VzZXJzLnB0YXlsb3IuZGV2Lml4anMuc3JjLml0ZXJhYmxlXCIpO1xuLyoqXG4gKiBAdGVtcGxhdGUgVFJlc3VsdFxuICovXG5jbGFzcyBDaGFpbkl0ZXJhYmxlPFRSZXN1bHQ+IGV4dGVuZHMgSXRlcmFibGVYPFRSZXN1bHQ+IHtcbnByaXZhdGUgX3Jlc3VsdDogSXRlcmFibGU8VFJlc3VsdD47XG4vKipcbiAqIEBwYXJhbSB7IUl0ZXJhYmxlPFRSZXN1bHQ+fSByZXN1bHRcbiAqL1xuY29uc3RydWN0b3IocmVzdWx0OiBJdGVyYWJsZTxUUmVzdWx0Pikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0O1xuICB9XG4vKipcbiAqIEByZXR1cm4geyFJdGVyYXRvcjxUUmVzdWx0Pn1cbiAqL1xuW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3VsdFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gQ2hhaW5JdGVyYWJsZV90c2lja2xlX0Nsb3N1cmVfZGVjbGFyYXRpb25zKCkge1xuLyoqIEB0eXBlIHshSXRlcmFibGU8VFJlc3VsdD59ICovXG5DaGFpbkl0ZXJhYmxlLnByb3RvdHlwZS5fcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaXRlcmFibGUgc2VxdWVuY2UgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBzZWxlY3RvciBvbiB0aGUgc291cmNlIHNlcXVlbmNlLFxuICogd2l0aG91dCBzaGFyaW5nIHN1YnNjcmlwdGlvbnMuICBUaGlzIG9wZXJhdG9yIGFsbG93cyBmb3IgYSBmbHVlbnQgc3R5bGUgb2Ygd3JpdGluZyBxdWVyaWVzIHRoYXQgdXNlXG4gKiB0aGUgc2FtZSBzZXF1ZW5jZSBtdWx0aXBsZSB0aW1lcy5cbiAqIHRoZSBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc2VxdWVuY2UuXG4gKiBAdGVtcGxhdGUgVFNvdXJjZSwgVFJlc3VsdFxuICogQHBhcmFtIHshSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbighSXRlcmFibGU8VFNvdXJjZT4pOiAhSXRlcmFibGU8VFJlc3VsdD59IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHshdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMS5JdGVyYWJsZVg8VFJlc3VsdD59IEFuIGl0ZXJhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2VcbiAqIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhaW48VFNvdXJjZSwgVFJlc3VsdD4oXG4gICAgc291cmNlOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICBzZWxlY3RvcjogKHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4pID0+IEl0ZXJhYmxlPFRSZXN1bHQ+KTogSXRlcmFibGVYPFRSZXN1bHQ+IHtcbiAgcmV0dXJuIG5ldyBDaGFpbkl0ZXJhYmxlPFRSZXN1bHQ+KHNlbGVjdG9yKHNvdXJjZSkpO1xufVxuIl19