goog.module('targets.es5.cls.iterable.scan'); exports = {}; var module = {id: 'targets/es5/cls/iterable/scan.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.es5.cls.iterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
/**
 * @template T, R
 */
var ScanIterable = (function (_super) {
    __extends(ScanIterable, _super);
    /**
     * @param {!Iterable<T>} source
     * @param {function((T|R), T, number): R} fn
     * @param {...(T|R)} args
     */
    function ScanIterable(source, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._fn = fn;
        _this._hasSeed = args.length === 1;
        _this._seed = args[0];
        return _this;
    }
    /**
     * @return {!IterableIterator<R>}
     */
    ScanIterable.prototype[Symbol.iterator] = function () {
        var i, hasValue, _a, _b, item, e_1_1, e_1, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    i = 0, hasValue = false;
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 7, 8, 9]);
                    _a = __values(this._source), _b = _a.next();
                    _d.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 6];
                    item = _b.value;
                    if (!(hasValue || (hasValue = this._hasSeed))) return [3 /*break*/, 4];
                    this._seed = this._fn(/** @type {R} */ (this._seed), item, i++);
                    return [4 /*yield*/, this._seed];
                case 3:
                    _d.sent();
                    return [3 /*break*/, 5];
                case 4:
                    this._seed = item;
                    hasValue = true;
                    i++;
                    _d.label = 5;
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    };
    return ScanIterable;
}(iterable_1.IterableX));
function ScanIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<T>} */
    ScanIterable.prototype._source;
    /** @type {function((T|R), T, number): R} */
    ScanIterable.prototype._fn;
    /** @type {(T|R)} */
    ScanIterable.prototype._seed;
    /** @type {boolean} */
    ScanIterable.prototype._hasSeed;
}
/**
 * @template T, R
 * @param {!Iterable<T>} source
 * @param {function((T|R), T, number): R} accumulator
 * @param {...(T|R)} args
 * @return {!tsickle_forward_declare_1.IterableX<(T|R)>}
 */
function scan(source, accumulator) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return new (ScanIterable.bind.apply(ScanIterable, __spread([void 0, source, accumulator], args)))();
}
exports.scan = scan;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9zY2FuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRzs7QUFFSCx3Q0FMa0I7QUFNbEIsSUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7QUFDOUY7O0dBRUc7QUFQSDtJQUFnQyxnQ0FBYTtJQWE3Qzs7OztPQUlHO0lBWEQsc0JBYUksTUFabUIsRUFhbkIsRUFaMEM7UUFhMUMsY0Faa0I7YUFZbEIsVUFaa0IsRUFZbEIscUJBWmtCLEVBWWxCLElBWmtCO1lBWWxCLDZCQVprQjs7UUFIdEIsWUFnQkUsaUJBWk8sU0FpQlI7UUFKQyxLQVpJLENBQUMsT0FBTyxHQUFFLE1BQU8sQ0FBQztRQWF0QixLQVpJLENBQUMsR0FBRyxHQUFFLEVBQUcsQ0FBQztRQWFkLEtBWkksQ0FBQyxRQUFRLEdBQUUsSUFBSyxDQUFDLE1BQU0sS0FBSSxDQUFFLENBQUM7UUFhbEMsS0FaSSxDQUFDLEtBQUssR0FBRSxJQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBYXZCLENBQUM7SUFDSDs7T0FFRztJQWJBLHVCQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBbEI7Ozs7O29CQUNLLENBQUUsR0FBRSxDQUFFLEVBQUMsUUFBUyxHQUFFLEtBQU0sQ0FBQzs7OztvQkFDWixLQUFBLFNBQUEsSUFBSyxDQUFDLE9BQU8sQ0FBQTs7OztvQkFBckIsSUFBSzt5QkFDUCxDQUFBLFFBQVEsSUFBRyxDQUFFLFFBQVEsR0FBRSxJQUFLLENBQUMsUUFBUSxDQUFDLENBQUEsRUFBdEMsd0JBQXNDO29CQWV4QyxJQWRJLENBQUMsS0FBSyxHQUFFLElBQUssQ0FBQyxHQUFHLENBQUEsZ0JBQUEsQ0FBQSxDQUFJLElBQUksQ0FBQyxLQUFBLENBQUssRUFBQyxJQUFLLEVBQUMsQ0FBRSxFQUFFLENBQUMsQ0FBQztvQkFlaEQscUJBZEssSUFBSyxDQUFDLEtBQUssRUFBQTs7b0JBY2hCLFNBZGdCLENBQUM7OztvQkFnQmpCLElBZEksQ0FBQyxLQUFLLEdBQUUsSUFBSyxDQUFDO29CQWVsQixRQWRRLEdBQUUsSUFBSyxDQUFDO29CQWVoQixDQWRDLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUdUO0lBQ0gsbUJBQUE7QUFBQSxDQTlCQSxBQThCQSxDQTlCZ0Msb0JBQVUsR0E4QjFDO0FBZ0JBO0lBQ0EsMkJBQTJCO0lBQzNCLFlBQVksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBQy9CLDRDQUE0QztJQUM1QyxZQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztJQUMzQixvQkFBb0I7SUFDcEIsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7SUFDN0Isc0JBQXNCO0lBQ3RCLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBQ2hDLENBQUM7QUFVRDs7Ozs7O0dBTUc7QUFoQ0gsY0FrQ0ksTUFqQ21CLEVBa0NuQixXQWpDdUQ7SUFrQ3ZELGNBakNrQjtTQWlDbEIsVUFqQ2tCLEVBaUNsQixxQkFqQ2tCLEVBaUNsQixJQWpDa0I7UUFpQ2xCLDZCQWpDa0I7O0lBa0NwQixNQWpDTSxNQUFJLFlBQWEsWUFBYixZQUFhLG9CQUFDLE1BQU0sRUFBQyxXQUFZLEdBQUssSUFBSSxNQUFFO0FBa0N4RCxDQWpDQztBQUxELG9CQUtDIiwiZmlsZSI6InNjYW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pdGVyYWJsZVwiKTtcbi8qKlxuICogQHRlbXBsYXRlIFQsIFJcbiAqL1xuY2xhc3MgU2Nhbkl0ZXJhYmxlPFQsIFI+IGV4dGVuZHMgSXRlcmFibGVYPFI+IHtcbnByaXZhdGUgX3NvdXJjZTogSXRlcmFibGU8VD47XG5wcml2YXRlIF9mbjogKGFjYzogVCB8IFIsIHg6IFQsIGluZGV4OiBudW1iZXIpID0+IFI7XG5wcml2YXRlIF9zZWVkPzogVCB8IFI7XG5wcml2YXRlIF9oYXNTZWVkOiBib29sZWFuO1xuLyoqXG4gKiBAcGFyYW0geyFJdGVyYWJsZTxUPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKChUfFIpLCBULCBudW1iZXIpOiBSfSBmblxuICogQHBhcmFtIHsuLi4oVHxSKX0gYXJnc1xuICovXG5jb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogSXRlcmFibGU8VD4sXG4gICAgICBmbjogKGFjYzogVCB8IFIsIHg6IFQsIGluZGV4OiBudW1iZXIpID0+IFIsXG4gICAgICAuLi5hcmdzOiAoVCB8IFIpW10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9mbiA9IGZuO1xuICAgIHRoaXMuX2hhc1NlZWQgPSBhcmdzLmxlbmd0aCA9PT0gMTtcbiAgICB0aGlzLl9zZWVkID0gYXJnc1swXTtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshSXRlcmFibGVJdGVyYXRvcjxSPn1cbiAqL1xuKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gaSA9IDAsIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gaGFzVmFsdWUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCAvKiogQHR5cGUge1R9ICovIGl0ZW0gb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICBpZiAoaGFzVmFsdWUgfHwgKGhhc1ZhbHVlID0gdGhpcy5faGFzU2VlZCkpIHtcbiAgICAgICAgdGhpcy5fc2VlZCA9IHRoaXMuX2ZuKCAvKiogQHR5cGUge1J9ICovKCg8Uj50aGlzLl9zZWVkKSksIGl0ZW0sIGkrKyk7XG4gICAgICAgIHlpZWxkIHRoaXMuX3NlZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWVkID0gaXRlbTtcbiAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIFNjYW5JdGVyYWJsZV90c2lja2xlX0Nsb3N1cmVfZGVjbGFyYXRpb25zKCkge1xuLyoqIEB0eXBlIHshSXRlcmFibGU8VD59ICovXG5TY2FuSXRlcmFibGUucHJvdG90eXBlLl9zb3VyY2U7XG4vKiogQHR5cGUge2Z1bmN0aW9uKChUfFIpLCBULCBudW1iZXIpOiBSfSAqL1xuU2Nhbkl0ZXJhYmxlLnByb3RvdHlwZS5fZm47XG4vKiogQHR5cGUgeyhUfFIpfSAqL1xuU2Nhbkl0ZXJhYmxlLnByb3RvdHlwZS5fc2VlZDtcbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cblNjYW5JdGVyYWJsZS5wcm90b3R5cGUuX2hhc1NlZWQ7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYW48VD4oXG4gIHNvdXJjZTogSXRlcmFibGU8VD4sXG4gIGFjY3VtdWxhdG9yOiAoYWNjOiBULCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gVCk6IEl0ZXJhYmxlWDxUPjtcbmV4cG9ydCBmdW5jdGlvbiBzY2FuPFQsIFIgPSBUPihcbiAgc291cmNlOiBJdGVyYWJsZTxUPixcbiAgYWNjdW11bGF0b3I6IChhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBSLFxuICBzZWVkOiBSKTogSXRlcmFibGVYPFI+O1xuLyoqXG4gKiBAdGVtcGxhdGUgVCwgUlxuICogQHBhcmFtIHshSXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbigoVHxSKSwgVCwgbnVtYmVyKTogUn0gYWNjdW11bGF0b3JcbiAqIEBwYXJhbSB7Li4uKFR8Uil9IGFyZ3NcbiAqIEByZXR1cm4geyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xLkl0ZXJhYmxlWDwoVHxSKT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FuPFQsIFIgPSBUPihcbiAgICBzb3VyY2U6IEl0ZXJhYmxlPFQ+LFxuICAgIGFjY3VtdWxhdG9yOiAoYWNjOiBUIHwgUiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIsXG4gICAgLi4uYXJnczogKFQgfCBSKVtdKTogSXRlcmFibGVYPFQgfCBSPiB7XG4gIHJldHVybiBuZXcgU2Nhbkl0ZXJhYmxlKHNvdXJjZSwgYWNjdW11bGF0b3IsIC4uLmFyZ3MpO1xufVxuIl19