goog.module('targets.es5.cls.iterable.orderby'); exports = {}; var module = {id: 'targets/es5/cls/iterable/orderby.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.es5.cls.iterable');
var tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
var sorter_1 = goog.require('targets.es5.cls.internal.sorter');
var tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.internal.sorter");
/**
 * @abstract
 * @template TSource
 */
var OrderedIterableBaseX = (function (_super) {
    __extends(OrderedIterableBaseX, _super);
    /**
     * @param {!Iterable<TSource>} source
     */
    function OrderedIterableBaseX(source) {
        var _this = _super.call(this) || this;
        _this._source = source;
        return _this;
    }
    /**
     * @return {!IterableIterator<TSource>}
     */
    OrderedIterableBaseX.prototype[Symbol.iterator] = function () {
        var array, len, indices, i, len_1, indices_1, indices_1_1, index, e_1_1, e_1, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    array = Array.from(this._source);
                    len = array.length;
                    indices = new Array(len);
                    for (i = 0, len_1 = array.length; i < len_1; i++) {
                        indices[i] = i;
                    }
                    indices.sort(this._getSorter(array));
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 8]);
                    indices_1 = __values(indices), indices_1_1 = indices_1.next();
                    _b.label = 2;
                case 2:
                    if (!!indices_1_1.done) return [3 /*break*/, 5];
                    index = indices_1_1.value;
                    return [4 /*yield*/, array[index]];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    indices_1_1 = indices_1.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (indices_1_1 && !indices_1_1.done && (_a = indices_1.return)) _a.call(indices_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/];
            }
        });
    };
    /**
     * @template TKey
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number=} comparer
     * @return {!OrderedIterableBaseX}
     */
    OrderedIterableBaseX.prototype.thenBy = function (keySelector, comparer) {
        if (comparer === void 0) { comparer = sorter_1.sorter; }
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedIterableX(this._source, keySelector, comparer, false, this);
    };
    /**
     * @template TKey
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number=} comparer
     * @return {!OrderedIterableBaseX}
     */
    OrderedIterableBaseX.prototype.thenByDescending = function (keySelector, comparer) {
        if (comparer === void 0) { comparer = sorter_1.sorter; }
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedIterableX(this._source, keySelector, comparer, true, this);
    };
    return OrderedIterableBaseX;
}(iterable_1.IterableX));
exports.OrderedIterableBaseX = OrderedIterableBaseX;
function OrderedIterableBaseX_tsickle_Closure_declarations() {
    /** @type {!Iterable<TSource>} */
    OrderedIterableBaseX.prototype._source;
    /**
     * @abstract
     * @param {!Array<TSource>} elements
     * @param {function(number, number): number=} next
     * @return {function(number, number): number}
     */
    OrderedIterableBaseX.prototype._getSorter = function (elements, next) { };
}
/**
 * @template TKey, TSource
 */
var OrderedIterableX = (function (_super) {
    __extends(OrderedIterableX, _super);
    /**
     * @param {!Iterable<TSource>} source
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number} comparer
     * @param {boolean} descending
     * @param {!OrderedIterableBaseX<TSource>=} parent
     */
    function OrderedIterableX(source, keySelector, comparer, descending, parent) {
        var _this = _super.call(this, source) || this;
        _this._keySelector = keySelector;
        _this._comparer = comparer;
        _this._descending = descending;
        _this._parent = parent;
        return _this;
    }
    /**
     * @param {!Array<TSource>} elements
     * @param {function(number, number): number=} next
     * @return {function(number, number): number}
     */
    OrderedIterableX.prototype._getSorter = function (elements, next) {
        var /** @type {!Array<TKey>} */ keys = elements.map(this._keySelector);
        var /** @type {function(TKey, TKey): number} */ comparer = this._comparer;
        var /** @type {!OrderedIterableBaseX<TSource>} */ parent = this._parent;
        var /** @type {boolean} */ descending = this._descending;
        var /** @type {function(number, number): number} */ sorter = function (x, y) {
            var /** @type {number} */ result = comparer(keys[x], keys[y]);
            if (result === 0) {
                return next ? next(x, y) : x - y;
            }
            return descending ? -result : result;
        };
        return parent ? parent._getSorter(elements, sorter) : sorter;
    };
    return OrderedIterableX;
}(OrderedIterableBaseX));
exports.OrderedIterableX = OrderedIterableX;
function OrderedIterableX_tsickle_Closure_declarations() {
    /** @type {function(TSource): TKey} */
    OrderedIterableX.prototype._keySelector;
    /** @type {function(TKey, TKey): number} */
    OrderedIterableX.prototype._comparer;
    /** @type {boolean} */
    OrderedIterableX.prototype._descending;
    /** @type {!OrderedIterableBaseX<TSource>} */
    OrderedIterableX.prototype._parent;
}
/**
 * @template TKey, TSource
 * @param {!Iterable<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedIterableX<TKey, TSource>}
 */
function orderBy(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedIterableX(source, keySelector, comparer, false);
}
exports.orderBy = orderBy;
/**
 * @template TKey, TSource
 * @param {!Iterable<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedIterableX<TKey, TSource>}
 */
function orderByDescending(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedIterableX(source, keySelector, comparer, true);
}
exports.orderByDescending = orderByDescending;
/**
 * @template TKey, TSource
 * @param {!OrderedIterableBaseX<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedIterableX<TKey, TSource>}
 */
function thenBy(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedIterableX(source._source, keySelector, comparer, false, source);
}
exports.thenBy = thenBy;
/**
 * @template TKey, TSource
 * @param {!OrderedIterableBaseX<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedIterableX<TKey, TSource>}
 */
function thenByDescending(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedIterableX(source._source, keySelector, comparer, true, source);
}
exports.thenByDescending = thenByDescending;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9vcmRlcmJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRzs7QUFFSCx3Q0FMa0I7QUFNbEIsSUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLHNDQUFzQyxDQUFDLENBTnJEO0FBT3hDLDZDQU5nQztBQU9oQyxJQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsNkNBQTZDLENBQUMsQ0FBQztBQUNyRzs7O0dBR0c7QUFUSDtJQUEyRCx3Q0FBbUI7SUFZOUU7O09BRUc7SUFYRCw4QkFBWSxNQUF5QjtRQUFyQyxZQWFFLGlCQVpPLFNBY1I7UUFEQyxLQVpJLENBQUMsT0FBTyxHQUFFLE1BQU8sQ0FBQzs7SUFheEIsQ0FBQztJQUNIOztPQUVHO0lBYkEsK0JBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFsQjs7Ozs7b0JBQ08sS0FBTSxHQUFFLEtBQU0sQ0FBQyxJQUFJLENBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUMzQyxHQUFJLEdBQUUsS0FBTSxDQUFDLE1BQU0sQ0FBQztvQkFDcEIsT0FBUSxHQUFFLElBQUksS0FBTSxDQUFTLEdBQUcsQ0FBQyxDQUFDO29CQWV2QyxHQUFHLENBQUMsQ0FkSSxDQUFFLEdBQUUsQ0FBRSxFQUFDLFFBQU0sS0FBTSxDQUFDLE1BQU0sRUFBQyxDQUFFLEdBQUUsS0FBSSxFQUFDLENBQUUsRUFBRSxFQUFDLENBQUU7d0JBZWpELE9BZE8sQ0FBQyxDQUFDLENBQUMsR0FBRSxDQUFFLENBQUM7b0JBZWpCLENBZEM7b0JBZ0JELE9BZE8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7O29CQUNsQixZQUFBLFNBQUEsT0FBUSxDQUFBOzs7O29CQUFqQixLQUFNO29CQWVkLHFCQWRLLEtBQU0sQ0FBQyxLQUFLLENBQUMsRUFBQTs7b0JBY2xCLFNBZGtCLENBQUM7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QyxXQXRGb0MsRUF1RnBDLFFBdEYwRDtJQXNGMUQseUJBQUEsRUFBQSxXQXRGNEMsZUFBYztJQXVGOUQsTUF0Rk0sQ0FBQSxJQUFJLGdCQUFpQixDQUFnQixNQUFNLENBQUMsT0FBTyxFQUFDLFdBQVksRUFBQyxRQUFTLEVBQUMsSUFBSyxFQUFDLE1BQU8sQ0FBQyxDQUFDO0FBdUZsRyxDQXRGQztBQUxELDRDQUtDIiwiZmlsZSI6Im9yZGVyYnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pdGVyYWJsZVwiKTtcbmltcG9ydCB7IHNvcnRlciBhcyBkZWZhdWx0U29ydGVyIH0gZnJvbSAnLi4vaW50ZXJuYWwvc29ydGVyJztcbmNvbnN0IHRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzIgPSBnb29nLmZvcndhcmREZWNsYXJlKFwiX1VzZXJzLnB0YXlsb3IuZGV2Lml4anMuc3JjLmludGVybmFsLnNvcnRlclwiKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKiBAdGVtcGxhdGUgVFNvdXJjZVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBfc291cmNlOiBJdGVyYWJsZTxUU291cmNlPjtcbi8qKlxuICogQHBhcmFtIHshSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gIH1cbi8qKlxuICogQHJldHVybiB7IUl0ZXJhYmxlSXRlcmF0b3I8VFNvdXJjZT59XG4gKi9cbipbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCAvKiogQHR5cGUgeyFBcnJheTxUU291cmNlPn0gKi8gYXJyYXkgPSBBcnJheS5mcm9tPFRTb3VyY2U+KHRoaXMuX3NvdXJjZSk7XG4gICAgY29uc3QgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCAvKiogQHR5cGUgeyFBcnJheTxudW1iZXI+fSAqLyBpbmRpY2VzID0gbmV3IEFycmF5PG51bWJlcj4obGVuKTtcbiAgICBmb3IgKGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gaSA9IDAsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuXG4gICAgaW5kaWNlcy5zb3J0KHRoaXMuX2dldFNvcnRlcihhcnJheSkpO1xuICAgIGZvciAoY29uc3QgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGluZGV4IG9mIGluZGljZXMpIHtcbiAgICAgIHlpZWxkIGFycmF5W2luZGV4XTtcbiAgICB9XG4gIH1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRJdGVyYWJsZUJhc2VYfVxuICovXG50aGVuQnk8VEtleT4oXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT4ge1xuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+KHRoaXMuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCBmYWxzZSwgdGhpcyk7XG4gIH1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRJdGVyYWJsZUJhc2VYfVxuICovXG50aGVuQnlEZXNjZW5kaW5nPFRLZXk+KFxuICAgICAga2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5LFxuICAgICAgY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyID0gZGVmYXVsdFNvcnRlcik6IE9yZGVyZWRJdGVyYWJsZUJhc2VYPFRTb3VyY2U+IHtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVzZS1iZWZvcmUtZGVjbGFyZSAqL1xuICAgIHJldHVybiBuZXcgT3JkZXJlZEl0ZXJhYmxlWDxUS2V5LCBUU291cmNlPih0aGlzLl9zb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgdHJ1ZSwgdGhpcyk7XG4gIH1cblxuICBhYnN0cmFjdCBfZ2V0U29ydGVyKFxuICAgIGVsZW1lbnRzOiBUU291cmNlW10sXG4gICAgbmV4dD86ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyKTogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIE9yZGVyZWRJdGVyYWJsZUJhc2VYX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUgeyFJdGVyYWJsZTxUU291cmNlPn0gKi9cbk9yZGVyZWRJdGVyYWJsZUJhc2VYLnByb3RvdHlwZS5fc291cmNlO1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHshQXJyYXk8VFNvdXJjZT59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogbnVtYmVyPX0gbmV4dFxuICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9XG4gKi9cbk9yZGVyZWRJdGVyYWJsZUJhc2VYLnByb3RvdHlwZS5fZ2V0U29ydGVyID0gZnVuY3Rpb24oZWxlbWVudHMsIG5leHQpIHt9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5LCBUU291cmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IGV4dGVuZHMgT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT4ge1xucHJpdmF0ZSBfa2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5O1xucHJpdmF0ZSBfY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyO1xucHJpdmF0ZSBfZGVzY2VuZGluZzogYm9vbGVhbjtcbnByaXZhdGUgX3BhcmVudD86IE9yZGVyZWRJdGVyYWJsZUJhc2VYPFRTb3VyY2U+O1xuLyoqXG4gKiBAcGFyYW0geyFJdGVyYWJsZTxUU291cmNlPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSBrZXlTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyfSBjb21wYXJlclxuICogQHBhcmFtIHtib29sZWFufSBkZXNjZW5kaW5nXG4gKiBAcGFyYW0geyFPcmRlcmVkSXRlcmFibGVCYXNlWDxUU291cmNlPj19IHBhcmVudFxuICovXG5jb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIsXG4gICAgICBkZXNjZW5kaW5nOiBib29sZWFuLFxuICAgICAgcGFyZW50PzogT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT4pIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIHRoaXMuX2tleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgdGhpcy5fY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICB0aGlzLl9kZXNjZW5kaW5nID0gZGVzY2VuZGluZztcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbi8qKlxuICogQHBhcmFtIHshQXJyYXk8VFNvdXJjZT59IGVsZW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogbnVtYmVyPX0gbmV4dFxuICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9XG4gKi9cbl9nZXRTb3J0ZXIoXG4gICAgICBlbGVtZW50czogVFNvdXJjZVtdLFxuICAgICAgbmV4dD86ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyKTogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBudW1iZXIge1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7IUFycmF5PFRLZXk+fSAqLyBrZXlzID0gZWxlbWVudHMubWFwKHRoaXMuX2tleVNlbGVjdG9yKTtcbiAgICBjb25zdCAvKiogQHR5cGUge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXJ9ICovIGNvbXBhcmVyID0gdGhpcy5fY29tcGFyZXI7XG4gICAgY29uc3QgLyoqIEB0eXBlIHshT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT59ICovIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICBjb25zdCAvKiogQHR5cGUge2Jvb2xlYW59ICovIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nO1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiBudW1iZXJ9ICovIHNvcnRlciA9ICh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICBjb25zdCAvKiogQHR5cGUge251bWJlcn0gKi8gcmVzdWx0ID0gY29tcGFyZXIoa2V5c1t4XSwga2V5c1t5XSk7XG4gICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXh0ID8gbmV4dCh4LCB5KSA6IHggLSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzY2VuZGluZyA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuX2dldFNvcnRlcihlbGVtZW50cywgc29ydGVyKSA6IHNvcnRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBPcmRlcmVkSXRlcmFibGVYX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSAqL1xuT3JkZXJlZEl0ZXJhYmxlWC5wcm90b3R5cGUuX2tleVNlbGVjdG9yO1xuLyoqIEB0eXBlIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyfSAqL1xuT3JkZXJlZEl0ZXJhYmxlWC5wcm90b3R5cGUuX2NvbXBhcmVyO1xuLyoqIEB0eXBlIHtib29sZWFufSAqL1xuT3JkZXJlZEl0ZXJhYmxlWC5wcm90b3R5cGUuX2Rlc2NlbmRpbmc7XG4vKiogQHR5cGUgeyFPcmRlcmVkSXRlcmFibGVCYXNlWDxUU291cmNlPn0gKi9cbk9yZGVyZWRJdGVyYWJsZVgucHJvdG90eXBlLl9wYXJlbnQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRLZXksIFRTb3VyY2VcbiAqIEBwYXJhbSB7IUl0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmRlckJ5PFRLZXksIFRTb3VyY2U+KFxuICAgICAgc291cmNlOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+KHNvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCBmYWxzZSk7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5LCBUU291cmNlXG4gKiBAcGFyYW0geyFJdGVyYWJsZTxUU291cmNlPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSBrZXlTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyPX0gY29tcGFyZXJcbiAqIEByZXR1cm4geyFPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJCeURlc2NlbmRpbmc8VEtleSwgVFNvdXJjZT4oXG4gICAgICBzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LFxuICAgICAga2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5LFxuICAgICAgY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyID0gZGVmYXVsdFNvcnRlcik6IE9yZGVyZWRJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIHRydWUpO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVEtleSwgVFNvdXJjZVxuICogQHBhcmFtIHshT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihUU291cmNlKTogVEtleX0ga2V5U2VsZWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcj19IGNvbXBhcmVyXG4gKiBAcmV0dXJuIHshT3JkZXJlZEl0ZXJhYmxlWDxUS2V5LCBUU291cmNlPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRoZW5CeTxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogT3JkZXJlZEl0ZXJhYmxlQmFzZVg8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEl0ZXJhYmxlWDxUS2V5LCBUU291cmNlPiB7XG4gIHJldHVybiBuZXcgT3JkZXJlZEl0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCBmYWxzZSwgc291cmNlKTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXksIFRTb3VyY2VcbiAqIEBwYXJhbSB7IU9yZGVyZWRJdGVyYWJsZUJhc2VYPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aGVuQnlEZXNjZW5kaW5nPFRLZXksIFRTb3VyY2U+KFxuICAgICAgc291cmNlOiBPcmRlcmVkSXRlcmFibGVCYXNlWDxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+KHNvdXJjZS5fc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIHRydWUsIHNvdXJjZSk7XG59XG4iXX0=