Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var iterable_1 = require("../iterable");
var BufferIterable = (function (_super) {
    tslib_1.__extends(BufferIterable, _super);
    function BufferIterable(source, count, skip) {
        var _this = _super.call(this) || this;
        _this._source = source;
        _this._count = count;
        _this._skip = skip;
        return _this;
    }
    BufferIterable.prototype[Symbol.iterator] = function () {
        var buffers, i, _a, _b, item, buffers_1, buffers_1_1, buffer_1, e_1_1, e_1, _c, e_2, _d;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    buffers = [], i = 0;
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 7, 8, 9]);
                    _a = tslib_1.__values(this._source), _b = _a.next();
                    _e.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 6];
                    item = _b.value;
                    if (i % this._skip === 0) {
                        buffers.push([]);
                    }
                    try {
                        for (buffers_1 = tslib_1.__values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                            buffer_1 = buffers_1_1.value;
                            buffer_1.push(item);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (buffers_1_1 && !buffers_1_1.done && (_d = buffers_1.return)) _d.call(buffers_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!(buffers.length > 0 && buffers[0].length === this._count)) return [3 /*break*/, 4];
                    return [4 /*yield*/, buffers.shift()];
                case 3:
                    _e.sent();
                    _e.label = 4;
                case 4:
                    i++;
                    _e.label = 5;
                case 5:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9:
                    if (!(buffers.length > 0)) return [3 /*break*/, 11];
                    return [4 /*yield*/, buffers.shift()];
                case 10:
                    _e.sent();
                    return [3 /*break*/, 9];
                case 11: return [2 /*return*/];
            }
        });
    };
    return BufferIterable;
}(iterable_1.IterableX));
/**
 * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
 * @example <caption>Creates a sequence of buffers with and without skip</caption>
 * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
 *
 * // Without skip
 * const result = buffer(source, 5);
 * const result = Ix.Iterable.from(source).buffer(5);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2, 3, 4]
 * // => [5, 6, 7, 8, 9]
 *
 * // With skip
 * const result = buffer(source, 3, 4);
 * const result = Ix.Iterable.from(source).buffer(3, 4);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2]
 * // => [4, 5, 6]
 * // => [8, 9]
 * @param {Iterabel<TSource>} source Source sequence
 * @param {number} count Number of elements for allocated buffers.
 * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults
 * to the count.
 * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements
 */
function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferIterable(source, count, skip);
}
exports.buffer = buffer;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdDQUF3QztBQUV4QztJQUFzQywwQ0FBb0I7SUFLeEQsd0JBQVksTUFBeUIsRUFBRSxLQUFhLEVBQUUsSUFBWTtRQUFsRSxZQUNFLGlCQUFPLFNBSVI7UUFIQyxLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixLQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixLQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzs7SUFDcEIsQ0FBQztJQUVBLHlCQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBbEI7Ozs7O29CQUNNLE9BQU8sR0FBZ0IsRUFBRSxFQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Ozs7b0JBQ3JCLEtBQUEsaUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQTs7OztvQkFBcEIsSUFBSTtvQkFDWCxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUNuQixDQUFDOzt3QkFFRCxHQUFHLENBQUMsQ0FBZSxZQUFBLGlCQUFBLE9BQU8sQ0FBQTs0QkFBckI7NEJBQ0gsUUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzt5QkFDbkI7Ozs7Ozs7Ozt5QkFFRyxDQUFBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQSxFQUF2RCx3QkFBdUQ7b0JBQ3pELHFCQUFNLE9BQU8sQ0FBQyxLQUFLLEVBQUcsRUFBQTs7b0JBQXRCLFNBQXNCLENBQUM7OztvQkFHekIsQ0FBQyxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQUdDLENBQUEsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUE7b0JBQ3ZCLHFCQUFNLE9BQU8sQ0FBQyxLQUFLLEVBQUcsRUFBQTs7b0JBQXRCLFNBQXNCLENBQUM7Ozs7O0tBRTFCO0lBQ0gscUJBQUM7QUFBRCxDQWxDQSxBQWtDQyxDQWxDcUMsb0JBQVMsR0FrQzlDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFDSCxnQkFDSSxNQUF5QixFQUN6QixLQUFhLEVBQ2IsSUFBYTtJQUNmLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztJQUFDLENBQUM7SUFDcEMsTUFBTSxDQUFDLElBQUksY0FBYyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDaEQsQ0FBQztBQU5ELHdCQU1DIiwiZmlsZSI6Iml0ZXJhYmxlL2J1ZmZlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZXJhYmxlWCB9IGZyb20gJy4uL2l0ZXJhYmxlJztcblxuY2xhc3MgQnVmZmVySXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZVtdPiB7XG4gIHByaXZhdGUgX3NvdXJjZTogSXRlcmFibGU8VFNvdXJjZT47XG4gIHByaXZhdGUgX2NvdW50OiBudW1iZXI7XG4gIHByaXZhdGUgX3NraXA6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LCBjb3VudDogbnVtYmVyLCBza2lwOiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIHRoaXMuX3NraXAgPSBza2lwO1xuICB9XG5cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCBidWZmZXJzOiBUU291cmNlW11bXSA9IFtdLCAgaSA9IDA7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChpICUgdGhpcy5fc2tpcCA9PT0gMCkge1xuICAgICAgICBidWZmZXJzLnB1c2goW10pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCAmJiBidWZmZXJzWzBdLmxlbmd0aCA9PT0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgeWllbGQgYnVmZmVycy5zaGlmdCgpITtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHdoaWxlIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHlpZWxkIGJ1ZmZlcnMuc2hpZnQoKSE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2VxdWVuY2Ugb2YgYnVmZmVycyBvdmVyIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIHdpdGggc3BlY2lmaWVkIGxlbmd0aCBhbmQgcG9zc2libGUgb3ZlcmxhcC5cbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZXMgYSBzZXF1ZW5jZSBvZiBidWZmZXJzIHdpdGggYW5kIHdpdGhvdXQgc2tpcDwvY2FwdGlvbj5cbiAqIGNvbnN0IHNvdXJjZSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAwXTtcbiAqXG4gKiAvLyBXaXRob3V0IHNraXBcbiAqIGNvbnN0IHJlc3VsdCA9IGJ1ZmZlcihzb3VyY2UsIDUpO1xuICogY29uc3QgcmVzdWx0ID0gSXguSXRlcmFibGUuZnJvbShzb3VyY2UpLmJ1ZmZlcig1KTtcbiAqIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH1cbiAqIC8vID0+IFswLCAxLCAyLCAzLCA0XVxuICogLy8gPT4gWzUsIDYsIDcsIDgsIDldXG4gKlxuICogLy8gV2l0aCBza2lwXG4gKiBjb25zdCByZXN1bHQgPSBidWZmZXIoc291cmNlLCAzLCA0KTtcbiAqIGNvbnN0IHJlc3VsdCA9IEl4Lkl0ZXJhYmxlLmZyb20oc291cmNlKS5idWZmZXIoMywgNCk7XG4gKiBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKiAvLyA9PiBbMCwgMSwgMl1cbiAqIC8vID0+IFs0LCA1LCA2XVxuICogLy8gPT4gWzgsIDldXG4gKiBAcGFyYW0ge0l0ZXJhYmVsPFRTb3VyY2U+fSBzb3VyY2UgU291cmNlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIGZvciBhbGxvY2F0ZWQgYnVmZmVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpcF0gTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYmV0d2VlbiB0aGUgc3RhcnQgb2YgY29uc2VjdXRpdmUgYnVmZmVycy4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHNcbiAqIHRvIHRoZSBjb3VudC5cbiAqIEByZXR1cm4ge0l0ZXJhYmxlWDxUU291cmNlPltdfSBTZXF1ZW5jZSBvZiBidWZmZXJzIGNvbnRhaW5pbmcgc291cmNlIHNlcXVlbmNlIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXI8VFNvdXJjZT4oXG4gICAgc291cmNlOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIHNraXA/OiBudW1iZXIpOiBJdGVyYWJsZVg8VFNvdXJjZVtdPiB7XG4gIGlmIChza2lwID09IG51bGwpIHsgc2tpcCA9IGNvdW50OyB9XG4gcmV0dXJuIG5ldyBCdWZmZXJJdGVyYWJsZShzb3VyY2UsIGNvdW50LCBza2lwKTtcbn1cbiJdfQ==
