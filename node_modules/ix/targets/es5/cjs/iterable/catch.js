Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var iterable_1 = require("../iterable");
var returniterator_1 = require("../internal/returniterator");
var CatchIterable = (function (_super) {
    tslib_1.__extends(CatchIterable, _super);
    function CatchIterable(source) {
        var _this = _super.call(this) || this;
        _this._source = source;
        return _this;
    }
    CatchIterable.prototype[Symbol.iterator] = function () {
        var error, hasError, _a, _b, source, it, c, _c, done, value, e_1_1, e_1, _d;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    error = null, hasError = false;
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 8, 9, 10]);
                    _a = tslib_1.__values(this._source), _b = _a.next();
                    _e.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 7];
                    source = _b.value;
                    it = source[Symbol.iterator]();
                    error = null;
                    hasError = false;
                    _e.label = 3;
                case 3:
                    if (!1) return [3 /*break*/, 5];
                    c = {};
                    try {
                        _c = it.next(), done = _c.done, value = _c.value;
                        if (done) {
                            returniterator_1.returnIterator(it);
                            return [3 /*break*/, 5];
                        }
                        c = value;
                    }
                    catch (e) {
                        error = e;
                        hasError = true;
                        returniterator_1.returnIterator(it);
                        return [3 /*break*/, 5];
                    }
                    return [4 /*yield*/, c];
                case 4:
                    _e.sent();
                    return [3 /*break*/, 3];
                case 5:
                    if (!hasError) {
                        return [3 /*break*/, 7];
                    }
                    _e.label = 6;
                case 6:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 10:
                    if (hasError) {
                        throw error;
                    }
                    return [2 /*return*/];
            }
        });
    };
    return CatchIterable;
}(iterable_1.IterableX));
/**
 * Creates a sequence by concatenating source sequences until a source sequence completes successfully.
 * @param {Iterabe<Iterable<TSource>>} source Source sequences.
 * @return {Iterable<TSource>} Sequence that continues to concatenate source sequences while errors occur.
 */
function _catchAll(source) {
    return new CatchIterable(source);
}
exports._catchAll = _catchAll;
/**
 * Creates a sequence by concatenating source sequences until a source sequence completes successfully.
 * @param {Iterable<TSource>} source The first source.
 * @param {...Iterable<TSource>} args The rest of the sequence that continues to concatenate source sequences while errors occur.
 */
function _catch(source) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return new CatchIterable(tslib_1.__spread([source], args));
}
exports._catch = _catch;
/**
 * Creates a sequence by concatenating source sequences until a source sequence completes successfully.
 * @param {...Iterable<TSource>} source Sequence that continues to concatenate source sequences while errors occur.
 * @return {Iterable<TSource>} Sequence that continues to concatenate source sequences while errors occur.
 */
function _catchStatic() {
    var source = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        source[_i] = arguments[_i];
    }
    return new CatchIterable(source);
}
exports._catchStatic = _catchStatic;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2NhdGNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsd0NBQXdDO0FBQ3hDLDZEQUE0RDtBQUU1RDtJQUFxQyx5Q0FBa0I7SUFHckQsdUJBQVksTUFBbUM7UUFBL0MsWUFDRSxpQkFBTyxTQUVSO1FBREMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7O0lBQ3hCLENBQUM7SUFFQSx3QkFBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQWxCOzs7OztvQkFDTSxLQUFLLEdBQUcsSUFBSSxFQUFFLFFBQVEsR0FBRyxLQUFLLENBQUM7Ozs7b0JBRWhCLEtBQUEsaUJBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQTs7OztvQkFBdEIsTUFBTTtvQkFDUCxFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO29CQUVyQyxLQUFLLEdBQUcsSUFBSSxDQUFDO29CQUNiLFFBQVEsR0FBRyxLQUFLLENBQUM7Ozt5QkFFVixDQUFDO29CQUNGLENBQUMsR0FBWSxFQUFFLENBQUM7b0JBRXBCLElBQUksQ0FBQzt3QkFDRyxLQUFrQixFQUFFLENBQUMsSUFBSSxFQUFFLEVBQXpCLElBQUksVUFBQSxFQUFFLEtBQUssV0FBQSxDQUFlO3dCQUNsQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOzRCQUNULCtCQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7NEJBQ25CLE1BQU0sa0JBQUE7d0JBQ1IsQ0FBQzt3QkFDRCxDQUFDLEdBQUcsS0FBSyxDQUFDO29CQUNaLENBQUM7b0JBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDWCxLQUFLLEdBQUcsQ0FBQyxDQUFDO3dCQUNWLFFBQVEsR0FBRyxJQUFJLENBQUM7d0JBQ2hCLCtCQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7d0JBQ25CLE1BQU0sa0JBQUE7b0JBQ1IsQ0FBQztvQkFFRCxxQkFBTSxDQUFDLEVBQUE7O29CQUFQLFNBQU8sQ0FBQzs7O29CQUdWLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzt3QkFBQyxNQUFNLGtCQUFBO29CQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUczQixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3dCQUFDLE1BQU0sS0FBSyxDQUFDO29CQUFDLENBQUM7Ozs7S0FDL0I7SUFDSCxvQkFBQztBQUFELENBMUNBLEFBMENDLENBMUNvQyxvQkFBUyxHQTBDN0M7QUFFRDs7OztHQUlHO0FBQ0gsbUJBQW1DLE1BQW1DO0lBQ3BFLE1BQU0sQ0FBQyxJQUFJLGFBQWEsQ0FBVSxNQUFNLENBQUMsQ0FBQztBQUM1QyxDQUFDO0FBRkQsOEJBRUM7QUFFRDs7OztHQUlHO0FBQ0gsZ0JBQWdDLE1BQXlCO0lBQUUsY0FBNEI7U0FBNUIsVUFBNEIsRUFBNUIscUJBQTRCLEVBQTVCLElBQTRCO1FBQTVCLDZCQUE0Qjs7SUFDckYsTUFBTSxDQUFDLElBQUksYUFBYSxtQkFBVyxNQUFNLEdBQUssSUFBSSxFQUFFLENBQUM7QUFDdkQsQ0FBQztBQUZELHdCQUVDO0FBRUQ7Ozs7R0FJRztBQUNIO0lBQXNDLGdCQUE4QjtTQUE5QixVQUE4QixFQUE5QixxQkFBOEIsRUFBOUIsSUFBOEI7UUFBOUIsMkJBQThCOztJQUNsRSxNQUFNLENBQUMsSUFBSSxhQUFhLENBQVUsTUFBTSxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUZELG9DQUVDIiwiZmlsZSI6Iml0ZXJhYmxlL2NhdGNoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuaW1wb3J0IHsgcmV0dXJuSXRlcmF0b3IgfSBmcm9tICcuLi9pbnRlcm5hbC9yZXR1cm5pdGVyYXRvcic7XG5cbmNsYXNzIENhdGNoSXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBwcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPEl0ZXJhYmxlPFRTb3VyY2U+PjtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPEl0ZXJhYmxlPFRTb3VyY2U+Pikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCBlcnJvciA9IG51bGwsIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICBjb25zdCBpdCA9IHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG5cbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIGxldCBjID0gPFRTb3VyY2U+e307XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybkl0ZXJhdG9yKGl0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjID0gdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJldHVybkl0ZXJhdG9yKGl0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHlpZWxkIGM7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzRXJyb3IpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAoaGFzRXJyb3IpIHsgdGhyb3cgZXJyb3I7IH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXF1ZW5jZSBieSBjb25jYXRlbmF0aW5nIHNvdXJjZSBzZXF1ZW5jZXMgdW50aWwgYSBzb3VyY2Ugc2VxdWVuY2UgY29tcGxldGVzIHN1Y2Nlc3NmdWxseS5cbiAqIEBwYXJhbSB7SXRlcmFiZTxJdGVyYWJsZTxUU291cmNlPj59IHNvdXJjZSBTb3VyY2Ugc2VxdWVuY2VzLlxuICogQHJldHVybiB7SXRlcmFibGU8VFNvdXJjZT59IFNlcXVlbmNlIHRoYXQgY29udGludWVzIHRvIGNvbmNhdGVuYXRlIHNvdXJjZSBzZXF1ZW5jZXMgd2hpbGUgZXJyb3JzIG9jY3VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoQWxsPFRTb3VyY2U+KHNvdXJjZTogSXRlcmFibGU8SXRlcmFibGU8VFNvdXJjZT4+KTogSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBDYXRjaEl0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlcXVlbmNlIGJ5IGNvbmNhdGVuYXRpbmcgc291cmNlIHNlcXVlbmNlcyB1bnRpbCBhIHNvdXJjZSBzZXF1ZW5jZSBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5LlxuICogQHBhcmFtIHtJdGVyYWJsZTxUU291cmNlPn0gc291cmNlIFRoZSBmaXJzdCBzb3VyY2UuXG4gKiBAcGFyYW0gey4uLkl0ZXJhYmxlPFRTb3VyY2U+fSBhcmdzIFRoZSByZXN0IG9mIHRoZSBzZXF1ZW5jZSB0aGF0IGNvbnRpbnVlcyB0byBjb25jYXRlbmF0ZSBzb3VyY2Ugc2VxdWVuY2VzIHdoaWxlIGVycm9ycyBvY2N1ci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaDxUU291cmNlPihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LCAuLi5hcmdzOiBJdGVyYWJsZTxUU291cmNlPltdKTogSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBDYXRjaEl0ZXJhYmxlPFRTb3VyY2U+KFtzb3VyY2UsIC4uLmFyZ3NdKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VxdWVuY2UgYnkgY29uY2F0ZW5hdGluZyBzb3VyY2Ugc2VxdWVuY2VzIHVudGlsIGEgc291cmNlIHNlcXVlbmNlIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuXG4gKiBAcGFyYW0gey4uLkl0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2UgU2VxdWVuY2UgdGhhdCBjb250aW51ZXMgdG8gY29uY2F0ZW5hdGUgc291cmNlIHNlcXVlbmNlcyB3aGlsZSBlcnJvcnMgb2NjdXIuXG4gKiBAcmV0dXJuIHtJdGVyYWJsZTxUU291cmNlPn0gU2VxdWVuY2UgdGhhdCBjb250aW51ZXMgdG8gY29uY2F0ZW5hdGUgc291cmNlIHNlcXVlbmNlcyB3aGlsZSBlcnJvcnMgb2NjdXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hTdGF0aWM8VFNvdXJjZT4oLi4uc291cmNlOiBJdGVyYWJsZTxUU291cmNlPltdKTogSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBDYXRjaEl0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSk7XG59XG4iXX0=
