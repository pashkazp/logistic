Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var asynciterable_1 = require("../asynciterable");
var toarray_1 = require("./toarray");
var sorter_1 = require("../internal/sorter");
var OrderedAsyncIterableBaseX = (function (_super) {
    tslib_1.__extends(OrderedAsyncIterableBaseX, _super);
    function OrderedAsyncIterableBaseX(source) {
        var _this = _super.call(this) || this;
        _this._source = source;
        return _this;
    }
    OrderedAsyncIterableBaseX.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var array, len, indices, i, len_1, indices_1, indices_1_1, index, e_1_1, e_1, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, tslib_1.__await(toarray_1.toArray(this._source))];
                    case 1:
                        array = _b.sent();
                        len = array.length;
                        indices = new Array(len);
                        for (i = 0, len_1 = array.length; i < len_1; i++) {
                            indices[i] = i;
                        }
                        indices.sort(this._getSorter(array));
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 7, 8, 9]);
                        indices_1 = tslib_1.__values(indices), indices_1_1 = indices_1.next();
                        _b.label = 3;
                    case 3:
                        if (!!indices_1_1.done) return [3 /*break*/, 6];
                        index = indices_1_1.value;
                        return [4 /*yield*/, array[index]];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        indices_1_1 = indices_1.next();
                        return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (indices_1_1 && !indices_1_1.done && (_a = indices_1.return)) _a.call(indices_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    OrderedAsyncIterableBaseX.prototype.thenBy = function (keySelector, comparer) {
        if (comparer === void 0) { comparer = sorter_1.sorter; }
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedAsyncIterableX(this._source, keySelector, comparer, false, this);
    };
    OrderedAsyncIterableBaseX.prototype.thenByDescending = function (keySelector, comparer) {
        if (comparer === void 0) { comparer = sorter_1.sorter; }
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedAsyncIterableX(this._source, keySelector, comparer, true, this);
    };
    return OrderedAsyncIterableBaseX;
}(asynciterable_1.AsyncIterableX));
exports.OrderedAsyncIterableBaseX = OrderedAsyncIterableBaseX;
var OrderedAsyncIterableX = (function (_super) {
    tslib_1.__extends(OrderedAsyncIterableX, _super);
    function OrderedAsyncIterableX(source, keySelector, comparer, descending, parent) {
        var _this = _super.call(this, source) || this;
        _this._keySelector = keySelector;
        _this._comparer = comparer;
        _this._descending = descending;
        _this._parent = parent;
        return _this;
    }
    OrderedAsyncIterableX.prototype._getSorter = function (elements, next) {
        var keys = elements.map(this._keySelector);
        var comparer = this._comparer;
        var parent = this._parent;
        var descending = this._descending;
        var sorter = function (x, y) {
            var result = comparer(keys[x], keys[y]);
            if (result === 0) {
                return next ? next(x, y) : x - y;
            }
            return descending ? -result : result;
        };
        return parent ? parent._getSorter(elements, sorter) : sorter;
    };
    return OrderedAsyncIterableX;
}(OrderedAsyncIterableBaseX));
exports.OrderedAsyncIterableX = OrderedAsyncIterableX;
function orderBy(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source, keySelector, comparer, false);
}
exports.orderBy = orderBy;
function orderByDescending(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source, keySelector, comparer, true);
}
exports.orderByDescending = orderByDescending;
function thenBy(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source._source, keySelector, comparer, false, source);
}
exports.thenBy = thenBy;
function thenByDescending(source, keySelector, comparer) {
    if (comparer === void 0) { comparer = sorter_1.sorter; }
    return new OrderedAsyncIterableX(source._source, keySelector, comparer, true, source);
}
exports.thenByDescending = thenByDescending;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvb3JkZXJieS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGtEQUFrRDtBQUNsRCxxQ0FBb0M7QUFDcEMsNkNBQTZEO0FBRTdEO0lBQWlFLHFEQUF1QjtJQUd0RixtQ0FBWSxNQUE4QjtRQUExQyxZQUNFLGlCQUFPLFNBRVI7UUFEQyxLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7SUFDeEIsQ0FBQztJQUVNLG9DQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBN0I7Ozs7OzRCQUNnQixxQ0FBTSxpQkFBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBQTs7d0JBQW5DLEtBQUssR0FBRyxTQUEyQjt3QkFDbkMsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7d0JBQ25CLE9BQU8sR0FBRyxJQUFJLEtBQUssQ0FBUyxHQUFHLENBQUMsQ0FBQzt3QkFDdkMsR0FBRyxDQUFDLENBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFNLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEtBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDOzRCQUNqRCxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUNqQixDQUFDO3dCQUVELE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzs7O3dCQUNqQixZQUFBLGlCQUFBLE9BQU8sQ0FBQTs7Ozt3QkFBaEIsS0FBSzt3QkFDZCxxQkFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUE7O3dCQUFsQixTQUFrQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUV0QjtJQUVELDBDQUFNLEdBQU4sVUFDSSxXQUFvQyxFQUNwQyxRQUEwRDtRQUExRCx5QkFBQSxFQUFBLFdBQTZDLGVBQWE7UUFDNUQscURBQXFEO1FBQ3JELE1BQU0sQ0FBQyxJQUFJLHFCQUFxQixDQUFnQixJQUFJLENBQUMsT0FB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QUUsTUFBTSxDQUFDLENBQUM7QUFDeEcsQ0FBQztBQUxELHdCQUtDO0FBRUQsMEJBQ00sTUFBMEMsRUFDMUMsV0FBb0MsRUFDcEMsUUFBMEQ7SUFBMUQseUJBQUEsRUFBQSxXQUE2QyxlQUFhO0lBQzlELE1BQU0sQ0FBQyxJQUFJLHFCQUFxQixDQUFnQixNQUFNLENBQUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZHLENBQUM7QUFMRCw0Q0FLQyIsImZpbGUiOiJhc3luY2l0ZXJhYmxlL29yZGVyYnkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuaW1wb3J0IHsgdG9BcnJheSB9IGZyb20gJy4vdG9hcnJheSc7XG5pbXBvcnQgeyBzb3J0ZXIgYXMgZGVmYXVsdFNvcnRlciB9IGZyb20gJy4uL2ludGVybmFsL3NvcnRlcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+IGV4dGVuZHMgQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBfc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+O1xuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCB0b0FycmF5KHRoaXMuX3NvdXJjZSk7XG4gICAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuXG4gICAgaW5kaWNlcy5zb3J0KHRoaXMuX2dldFNvcnRlcihhcnJheSkpO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kaWNlcykge1xuICAgICAgeWllbGQgYXJyYXlbaW5kZXhdO1xuICAgIH1cbiAgfVxuXG4gIHRoZW5CeTxUS2V5PihcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+IHtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVzZS1iZWZvcmUtZGVjbGFyZSAqL1xuICAgIHJldHVybiBuZXcgT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+KHRoaXMuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCBmYWxzZSwgdGhpcyk7XG4gIH1cblxuICB0aGVuQnlEZXNjZW5kaW5nPFRLZXk+KFxuICAgICAga2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5LFxuICAgICAgY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyID0gZGVmYXVsdFNvcnRlcik6IE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4ge1xuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4odGhpcy5fc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIHRydWUsIHRoaXMpO1xuICB9XG5cbiAgYWJzdHJhY3QgX2dldFNvcnRlcihcbiAgICBlbGVtZW50czogVFNvdXJjZVtdLFxuICAgIG5leHQ/OiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IG51bWJlcik6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IGV4dGVuZHMgT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPiB7XG4gIHByaXZhdGUgX2tleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleTtcbiAgcHJpdmF0ZSBfY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyO1xuICBwcml2YXRlIF9kZXNjZW5kaW5nOiBib29sZWFuO1xuICBwcml2YXRlIF9wYXJlbnQ/OiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgICAga2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5LFxuICAgICAgY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyLFxuICAgICAgZGVzY2VuZGluZzogYm9vbGVhbixcbiAgICAgIHBhcmVudD86IE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4pIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIHRoaXMuX2tleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgdGhpcy5fY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgICB0aGlzLl9kZXNjZW5kaW5nID0gZGVzY2VuZGluZztcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cblxuICBfZ2V0U29ydGVyKFxuICAgICAgZWxlbWVudHM6IFRTb3VyY2VbXSxcbiAgICAgIG5leHQ/OiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IG51bWJlcik6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyIHtcbiAgICBjb25zdCBrZXlzID0gZWxlbWVudHMubWFwKHRoaXMuX2tleVNlbGVjdG9yKTtcbiAgICBjb25zdCBjb21wYXJlciA9IHRoaXMuX2NvbXBhcmVyO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICBjb25zdCBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZztcbiAgICBjb25zdCBzb3J0ZXIgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZXIoa2V5c1t4XSwga2V5c1t5XSk7XG4gICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXh0ID8gbmV4dCh4LCB5KSA6IHggLSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzY2VuZGluZyA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuX2dldFNvcnRlcihlbGVtZW50cywgc29ydGVyKSA6IHNvcnRlcjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJCeTxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJCeURlc2NlbmRpbmc8VEtleSwgVFNvdXJjZT4oXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhlbkJ5PFRLZXksIFRTb3VyY2U+KFxuICAgICAgc291cmNlOiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+LFxuICAgICAga2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5LFxuICAgICAgY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyID0gZGVmYXVsdFNvcnRlcik6IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPiB7XG4gIHJldHVybiBuZXcgT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+KHNvdXJjZS5fc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIGZhbHNlLCBzb3VyY2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhlbkJ5RGVzY2VuZGluZzxUS2V5LCBUU291cmNlPihcbiAgICAgIHNvdXJjZTogT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlciA9IGRlZmF1bHRTb3J0ZXIpOiBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPihzb3VyY2UuX3NvdXJjZSwga2V5U2VsZWN0b3IsIGNvbXBhcmVyLCB0cnVlLCBzb3VyY2UpO1xufVxuIl19
