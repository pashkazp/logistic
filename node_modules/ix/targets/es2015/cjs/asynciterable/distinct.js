Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const asynciterable_1 = require("../asynciterable");
const identity_1 = require("../internal/identity");
const arrayindexof_1 = require("../internal/arrayindexof");
const comparer_1 = require("../internal/comparer");
class DistinctAsyncIterable extends asynciterable_1.AsyncIterableX {
    constructor(source, keySelector, comparer) {
        super();
        this._source = source;
        this._keySelector = keySelector;
        this._comparer = comparer;
    }
    [Symbol.asyncIterator]() {
        return tslib_1.__asyncGenerator(this, arguments, function* _a() {
            let set = [];
            try {
                for (var _a = tslib_1.__asyncValues((this._source)), _b; _b = yield tslib_1.__await(_a.next()), !_b.done;) {
                    let item = yield tslib_1.__await(_b.value);
                    let key = yield tslib_1.__await(this._keySelector(item));
                    if ((yield tslib_1.__await(arrayindexof_1.arrayIndexOfAsync(set, key, this._comparer))) === -1) {
                        set.push(key);
                        yield item;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) yield tslib_1.__await(_c.call(_a));
                }
                finally { if (e_1) throw e_1.error; }
            }
            var e_1, _c;
        });
    }
}
function distinct(source, keySelector = identity_1.identityAsync, comparer = comparer_1.comparerAsync) {
    return new DistinctAsyncIterable(source, keySelector, comparer);
}
exports.distinct = distinct;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvZGlzdGluY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxvREFBa0Q7QUFDbEQsbURBQXFEO0FBQ3JELDJEQUE2RDtBQUM3RCxtREFBcUQ7QUFFckQsMkJBQTJDLFNBQVEsOEJBQXVCO0lBS3hFLFlBQ0ksTUFBOEIsRUFDOUIsV0FBcUQsRUFDckQsUUFBMEQ7UUFDNUQsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztJQUM1QixDQUFDO0lBRU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDOztZQUMzQixJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7O2dCQUViLEdBQUcsQ0FBQyxDQUFtQixJQUFBLEtBQUEsc0JBQXdCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBLElBQUE7b0JBQWxELElBQUksSUFBSSxrQ0FBQSxDQUFBO29CQUNqQixJQUFJLEdBQUcsR0FBRyxzQkFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFBLENBQUM7b0JBQ3hDLEVBQUUsQ0FBQyxDQUFDLENBQUEsc0JBQU0sZ0NBQWlCLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUEsTUFBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQzdELEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ2QsTUFBTSxJQUFJLENBQUM7b0JBQ2IsQ0FBQztpQkFDRjs7Ozs7Ozs7OztRQUNILENBQUM7S0FBQTtDQUNGO0FBRUQsa0JBQ0ksTUFBOEIsRUFDOUIsY0FBd0Qsd0JBQWEsRUFDckUsV0FBNkQsd0JBQWE7SUFDNUUsTUFBTSxDQUFDLElBQUkscUJBQXFCLENBQWdCLE1BQU0sRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDakYsQ0FBQztBQUxELDRCQUtDIiwiZmlsZSI6ImFzeW5jaXRlcmFibGUvZGlzdGluY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuaW1wb3J0IHsgaWRlbnRpdHlBc3luYyB9IGZyb20gJy4uL2ludGVybmFsL2lkZW50aXR5JztcbmltcG9ydCB7IGFycmF5SW5kZXhPZkFzeW5jIH0gZnJvbSAnLi4vaW50ZXJuYWwvYXJyYXlpbmRleG9mJztcbmltcG9ydCB7IGNvbXBhcmVyQXN5bmMgfSBmcm9tICcuLi9pbnRlcm5hbC9jb21wYXJlcic7XG5cbmNsYXNzIERpc3RpbmN0QXN5bmNJdGVyYWJsZTxUU291cmNlLCBUS2V5PiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBJdGVyYWJsZTxUU291cmNlIHwgUHJvbWlzZUxpa2UgPFRTb3VyY2U+PiB8IEFzeW5jSXRlcmFibGUgPFRTb3VyY2U+O1xuICBwcml2YXRlIF9rZXlTZWxlY3RvcjogKHZhbHVlOiBUU291cmNlKSA9PiBUS2V5IHwgUHJvbWlzZTxUS2V5PjtcbiAgcHJpdmF0ZSBfY29tcGFyZXI6ICh4OiBUS2V5LCB5OiBUS2V5KSA9PiBib29sZWFuIHwgUHJvbWlzZTxib29sZWFuPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGtleVNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+LFxuICAgICAgY29tcGFyZXI6ICh4OiBUS2V5LCB5OiBUS2V5KSA9PiBib29sZWFuIHwgUHJvbWlzZTxib29sZWFuPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2tleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgdGhpcy5fY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBzZXQgPSBbXTtcblxuICAgIGZvciBhd2FpdCAobGV0IGl0ZW0gb2YgPEFzeW5jSXRlcmFibGU8VFNvdXJjZT4+KHRoaXMuX3NvdXJjZSkpIHtcbiAgICAgIGxldCBrZXkgPSBhd2FpdCB0aGlzLl9rZXlTZWxlY3RvcihpdGVtKTtcbiAgICAgIGlmIChhd2FpdCBhcnJheUluZGV4T2ZBc3luYyhzZXQsIGtleSwgdGhpcy5fY29tcGFyZXIpID09PSAtMSkge1xuICAgICAgICBzZXQucHVzaChrZXkpO1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGluY3Q8VFNvdXJjZSwgVEtleT4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIGtleVNlbGVjdG9yOiAodmFsdWU6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+ID0gaWRlbnRpdHlBc3luYyxcbiAgICBjb21wYXJlcjogKHg6IFRLZXksIHk6IFRLZXkpID0+IGJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+ID0gY29tcGFyZXJBc3luYyk6IEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBEaXN0aW5jdEFzeW5jSXRlcmFibGU8VFNvdXJjZSwgVEtleT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIpO1xufVxuIl19
