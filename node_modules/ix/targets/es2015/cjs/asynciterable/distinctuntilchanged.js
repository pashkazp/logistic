Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const asynciterable_1 = require("../asynciterable");
const identity_1 = require("../internal/identity");
const comparer_1 = require("../internal/comparer");
class DistinctUntilChangedAsyncIterable extends asynciterable_1.AsyncIterableX {
    constructor(source, keySelector, comparer) {
        super();
        this._source = source;
        this._keySelector = keySelector;
        this._comparer = comparer;
    }
    [Symbol.asyncIterator]() {
        return tslib_1.__asyncGenerator(this, arguments, function* _a() {
            let currentKey, hasCurrentKey = false;
            try {
                for (var _a = tslib_1.__asyncValues(this._source), _b; _b = yield tslib_1.__await(_a.next()), !_b.done;) {
                    let item = yield tslib_1.__await(_b.value);
                    let key = yield tslib_1.__await(this._keySelector(item));
                    let comparerEquals = false;
                    if (hasCurrentKey) {
                        comparerEquals = yield tslib_1.__await(this._comparer(currentKey, key));
                    }
                    if (!hasCurrentKey || !comparerEquals) {
                        hasCurrentKey = true;
                        currentKey = key;
                        yield item;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) yield tslib_1.__await(_c.call(_a));
                }
                finally { if (e_1) throw e_1.error; }
            }
            var e_1, _c;
        });
    }
}
function distinctUntilChanged(source, keySelector = identity_1.identityAsync, comparer = comparer_1.comparerAsync) {
    return new DistinctUntilChangedAsyncIterable(source, keySelector, comparer);
}
exports.distinctUntilChanged = distinctUntilChanged;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvZGlzdGluY3R1bnRpbGNoYW5nZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxvREFBa0Q7QUFDbEQsbURBQXFEO0FBQ3JELG1EQUFxRDtBQUVyRCx1Q0FBdUQsU0FBUSw4QkFBdUI7SUFLcEYsWUFDSSxNQUE4QixFQUM5QixXQUFxRCxFQUNyRCxRQUFtRTtRQUNyRSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQzVCLENBQUM7SUFFTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7O1lBQzNCLElBQUksVUFBNEIsRUFBRSxhQUFhLEdBQUcsS0FBSyxDQUFDOztnQkFDeEQsR0FBRyxDQUFDLENBQW1CLElBQUEsS0FBQSxzQkFBQSxJQUFJLENBQUMsT0FBTyxDQUFBLElBQUE7b0JBQXhCLElBQUksSUFBSSxrQ0FBQSxDQUFBO29CQUNqQixJQUFJLEdBQUcsR0FBRyxzQkFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFBLENBQUM7b0JBQ3hDLElBQUksY0FBYyxHQUFHLEtBQUssQ0FBQztvQkFDM0IsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzt3QkFBQyxjQUFjLEdBQUcsc0JBQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFXLEVBQUUsR0FBRyxDQUFDLENBQUEsQ0FBQztvQkFBQyxDQUFDO29CQUMvRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7d0JBQ3RDLGFBQWEsR0FBRyxJQUFJLENBQUM7d0JBQ3JCLFVBQVUsR0FBRyxHQUFHLENBQUM7d0JBQ2pCLE1BQU0sSUFBSSxDQUFDO29CQUNiLENBQUM7aUJBQ0Y7Ozs7Ozs7Ozs7UUFDSCxDQUFDO0tBQUE7Q0FDRjtBQUVELDhCQUNJLE1BQThCLEVBQzlCLGNBQXdELHdCQUFhLEVBQ3JFLFdBQXNFLHdCQUFhO0lBQ3JGLE1BQU0sQ0FBQyxJQUFJLGlDQUFpQyxDQUFnQixNQUFNLEVBQUUsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzdGLENBQUM7QUFMRCxvREFLQyIsImZpbGUiOiJhc3luY2l0ZXJhYmxlL2Rpc3RpbmN0dW50aWxjaGFuZ2VkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXN5bmNJdGVyYWJsZVggfSBmcm9tICcuLi9hc3luY2l0ZXJhYmxlJztcbmltcG9ydCB7IGlkZW50aXR5QXN5bmMgfSBmcm9tICcuLi9pbnRlcm5hbC9pZGVudGl0eSc7XG5pbXBvcnQgeyBjb21wYXJlckFzeW5jIH0gZnJvbSAnLi4vaW50ZXJuYWwvY29tcGFyZXInO1xuXG5jbGFzcyBEaXN0aW5jdFVudGlsQ2hhbmdlZEFzeW5jSXRlcmFibGU8VFNvdXJjZSwgVEtleT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG4gIHByaXZhdGUgX3NvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPjtcbiAgcHJpdmF0ZSBfa2V5U2VsZWN0b3I6ICh2YWx1ZTogVFNvdXJjZSkgPT4gVEtleSB8IFByb21pc2U8VEtleT47XG4gIHByaXZhdGUgX2NvbXBhcmVyOiAoeDogVEtleSwgeTogVEtleSkgPT4gYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKHZhbHVlOiBUU291cmNlKSA9PiBUS2V5IHwgUHJvbWlzZTxUS2V5PixcbiAgICAgIGNvbXBhcmVyOiAoZmlyc3Q6IFRLZXksIHNlY29uZDogVEtleSkgPT4gYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgIHRoaXMuX2NvbXBhcmVyID0gY29tcGFyZXI7XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgY3VycmVudEtleTogVEtleSB8IHVuZGVmaW5lZCwgaGFzQ3VycmVudEtleSA9IGZhbHNlO1xuICAgIGZvciBhd2FpdCAobGV0IGl0ZW0gb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICBsZXQga2V5ID0gYXdhaXQgdGhpcy5fa2V5U2VsZWN0b3IoaXRlbSk7XG4gICAgICBsZXQgY29tcGFyZXJFcXVhbHMgPSBmYWxzZTtcbiAgICAgIGlmIChoYXNDdXJyZW50S2V5KSB7IGNvbXBhcmVyRXF1YWxzID0gYXdhaXQgdGhpcy5fY29tcGFyZXIoY3VycmVudEtleSEsIGtleSk7IH1cbiAgICAgIGlmICghaGFzQ3VycmVudEtleSB8fCAhY29tcGFyZXJFcXVhbHMpIHtcbiAgICAgICAgaGFzQ3VycmVudEtleSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXk7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZDxUU291cmNlLCBUS2V5PihcbiAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAga2V5U2VsZWN0b3I6ICh2YWx1ZTogVFNvdXJjZSkgPT4gVEtleSB8IFByb21pc2U8VEtleT4gPSBpZGVudGl0eUFzeW5jLFxuICAgIGNvbXBhcmVyOiAoZmlyc3Q6IFRLZXksIHNlY29uZDogVEtleSkgPT4gYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4gPSBjb21wYXJlckFzeW5jKTogIEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZEFzeW5jSXRlcmFibGU8VFNvdXJjZSwgVEtleT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIpO1xufVxuIl19
