Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const asynciterable_1 = require("../asynciterable");
/**
 * @ignore
 */
function defaultCompareAsync(key, minValue) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return key > minValue ? 1 : key < minValue ? -1 : 0;
    });
}
exports.defaultCompareAsync = defaultCompareAsync;
/**
 * @ignore
 */
class ExtremaByAsyncIterator extends asynciterable_1.AsyncIterableX {
    constructor(source, keyFn, cmp) {
        super();
        this._source = source;
        this._keyFn = keyFn;
        this._cmp = cmp;
    }
    [Symbol.asyncIterator]() {
        return tslib_1.__asyncGenerator(this, arguments, function* _a() {
            let result = [], done, next;
            const it = this._source[Symbol.asyncIterator]();
            done = (next = yield tslib_1.__await(it.next())).done;
            if (done) {
                throw new Error('Sequence contains no elements');
            }
            let current = next.value;
            let resKey = yield tslib_1.__await(this._keyFn(current));
            done = (next = yield tslib_1.__await(it.next())).done;
            while (!done) {
                let curr = next.value;
                let key = yield tslib_1.__await(this._keyFn(curr));
                const c = yield tslib_1.__await(this._cmp(key, resKey));
                if (c === 0) {
                    result.push(curr);
                }
                else if (c > 0) {
                    result = [curr];
                    resKey = key;
                }
                done = (next = yield tslib_1.__await(it.next())).done;
            }
            yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(result)));
        });
    }
}
/**
 * @ignore
 */
function extremaBy(source, keyFn, cmp) {
    return new ExtremaByAsyncIterator(source, keyFn, cmp);
}
exports.extremaBy = extremaBy;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvX2V4dHJlbWFieS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG9EQUFrRDtBQUVsRDs7R0FFRztBQUNILDZCQUE2QyxHQUFNLEVBQUUsUUFBVzs7UUFDOUQsTUFBTSxDQUFDLEdBQUcsR0FBRyxRQUFRLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FBQTtBQUZELGtEQUVDO0FBRUQ7O0dBRUc7QUFDSCw0QkFBNEMsU0FBUSw4QkFBdUI7SUFLekUsWUFDSSxNQUE4QixFQUM5QixLQUEyQyxFQUMzQyxHQUFtRDtRQUNyRCxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0lBQ2xCLENBQUM7SUFFTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7O1lBQzNCLElBQUksTUFBTSxHQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO1lBQ3ZDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUM7WUFDaEQsSUFBSSxHQUFHLENBQUMsSUFBSSxHQUFHLHNCQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQSxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3JDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1lBQ25ELENBQUM7WUFFRCxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3pCLElBQUksTUFBTSxHQUFHLHNCQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUEsQ0FBQztZQUN4QyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEdBQUcsc0JBQU0sRUFBRSxDQUFDLElBQUksRUFBRSxDQUFBLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDckMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNiLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQ3RCLElBQUksR0FBRyxHQUFHLHNCQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUEsQ0FBQztnQkFDbEMsTUFBTSxDQUFDLEdBQUcsc0JBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUEsQ0FBQztnQkFDdkMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ1osTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDcEIsQ0FBQztnQkFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2pCLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUNoQixNQUFNLEdBQUcsR0FBRyxDQUFDO2dCQUNmLENBQUM7Z0JBQ0QsSUFBSSxHQUFHLENBQUMsSUFBSSxHQUFHLHNCQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQSxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3ZDLENBQUM7WUFFRCxzQkFBQSxPQUFPLHlCQUFBLHNCQUFBLE1BQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQztRQUNoQixDQUFDO0tBQUE7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsbUJBQ0ksTUFBOEIsRUFDOUIsS0FBMkMsRUFDM0MsR0FBbUQ7SUFDckQsTUFBTSxDQUFDLElBQUksc0JBQXNCLENBQWdCLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUxELDhCQUtDIiwiZmlsZSI6ImFzeW5jaXRlcmFibGUvX2V4dHJlbWFieS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmVBc3luYzxUPihrZXk6IFQsIG1pblZhbHVlOiBUKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgcmV0dXJuIGtleSA+IG1pblZhbHVlID8gMSA6IGtleSA8IG1pblZhbHVlID8gLTEgOiAwO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgRXh0cmVtYUJ5QXN5bmNJdGVyYXRvcjxUU291cmNlLCBUS2V5PiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcHJpdmF0ZSBfc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9rZXlGbjogKHg6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+O1xuICBwcml2YXRlIF9jbXA6ICh4OiBUS2V5LCB5OiBUS2V5KSA9PiBudW1iZXIgfCBQcm9taXNlPG51bWJlcj47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlGbjogKHg6IFRTb3VyY2UpID0+IFRLZXkgfCBQcm9taXNlPFRLZXk+LFxuICAgICAgY21wOiAoeDogVEtleSwgeTogVEtleSkgPT4gbnVtYmVyIHwgUHJvbWlzZTxudW1iZXI+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fa2V5Rm4gPSBrZXlGbjtcbiAgICB0aGlzLl9jbXAgPSBjbXA7XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgcmVzdWx0OiBUU291cmNlW10gPSBbXSwgZG9uZSwgbmV4dDtcbiAgICBjb25zdCBpdCA9IHRoaXMuX3NvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBkb25lID0gKG5leHQgPSBhd2FpdCBpdC5uZXh0KCkpLmRvbmU7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VxdWVuY2UgY29udGFpbnMgbm8gZWxlbWVudHMnKTtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudCA9IG5leHQudmFsdWU7XG4gICAgbGV0IHJlc0tleSA9IGF3YWl0IHRoaXMuX2tleUZuKGN1cnJlbnQpO1xuICAgIGRvbmUgPSAobmV4dCA9IGF3YWl0IGl0Lm5leHQoKSkuZG9uZTtcbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgIGxldCBjdXJyID0gbmV4dC52YWx1ZTtcbiAgICAgIGxldCBrZXkgPSBhd2FpdCB0aGlzLl9rZXlGbihjdXJyKTtcbiAgICAgIGNvbnN0IGMgPSBhd2FpdCB0aGlzLl9jbXAoa2V5LCByZXNLZXkpO1xuICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3Vycik7XG4gICAgICB9IGVsc2UgaWYgKGMgPiAwKSB7XG4gICAgICAgIHJlc3VsdCA9IFtjdXJyXTtcbiAgICAgICAgcmVzS2V5ID0ga2V5O1xuICAgICAgfVxuICAgICAgZG9uZSA9IChuZXh0ID0gYXdhaXQgaXQubmV4dCgpKS5kb25lO1xuICAgIH1cblxuICAgIHlpZWxkKiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyZW1hQnk8VFNvdXJjZSwgVEtleT4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIGtleUZuOiAoeDogVFNvdXJjZSkgPT4gVEtleSB8IFByb21pc2U8VEtleT4sXG4gICAgY21wOiAoeDogVEtleSwgeTogVEtleSkgPT4gbnVtYmVyIHwgUHJvbWlzZTxudW1iZXI+KTogQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IEV4dHJlbWFCeUFzeW5jSXRlcmF0b3I8VFNvdXJjZSwgVEtleT4oc291cmNlLCBrZXlGbiwgY21wKTtcbn1cbiJdfQ==
