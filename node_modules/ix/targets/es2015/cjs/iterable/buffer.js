Object.defineProperty(exports, "__esModule", { value: true });
const iterable_1 = require("../iterable");
class BufferIterable extends iterable_1.IterableX {
    constructor(source, count, skip) {
        super();
        this._source = source;
        this._count = count;
        this._skip = skip;
    }
    *[Symbol.iterator]() {
        let buffers = [], i = 0;
        for (let item of this._source) {
            if (i % this._skip === 0) {
                buffers.push([]);
            }
            for (let buffer of buffers) {
                buffer.push(item);
            }
            if (buffers.length > 0 && buffers[0].length === this._count) {
                yield buffers.shift();
            }
            i++;
        }
        while (buffers.length > 0) {
            yield buffers.shift();
        }
    }
}
/**
 * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
 * @example <caption>Creates a sequence of buffers with and without skip</caption>
 * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
 *
 * // Without skip
 * const result = buffer(source, 5);
 * const result = Ix.Iterable.from(source).buffer(5);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2, 3, 4]
 * // => [5, 6, 7, 8, 9]
 *
 * // With skip
 * const result = buffer(source, 3, 4);
 * const result = Ix.Iterable.from(source).buffer(3, 4);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2]
 * // => [4, 5, 6]
 * // => [8, 9]
 * @param {Iterabel<TSource>} source Source sequence
 * @param {number} count Number of elements for allocated buffers.
 * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults
 * to the count.
 * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements
 */
function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferIterable(source, count, skip);
}
exports.buffer = buffer;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsMENBQXdDO0FBRXhDLG9CQUE4QixTQUFRLG9CQUFvQjtJQUt4RCxZQUFZLE1BQXlCLEVBQUUsS0FBYSxFQUFFLElBQVk7UUFDaEUsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNwQixDQUFDO0lBRUQsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDaEIsSUFBSSxPQUFPLEdBQWdCLEVBQUUsRUFBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzlCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbkIsQ0FBQztZQUVELEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQzNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEIsQ0FBQztZQUVELEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQzVELE1BQU0sT0FBTyxDQUFDLEtBQUssRUFBRyxDQUFDO1lBQ3pCLENBQUM7WUFFRCxDQUFDLEVBQUUsQ0FBQztRQUNOLENBQUM7UUFFRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDMUIsTUFBTSxPQUFPLENBQUMsS0FBSyxFQUFHLENBQUM7UUFDekIsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBQ0gsZ0JBQ0ksTUFBeUIsRUFDekIsS0FBYSxFQUNiLElBQWE7SUFDZixFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUFDLElBQUksR0FBRyxLQUFLLENBQUM7SUFBQyxDQUFDO0lBQ3BDLE1BQU0sQ0FBQyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2hELENBQUM7QUFORCx3QkFNQyIsImZpbGUiOiJpdGVyYWJsZS9idWZmZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5cbmNsYXNzIEJ1ZmZlckl0ZXJhYmxlPFRTb3VyY2U+IGV4dGVuZHMgSXRlcmFibGVYPFRTb3VyY2VbXT4ge1xuICBwcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9jb3VudDogbnVtYmVyO1xuICBwcml2YXRlIF9za2lwOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Ioc291cmNlOiBJdGVyYWJsZTxUU291cmNlPiwgY291bnQ6IG51bWJlciwgc2tpcDogbnVtYmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICB0aGlzLl9za2lwID0gc2tpcDtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgYnVmZmVyczogVFNvdXJjZVtdW10gPSBbXSwgIGkgPSAwO1xuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICBpZiAoaSAlIHRoaXMuX3NraXAgPT09IDApIHtcbiAgICAgICAgYnVmZmVycy5wdXNoKFtdKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+IDAgJiYgYnVmZmVyc1swXS5sZW5ndGggPT09IHRoaXMuX2NvdW50KSB7XG4gICAgICAgIHlpZWxkIGJ1ZmZlcnMuc2hpZnQoKSE7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB5aWVsZCBidWZmZXJzLnNoaWZ0KCkhO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNlcXVlbmNlIG9mIGJ1ZmZlcnMgb3ZlciB0aGUgc291cmNlIHNlcXVlbmNlLCB3aXRoIHNwZWNpZmllZCBsZW5ndGggYW5kIHBvc3NpYmxlIG92ZXJsYXAuXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGVzIGEgc2VxdWVuY2Ugb2YgYnVmZmVycyB3aXRoIGFuZCB3aXRob3V0IHNraXA8L2NhcHRpb24+XG4gKiBjb25zdCBzb3VyY2UgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMF07XG4gKlxuICogLy8gV2l0aG91dCBza2lwXG4gKiBjb25zdCByZXN1bHQgPSBidWZmZXIoc291cmNlLCA1KTtcbiAqIGNvbnN0IHJlc3VsdCA9IEl4Lkl0ZXJhYmxlLmZyb20oc291cmNlKS5idWZmZXIoNSk7XG4gKiBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKiAvLyA9PiBbMCwgMSwgMiwgMywgNF1cbiAqIC8vID0+IFs1LCA2LCA3LCA4LCA5XVxuICpcbiAqIC8vIFdpdGggc2tpcFxuICogY29uc3QgcmVzdWx0ID0gYnVmZmVyKHNvdXJjZSwgMywgNCk7XG4gKiBjb25zdCByZXN1bHQgPSBJeC5JdGVyYWJsZS5mcm9tKHNvdXJjZSkuYnVmZmVyKDMsIDQpO1xuICogZm9yIChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfVxuICogLy8gPT4gWzAsIDEsIDJdXG4gKiAvLyA9PiBbNCwgNSwgNl1cbiAqIC8vID0+IFs4LCA5XVxuICogQHBhcmFtIHtJdGVyYWJlbDxUU291cmNlPn0gc291cmNlIFNvdXJjZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IE51bWJlciBvZiBlbGVtZW50cyBmb3IgYWxsb2NhdGVkIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NraXBdIE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGNvbnNlY3V0aXZlIGJ1ZmZlcnMuIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzXG4gKiB0byB0aGUgY291bnQuXG4gKiBAcmV0dXJuIHtJdGVyYWJsZVg8VFNvdXJjZT5bXX0gU2VxdWVuY2Ugb2YgYnVmZmVycyBjb250YWluaW5nIHNvdXJjZSBzZXF1ZW5jZSBlbGVtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyPFRTb3VyY2U+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgY291bnQ6IG51bWJlcixcbiAgICBza2lwPzogbnVtYmVyKTogSXRlcmFibGVYPFRTb3VyY2VbXT4ge1xuICBpZiAoc2tpcCA9PSBudWxsKSB7IHNraXAgPSBjb3VudDsgfVxuIHJldHVybiBuZXcgQnVmZmVySXRlcmFibGUoc291cmNlLCBjb3VudCwgc2tpcCk7XG59XG4iXX0=
