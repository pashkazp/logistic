goog.module('targets.es2015.cls.iterable.buffer'); exports = {}; var module = {id: 'targets/es2015/cls/iterable/buffer.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.es2015.cls.iterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
/**
 * @template TSource
 */
class BufferIterable extends iterable_1.IterableX {
    /**
     * @param {!Iterable<TSource>} source
     * @param {number} count
     * @param {number} skip
     */
    constructor(source, count, skip) {
        super();
        this._source = source;
        this._count = count;
        this._skip = skip;
    }
    /**
     * @return {!IterableIterator<!Array<TSource>>}
     */
    *[Symbol.iterator]() {
        let /** @type {!Array<!Array<TSource>>} */ buffers = [], /** @type {number} */ i = 0;
        for (let /** @type {TSource} */ item of this._source) {
            if (i % this._skip === 0) {
                buffers.push([]);
            }
            for (let /** @type {!Array<TSource>} */ buffer of buffers) {
                buffer.push(item);
            }
            if (buffers.length > 0 && buffers[0].length === this._count) {
                yield ((buffers.shift()));
            }
            i++;
        }
        while (buffers.length > 0) {
            yield ((buffers.shift()));
        }
    }
}
function BufferIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<TSource>} */
    BufferIterable.prototype._source;
    /** @type {number} */
    BufferIterable.prototype._count;
    /** @type {number} */
    BufferIterable.prototype._skip;
}
/**
 * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
 * \@example <caption>Creates a sequence of buffers with and without skip</caption>
 * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
 *
 * // Without skip
 * const result = buffer(source, 5);
 * const result = Ix.Iterable.from(source).buffer(5);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2, 3, 4]
 * // => [5, 6, 7, 8, 9]
 *
 * // With skip
 * const result = buffer(source, 3, 4);
 * const result = Ix.Iterable.from(source).buffer(3, 4);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2]
 * // => [4, 5, 6]
 * // => [8, 9]
 * to the count.
 * @template TSource
 * @param {!Iterable<TSource>} source
 * @param {number} count
 * @param {number=} skip
 * @return {!tsickle_forward_declare_1.IterableX<!Array<TSource>>}
 */
function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferIterable(source, count, skip);
}
exports.buffer = buffer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9idWZmZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILDBDQUxrQjtBQU1sQixNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsc0NBQXNDLENBQUMsQ0FBQztBQUM5Rjs7R0FFRztBQVBILG9CQUE2QixTQUFRLG9CQUFxQjtJQVkxRDs7OztPQUlHO0lBWEQsWUFBWSxNQUF5QixFQUFDLEtBQWMsRUFBQyxJQUFhO1FBYWhFLEtBWkssRUFBRSxDQUFDO1FBYVIsSUFaSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7UUFhdEIsSUFaSSxDQUFDLE1BQU0sR0FBRSxLQUFNLENBQUM7UUFhcEIsSUFaSSxDQUFDLEtBQUssR0FBRSxJQUFLLENBQUM7SUFhcEIsQ0FBQztJQUNIOztPQUVHO0lBYkQsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFlaEIsSUFBSSxzQ0FkRCxDQUFBLE9BQVEsR0FBZSxFQUFHLEVBQUEscUJBQUMsQ0FBQSxDQUFHLEdBQUUsQ0FBRSxDQUFDO1FBZXRDLEdBQUcsQ0FBQyxDQWRDLElBQUEsc0JBQUcsQ0FBQSxJQUFLLElBQUcsSUFBSyxDQUFDLE9BQU8sQ0FBQyxDQUFBLENBQUU7WUFlOUIsRUFBRSxDQUFDLENBZEMsQ0FBQyxHQUFFLElBQUssQ0FBQyxLQUFLLEtBQUksQ0FBRSxDQUFDLENBQUEsQ0FBRTtnQkFlekIsT0FkTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQWVuQixDQWRDO1lBZ0JELEdBQUcsQ0FBQyxDQWRDLElBQUEsOEJBQUcsQ0FBQSxNQUFPLElBQUcsT0FBUSxDQUFDLENBQUEsQ0FBRTtnQkFlM0IsTUFkTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQWVwQixDQWRDO1lBZ0JELEVBQUUsQ0FBQyxDQWRDLE9BQU8sQ0FBQyxNQUFNLEdBQUUsQ0FBRSxJQUFHLE9BQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUksSUFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFBLENBQUU7Z0JBZTVELE1BQW9DLENBQUMsQ0FkaEMsT0FBUSxDQUFDLEtBQUssRUFBQSxDQUFBLENBQUcsQ0FBQztZQWV6QixDQWRDO1lBZ0JELENBZEMsRUFBRSxDQUFDO1FBZU4sQ0FkQztRQWdCRCxPQWRPLE9BQU8sQ0FBQyxNQUFNLEdBQUUsQ0FBRSxFQUFDLENBQUU7WUFlMUIsTUFBb0MsQ0FBQyxDQWRoQyxPQUFRLENBQUMsS0FBSyxFQUFBLENBQUEsQ0FBRyxDQUFDO1FBZXpCLENBZEM7SUFlSCxDQWRDO0NBQ0g7QUFnQkE7SUFDQSxpQ0FBaUM7SUFDakMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFDakMscUJBQXFCO0lBQ3JCLGNBQWMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO0lBQ2hDLHFCQUFxQjtJQUNyQixjQUFjLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztBQUMvQixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJHO0FBdkJILGdCQXlCSSxNQXhCeUIsRUF5QnpCLEtBeEJhLEVBeUJiLElBeEJhO0lBeUJmLEVBQUUsQ0FBQyxDQXhCQyxJQUFJLElBQUcsSUFBSyxDQUFDLENBQUEsQ0FBRTtRQUFBLElBQUssR0FBRSxLQUFNLENBQUM7SUFBQSxDQUFFO0lBeUJwQyxNQXhCTSxDQUFBLElBQUksY0FBZSxDQUFDLE1BQU0sRUFBQyxLQUFNLEVBQUMsSUFBSyxDQUFDLENBQUM7QUF5QmhELENBeEJDO0FBTkQsd0JBTUMiLCJmaWxlIjoiYnVmZmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaXRlcmFibGVcIik7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmNsYXNzIEJ1ZmZlckl0ZXJhYmxlPFRTb3VyY2U+IGV4dGVuZHMgSXRlcmFibGVYPFRTb3VyY2VbXT4ge1xucHJpdmF0ZSBfc291cmNlOiBJdGVyYWJsZTxUU291cmNlPjtcbnByaXZhdGUgX2NvdW50OiBudW1iZXI7XG5wcml2YXRlIF9za2lwOiBudW1iZXI7XG4vKipcbiAqIEBwYXJhbSB7IUl0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtudW1iZXJ9IHNraXBcbiAqL1xuY29uc3RydWN0b3Ioc291cmNlOiBJdGVyYWJsZTxUU291cmNlPiwgY291bnQ6IG51bWJlciwgc2tpcDogbnVtYmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICB0aGlzLl9za2lwID0gc2tpcDtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshSXRlcmFibGVJdGVyYXRvcjwhQXJyYXk8VFNvdXJjZT4+fVxuICovXG4qW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IC8qKiBAdHlwZSB7IUFycmF5PCFBcnJheTxUU291cmNlPj59ICovIGJ1ZmZlcnM6IFRTb3VyY2VbXVtdID0gW10sIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAgaSA9IDA7XG4gICAgZm9yIChsZXQgLyoqIEB0eXBlIHtUU291cmNlfSAqLyBpdGVtIG9mIHRoaXMuX3NvdXJjZSkge1xuICAgICAgaWYgKGkgJSB0aGlzLl9za2lwID09PSAwKSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IC8qKiBAdHlwZSB7IUFycmF5PFRTb3VyY2U+fSAqLyBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCAmJiBidWZmZXJzWzBdLmxlbmd0aCA9PT0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgeWllbGQgLyoqIEB0eXBlIHshQXJyYXk8VFNvdXJjZT59ICovKCggYnVmZmVycy5zaGlmdCgpKSk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB5aWVsZCAvKiogQHR5cGUgeyFBcnJheTxUU291cmNlPn0gKi8oKCBidWZmZXJzLnNoaWZ0KCkpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQnVmZmVySXRlcmFibGVfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7IUl0ZXJhYmxlPFRTb3VyY2U+fSAqL1xuQnVmZmVySXRlcmFibGUucHJvdG90eXBlLl9zb3VyY2U7XG4vKiogQHR5cGUge251bWJlcn0gKi9cbkJ1ZmZlckl0ZXJhYmxlLnByb3RvdHlwZS5fY291bnQ7XG4vKiogQHR5cGUge251bWJlcn0gKi9cbkJ1ZmZlckl0ZXJhYmxlLnByb3RvdHlwZS5fc2tpcDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzZXF1ZW5jZSBvZiBidWZmZXJzIG92ZXIgdGhlIHNvdXJjZSBzZXF1ZW5jZSwgd2l0aCBzcGVjaWZpZWQgbGVuZ3RoIGFuZCBwb3NzaWJsZSBvdmVybGFwLlxuICogXFxAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGVzIGEgc2VxdWVuY2Ugb2YgYnVmZmVycyB3aXRoIGFuZCB3aXRob3V0IHNraXA8L2NhcHRpb24+XG4gKiBjb25zdCBzb3VyY2UgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMF07XG4gKiBcbiAqIC8vIFdpdGhvdXQgc2tpcFxuICogY29uc3QgcmVzdWx0ID0gYnVmZmVyKHNvdXJjZSwgNSk7XG4gKiBjb25zdCByZXN1bHQgPSBJeC5JdGVyYWJsZS5mcm9tKHNvdXJjZSkuYnVmZmVyKDUpO1xuICogZm9yIChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogfVxuICogLy8gPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiAvLyA9PiBbNSwgNiwgNywgOCwgOV1cbiAqIFxuICogLy8gV2l0aCBza2lwXG4gKiBjb25zdCByZXN1bHQgPSBidWZmZXIoc291cmNlLCAzLCA0KTtcbiAqIGNvbnN0IHJlc3VsdCA9IEl4Lkl0ZXJhYmxlLmZyb20oc291cmNlKS5idWZmZXIoMywgNCk7XG4gKiBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKiAvLyA9PiBbMCwgMSwgMl1cbiAqIC8vID0+IFs0LCA1LCA2XVxuICogLy8gPT4gWzgsIDldXG4gKiB0byB0aGUgY291bnQuXG4gKiBAdGVtcGxhdGUgVFNvdXJjZVxuICogQHBhcmFtIHshSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge251bWJlcj19IHNraXBcbiAqIEByZXR1cm4geyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xLkl0ZXJhYmxlWDwhQXJyYXk8VFNvdXJjZT4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyPFRTb3VyY2U+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgY291bnQ6IG51bWJlcixcbiAgICBza2lwPzogbnVtYmVyKTogSXRlcmFibGVYPFRTb3VyY2VbXT4ge1xuICBpZiAoc2tpcCA9PSBudWxsKSB7IHNraXAgPSBjb3VudDsgfVxuIHJldHVybiBuZXcgQnVmZmVySXRlcmFibGUoc291cmNlLCBjb3VudCwgc2tpcCk7XG59XG4iXX0=