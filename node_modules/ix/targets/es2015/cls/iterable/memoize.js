goog.module('targets.es2015.cls.iterable.memoize'); exports = {}; var module = {id: 'targets/es2015/cls/iterable/memoize.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.es2015.cls.iterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
var _refcountlist_1 = goog.require('targets.es2015.cls.iterable._refcountlist');
const tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable._refcountlist");
var create_1 = goog.require('targets.es2015.cls.iterable.create');
const tsickle_forward_declare_3 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable.create");
/**
 * @template T
 */
class MemoizeBuffer extends iterable_1.IterableX {
    /**
     * @param {!Iterator<T>} source
     * @param {!tsickle_forward_declare_2.IRefCountList<T>} buffer
     */
    constructor(source, buffer) {
        super();
        this._stopped = false;
        this._source = source;
        this._buffer = buffer;
    }
    /**
     * @return {!IterableIterator<T>}
     */
    *[Symbol.iterator]() {
        let /** @type {number} */ i = 0;
        try {
            while (1) {
                let /** @type {boolean} */ hasValue = false, /** @type {T} */ current = ({});
                if (i >= this._buffer.count) {
                    if (!this._stopped) {
                        try {
                            let /** @type {!IteratorResult<T>} */ next = this._source.next();
                            hasValue = !next.done;
                            if (hasValue) {
                                current = next.value;
                            }
                        }
                        catch (e) {
                            this._error = e;
                            this._stopped = true;
                        }
                    }
                    if (this._stopped) {
                        throw this._error;
                    }
                    if (hasValue) {
                        this._buffer.push(current);
                    }
                }
                else {
                    hasValue = true;
                }
                if (hasValue) {
                    yield this._buffer.get(i);
                }
                else {
                    break;
                }
                i++;
            }
        }
        finally {
            this._buffer.done();
        }
    }
}
function MemoizeBuffer_tsickle_Closure_declarations() {
    /** @type {!Iterator<T>} */
    MemoizeBuffer.prototype._source;
    /** @type {!tsickle_forward_declare_2.IRefCountList<T>} */
    MemoizeBuffer.prototype._buffer;
    /** @type {?} */
    MemoizeBuffer.prototype._error;
    /** @type {boolean} */
    MemoizeBuffer.prototype._stopped;
}
/**
 * @template TSource, TResult
 * @param {!Iterable<TSource>} source
 * @param {number=} readerCount
 * @param {function(!Iterable<TSource>): !Iterable<TResult>=} selector
 * @return {!tsickle_forward_declare_1.IterableX<(TSource|TResult)>}
 */
function memoize(source, readerCount = -1, selector) {
    if (readerCount === -1 && !selector) {
        return new MemoizeBuffer(source[Symbol.iterator](), new _refcountlist_1.MaxRefCountList());
    }
    if (readerCount !== -1 && !selector) {
        return new MemoizeBuffer(source[Symbol.iterator](), new _refcountlist_1.RefCountList(readerCount));
    }
    return create_1.create(() => ((selector))(memoize(source, readerCount))[Symbol.iterator]());
}
exports.memoize = memoize;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9tZW1vaXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRzs7QUFFSCwwQ0FMa0I7QUFNbEIsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLHNDQUFzQyxDQUFDLENBTnJEO0FBT3hDLG1EQU5xRDtBQU9yRCxNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsb0RBQW9ELENBQUMsQ0FQNUI7QUFRL0UscUNBUGU7QUFRZixNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsNkNBQTZDLENBQUMsQ0FBQztBQUNyRzs7R0FFRztBQVRILG1CQUFzQixTQUFRLG9CQUFhO0lBZTNDOzs7T0FHRztJQVpELFlBQVksTUFBbUIsRUFBQyxNQUF5QjtRQWN2RCxLQWJLLEVBQUUsQ0FBQztRQUhILGFBQVMsR0FBVyxLQUFNLENBQUE7UUFpQi9CLElBYkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO1FBY3RCLElBYkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO0lBY3hCLENBQUM7SUFDSDs7T0FFRztJQWRELENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBZ0JoQixJQUFJLHFCQWZELENBQUEsQ0FBRSxHQUFFLENBQUUsQ0FBQztRQWdCVixJQWZHLENBQUU7WUFnQkgsT0FmTyxDQUFDLEVBQUMsQ0FBRTtnQkFnQlQsSUFBSSxzQkFmRCxDQUFBLFFBQVMsR0FBRSxLQUFNLEVBQUEsZ0JBQUMsQ0FBQSxPQUFRLEdBQUEsQ0FBTSxFQUFBLENBQUUsQ0FBQztnQkFnQnRDLEVBQUUsQ0FBQyxDQWZDLENBQUMsSUFBRyxJQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUU7b0JBZ0I1QixFQUFFLENBQUMsQ0FmQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQSxDQUFFO3dCQWdCbkIsSUFmRyxDQUFFOzRCQWdCSCxJQUFJLGlDQWZELENBQUEsSUFBSyxHQUFFLElBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7NEJBZ0IvQixRQWZRLEdBQUUsQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDOzRCQWdCdEIsRUFBRSxDQUFDLENBZkMsUUFBUSxDQUFDLENBQUEsQ0FBRTtnQ0FBQSxPQUFRLEdBQUUsSUFBSyxDQUFDLEtBQUssQ0FBQzs0QkFBQSxDQUFFO3dCQWdCekMsQ0FmQzt3QkFBQSxLQUFBLENBQUEsQ0FBUSxDQUFDLENBQUMsQ0FBQSxDQUFFOzRCQWdCWCxJQWZJLENBQUMsTUFBTSxHQUFFLENBQUUsQ0FBQzs0QkFnQmhCLElBZkksQ0FBQyxRQUFRLEdBQUUsSUFBSyxDQUFDO3dCQWdCdkIsQ0FmQztvQkFnQkgsQ0FmQztvQkFpQkQsRUFBRSxDQUFDLENBZkMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBLENBQUU7d0JBZ0JsQixNQWZLLElBQUssQ0FBQyxNQUFNLENBQUM7b0JBZ0JwQixDQWZDO29CQWlCRCxFQUFFLENBQUMsQ0FmQyxRQUFRLENBQUMsQ0FBQSxDQUFFO3dCQUFBLElBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUFBLENBQUU7Z0JBZ0IvQyxDQWZDO2dCQUFBLElBQUssQ0FBQSxDQUFFO29CQWdCTixRQWZRLEdBQUUsSUFBSyxDQUFDO2dCQWdCbEIsQ0FmQztnQkFpQkQsRUFBRSxDQUFDLENBZkMsUUFBUSxDQUFDLENBQUEsQ0FBRTtvQkFnQmIsTUFmSyxJQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFnQjVCLENBZkM7Z0JBQUEsSUFBSyxDQUFBLENBQUU7b0JBZ0JOLEtBQUssQ0FmQztnQkFnQlIsQ0FmQztnQkFpQkQsQ0FmQyxFQUFFLENBQUM7WUFnQk4sQ0FmQztRQWdCSCxDQWZDO2dCQUFRLENBQUU7WUFnQlQsSUFmSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQWdCdEIsQ0FmQztJQWdCSCxDQWZDO0NBQ0g7QUFpQkE7SUFDQSwyQkFBMkI7SUFDM0IsYUFBYSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFDaEMsMERBQTBEO0lBQzFELGFBQWEsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBQ2hDLGdCQUFnQjtJQUNoQixhQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztJQUMvQixzQkFBc0I7SUFDdEIsYUFBYSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7QUFDakMsQ0FBQztBQVNEOzs7Ozs7R0FNRztBQWpDSCxpQkFtQ0ksTUFsQ3lCLEVBbUN6QixjQWxDcUIsQ0FBRSxDQUFDLEVBbUN4QixRQWxDMEQ7SUFtQzVELEVBQUUsQ0FBQyxDQWxDQyxXQUFXLEtBQUksQ0FBRSxDQUFDLElBQUcsQ0FBRSxRQUFRLENBQUMsQ0FBQSxDQUFFO1FBbUNwQyxNQWxDTSxDQUFBLElBQUksYUFBYyxDQUFVLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBQyxJQUFJLCtCQUFnQixFQUFXLENBQUMsQ0FBQztJQW1DL0YsQ0FsQ0M7SUFvQ0QsRUFBRSxDQUFDLENBbENDLFdBQVcsS0FBSSxDQUFFLENBQUMsSUFBRyxDQUFFLFFBQVEsQ0FBQyxDQUFBLENBQUU7UUFtQ3BDLE1BbENNLENBQUEsSUFBSSxhQUFjLENBQVUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFDLElBQUksNEJBQWEsQ0FBVSxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBbUN2RyxDQWxDQztJQW9DRCxNQWxDTSxDQUFBLGVBQU8sQ0FBb0IsTUFBRSxDQUFBLENBQUcsUUFBQSxDQUFBLENBQVUsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFDLFdBQVksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQW1DckcsQ0FsQ0M7QUFiRCwwQkFhQyIsImZpbGUiOiJtZW1vaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaXRlcmFibGVcIik7XG5pbXBvcnQgeyBJUmVmQ291bnRMaXN0LCBNYXhSZWZDb3VudExpc3QsIFJlZkNvdW50TGlzdCB9IGZyb20gJy4vX3JlZmNvdW50bGlzdCc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8yID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pdGVyYWJsZS5fcmVmY291bnRsaXN0XCIpO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi9jcmVhdGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMyA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaXRlcmFibGUuY3JlYXRlXCIpO1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBNZW1vaXplQnVmZmVyPFQ+IGV4dGVuZHMgSXRlcmFibGVYPFQ+IHtcbnByaXZhdGUgX3NvdXJjZTogSXRlcmF0b3I8VD47XG5wcml2YXRlIF9idWZmZXI6IElSZWZDb3VudExpc3Q8VD47XG5wcml2YXRlIF9lcnJvcjogYW55O1xucHJpdmF0ZSBfc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuLyoqXG4gKiBAcGFyYW0geyFJdGVyYXRvcjxUPn0gc291cmNlXG4gKiBAcGFyYW0geyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8yLklSZWZDb3VudExpc3Q8VD59IGJ1ZmZlclxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhdG9yPFQ+LCBidWZmZXI6IElSZWZDb3VudExpc3Q8VD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gIH1cbi8qKlxuICogQHJldHVybiB7IUl0ZXJhYmxlSXRlcmF0b3I8VD59XG4gKi9cbipbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGkgPSAwO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBsZXQgLyoqIEB0eXBlIHtib29sZWFufSAqLyBoYXNWYWx1ZSA9IGZhbHNlLCAvKiogQHR5cGUge1R9ICovIGN1cnJlbnQgPSAvKiogQHR5cGUge1R9ICovKCggPFQ+e30pKTtcbiAgICAgICAgaWYgKGkgPj0gdGhpcy5fYnVmZmVyLmNvdW50KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgLyoqIEB0eXBlIHshSXRlcmF0b3JSZXN1bHQ8VD59ICovIG5leHQgPSB0aGlzLl9zb3VyY2UubmV4dCgpO1xuICAgICAgICAgICAgICBoYXNWYWx1ZSA9ICFuZXh0LmRvbmU7XG4gICAgICAgICAgICAgIGlmIChoYXNWYWx1ZSkgeyBjdXJyZW50ID0gbmV4dC52YWx1ZTsgfVxuICAgICAgICAgICAgfSBjYXRjaCAoIC8qKiBAdHlwZSB7P30gKi9lKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZTtcbiAgICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNWYWx1ZSkgeyB0aGlzLl9idWZmZXIucHVzaChjdXJyZW50KTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuX2J1ZmZlci5nZXQoaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2J1ZmZlci5kb25lKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIE1lbW9pemVCdWZmZXJfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7IUl0ZXJhdG9yPFQ+fSAqL1xuTWVtb2l6ZUJ1ZmZlci5wcm90b3R5cGUuX3NvdXJjZTtcbi8qKiBAdHlwZSB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzIuSVJlZkNvdW50TGlzdDxUPn0gKi9cbk1lbW9pemVCdWZmZXIucHJvdG90eXBlLl9idWZmZXI7XG4vKiogQHR5cGUgez99ICovXG5NZW1vaXplQnVmZmVyLnByb3RvdHlwZS5fZXJyb3I7XG4vKiogQHR5cGUge2Jvb2xlYW59ICovXG5NZW1vaXplQnVmZmVyLnByb3RvdHlwZS5fc3RvcHBlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8VFNvdXJjZT4oXG4gIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gIHJlYWRlckNvdW50PzogbnVtYmVyKTogSXRlcmFibGVYPFRTb3VyY2U+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8VFNvdXJjZSwgVFJlc3VsdD4oXG4gIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gIHJlYWRlckNvdW50PzogbnVtYmVyLFxuICBzZWxlY3Rvcj86ICh2YWx1ZTogSXRlcmFibGU8VFNvdXJjZT4pID0+IEl0ZXJhYmxlPFRSZXN1bHQ+KTogSXRlcmFibGVYPFRSZXN1bHQ+O1xuLyoqXG4gKiBAdGVtcGxhdGUgVFNvdXJjZSwgVFJlc3VsdFxuICogQHBhcmFtIHshSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXI9fSByZWFkZXJDb3VudFxuICogQHBhcmFtIHtmdW5jdGlvbighSXRlcmFibGU8VFNvdXJjZT4pOiAhSXRlcmFibGU8VFJlc3VsdD49fSBzZWxlY3RvclxuICogQHJldHVybiB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuSXRlcmFibGVYPChUU291cmNlfFRSZXN1bHQpPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8VFNvdXJjZSwgVFJlc3VsdCA9IFRTb3VyY2U+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgcmVhZGVyQ291bnQ6IG51bWJlciA9IC0xLFxuICAgIHNlbGVjdG9yPzogKHZhbHVlOiBJdGVyYWJsZTxUU291cmNlPikgPT4gSXRlcmFibGU8VFJlc3VsdD4pOiBJdGVyYWJsZVg8VFNvdXJjZSB8IFRSZXN1bHQ+IHtcbiAgaWYgKHJlYWRlckNvdW50ID09PSAtMSAmJiAhc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9pemVCdWZmZXI8VFNvdXJjZT4oc291cmNlW1N5bWJvbC5pdGVyYXRvcl0oKSwgbmV3IE1heFJlZkNvdW50TGlzdDxUU291cmNlPigpKTtcbiAgfVxuXG4gIGlmIChyZWFkZXJDb3VudCAhPT0gLTEgJiYgIXNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vaXplQnVmZmVyPFRTb3VyY2U+KHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKCksIG5ldyBSZWZDb3VudExpc3Q8VFNvdXJjZT4ocmVhZGVyQ291bnQpKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGU8VFNvdXJjZSB8IFRSZXN1bHQ+KCgpID0+IC8qKiBAdHlwZSB7ZnVuY3Rpb24oIUl0ZXJhYmxlPFRTb3VyY2U+KTogIUl0ZXJhYmxlPFRSZXN1bHQ+fSAqLygoIHNlbGVjdG9yKSkobWVtb2l6ZShzb3VyY2UsIHJlYWRlckNvdW50KSlbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbn1cbiJdfQ==