goog.module('targets.es2015.cls.asynciterable.flatten'); exports = {}; var module = {id: 'targets/es2015/cls/asynciterable/flatten.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es2015.cls.asynciterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
var isiterable_1 = goog.require('targets.es2015.cls.internal.isiterable');
const tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.internal.isiterable");
/**
 * @template TSource
 */
class FlattenAsyncIterable extends asynciterable_1.AsyncIterableX {
    /**
     * @param {!AsyncIterable<TSource>} source
     * @param {number} depth
     */
    constructor(source, depth) {
        super();
        this._source = source;
        this._depth = depth;
    }
    /**
     * @param {!AsyncIterable<TSource>} source
     * @param {number} depth
     * @return {!AsyncIterable<TSource>}
     */
    _flatten(source, depth) {
        return __asyncGenerator(this, arguments, function* _flatten_1() {
            if (depth === 0) {
                try {
                    for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {
                        let /** @type {TSource} */ item = yield __await(source_1_1.value);
                        yield item;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return;
            }
            try {
                for (var source_2 = __asyncValues(source), source_2_1; source_2_1 = yield __await(source_2.next()), !source_2_1.done;) {
                    let /** @type {TSource} */ item = yield __await(source_2_1.value);
                    if (isiterable_1.isAsyncIterable(item)) {
                        try {
                            for (var _b = __asyncValues(this._flatten(item, depth - 1)), _c; _c = yield __await(_b.next()), !_c.done;) {
                                let /** @type {TSource} */ innerItem = yield __await(_c.value);
                                yield innerItem;
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) yield __await(_d.call(_b));
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    else {
                        yield item;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (source_2_1 && !source_2_1.done && (_e = source_2.return)) yield __await(_e.call(source_2));
                }
                finally { if (e_3) throw e_3.error; }
            }
            var e_1, _a, e_3, _e, e_2, _d;
        });
    }
    /**
     * @return {!AsyncIterator<TSource>}
     */
    [Symbol.asyncIterator]() {
        return this._flatten(this._source, this._depth)[Symbol.asyncIterator]();
    }
}
function FlattenAsyncIterable_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TSource>} */
    FlattenAsyncIterable.prototype._source;
    /** @type {number} */
    FlattenAsyncIterable.prototype._depth;
}
/**
 * @template T
 * @param {!AsyncIterable<T>} source
 * @param {number=} depth
 * @return {!tsickle_forward_declare_1.AsyncIterableX<T>}
 */
function flatten(source, depth = Infinity) {
    return new FlattenAsyncIterable(source, depth);
}
exports.flatten = flatten;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL2ZsYXR0ZW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILG9EQUx1QjtBQU12QixNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsMkNBQTJDLENBQUMsQ0FOaEQ7QUFPbEQsdURBTndCO0FBT3hCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO0FBQ3pHOztHQUVHO0FBUkgsMEJBQW1DLFNBQVEsOEJBQXdCO0lBWW5FOzs7T0FHRztJQVhELFlBQVksTUFBOEIsRUFBQyxLQUFjO1FBYXZELEtBWkssRUFBRSxDQUFDO1FBYVIsSUFaSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7UUFhdEIsSUFaSSxDQUFDLE1BQU0sR0FBRSxLQUFNLENBQUM7SUFhdEIsQ0FBQztJQUNIOzs7O09BSUc7SUFmYyxRQUFRLENBQUMsTUFBOEIsRUFBQyxLQUFjOztZQWtCbkUsRUFBRSxDQUFDLENBakJDLEtBQUssS0FBSSxDQUFFLENBQUMsQ0FBQSxDQUFFOztvQkFrQmhCLEdBakJHLENBQUEsQ0FBbUIsSUFBQSxXQUFBLGNBQUEsTUFBTyxDQUFBLFlBQUE7d0JBQWxCLElBQUEsc0JBQUcsQ0FBQSxJQUFLLGtDQUFBLENBQUE7d0JBQWEsTUFBTSxJQUFLLENBQUM7cUJBQUU7Ozs7Ozs7OztnQkFrQjlDLE1BQU0sQ0FqQkM7WUFrQlQsQ0FqQkM7O2dCQWtCRCxHQWpCRyxDQUFBLENBQW1CLElBQUEsV0FBQSxjQUFBLE1BQU8sQ0FBQSxZQUFBO29CQUFsQixJQUFBLHNCQUFHLENBQUEsSUFBSyxrQ0FBQSxDQUFBO29CQWtCakIsRUFBRSxDQUFDLENBakJDLDRCQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQSxDQUFFOzs0QkFrQjFCLEdBakJHLENBQUEsQ0FBd0IsSUFBQSxLQUFBLGNBQUEsSUFBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUMsS0FBTSxHQUFFLENBQUUsQ0FBQyxDQUFBLElBQUE7Z0NBQS9DLElBQUEsc0JBQUcsQ0FBQSxTQUFVLDBCQUFBLENBQUE7Z0NBQXFDLE1BQU0sU0FBVSxDQUFDOzZCQUFFOzs7Ozs7Ozs7b0JBa0JsRixDQWpCQztvQkFBQSxJQUFLLENBQUEsQ0FBRTt3QkFrQk4sTUFqQkssSUFBSyxDQUFDO29CQWtCYixDQWpCQztpQkFDRjs7Ozs7Ozs7OztRQWtCSCxDQUFDO0tBQUE7SUFDSDs7T0FFRztJQWxCRCxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7UUFvQnBCLE1BbkJNLENBQUEsSUFBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFDLElBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztJQW9CMUUsQ0FuQkM7Q0FDSDtBQXFCQTtJQUNBLHNDQUFzQztJQUN0QyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBQ3ZDLHFCQUFxQjtJQUNyQixvQkFBb0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO0FBQ3RDLENBQUM7QUFFRDs7Ozs7R0FLRztBQS9CSCxpQkFBMkIsTUFBd0IsRUFBQyxRQUFnQixRQUFTO0lBaUMzRSxNQWhDTSxDQUFBLElBQUksb0JBQXFCLENBQUksTUFBTSxFQUFDLEtBQU0sQ0FBQyxDQUFDO0FBaUNwRCxDQWhDQztBQUZELDBCQUVDIiwiZmlsZSI6ImZsYXR0ZW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuYXN5bmNpdGVyYWJsZVwiKTtcbmltcG9ydCB7IGlzQXN5bmNJdGVyYWJsZSB9IGZyb20gJy4uL2ludGVybmFsL2lzaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMiA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaW50ZXJuYWwuaXNpdGVyYWJsZVwiKTtcbi8qKlxuICogQHRlbXBsYXRlIFRTb3VyY2VcbiAqL1xuY2xhc3MgRmxhdHRlbkFzeW5jSXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG5wcml2YXRlIF9zb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT47XG5wcml2YXRlIF9kZXB0aDogbnVtYmVyO1xuLyoqXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sIGRlcHRoOiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9kZXB0aCA9IGRlcHRoO1xuICB9XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoXG4gKiBAcmV0dXJuIHshQXN5bmNJdGVyYWJsZTxUU291cmNlPn1cbiAqL1xuXG5wcml2YXRlIGFzeW5jICpfZmxhdHRlbihzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sIGRlcHRoOiBudW1iZXIpOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+IHtcbiAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgIGZvciBhd2FpdCAobGV0IC8qKiBAdHlwZSB7VFNvdXJjZX0gKi8gaXRlbSBvZiBzb3VyY2UpIHsgeWllbGQgaXRlbTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgYXdhaXQgKGxldCAvKiogQHR5cGUge1RTb3VyY2V9ICovIGl0ZW0gb2Ygc291cmNlKSB7XG4gICAgICBpZiAoaXNBc3luY0l0ZXJhYmxlKGl0ZW0pKSB7XG4gICAgICAgIGZvciBhd2FpdCAobGV0IC8qKiBAdHlwZSB7VFNvdXJjZX0gKi8gaW5uZXJJdGVtIG9mIHRoaXMuX2ZsYXR0ZW4oaXRlbSwgZGVwdGggLSAxKSkgeyB5aWVsZCBpbm5lckl0ZW07IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4vKipcbiAqIEByZXR1cm4geyFBc3luY0l0ZXJhdG9yPFRTb3VyY2U+fVxuICovXG5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLl9mbGF0dGVuKHRoaXMuX3NvdXJjZSwgdGhpcy5fZGVwdGgpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIEZsYXR0ZW5Bc3luY0l0ZXJhYmxlX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUgeyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSAqL1xuRmxhdHRlbkFzeW5jSXRlcmFibGUucHJvdG90eXBlLl9zb3VyY2U7XG4vKiogQHR5cGUge251bWJlcn0gKi9cbkZsYXR0ZW5Bc3luY0l0ZXJhYmxlLnByb3RvdHlwZS5fZGVwdGg7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXI9fSBkZXB0aFxuICogQHJldHVybiB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuQXN5bmNJdGVyYWJsZVg8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuPFQ+KHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUPiwgZGVwdGg6IG51bWJlciA9IEluZmluaXR5KTogQXN5bmNJdGVyYWJsZVg8VD4ge1xuICByZXR1cm4gbmV3IEZsYXR0ZW5Bc3luY0l0ZXJhYmxlPFQ+KHNvdXJjZSwgZGVwdGgpO1xufVxuIl19