goog.module('targets.es2015.cls.asynciterable.memoize'); exports = {}; var module = {id: 'targets/es2015/cls/asynciterable/memoize.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es2015.cls.asynciterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
var _refcountlist_1 = goog.require('targets.es2015.cls.iterable._refcountlist');
const tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable._refcountlist");
var create_1 = goog.require('targets.es2015.cls.asynciterable.create');
const tsickle_forward_declare_3 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable.create");
/**
 * @template T
 */
class MemoizeAsyncBuffer extends asynciterable_1.AsyncIterableX {
    /**
     * @param {!AsyncIterator<T>} source
     * @param {!tsickle_forward_declare_2.IRefCountList<T>} buffer
     */
    constructor(source, buffer) {
        super();
        this._stopped = false;
        this._source = source;
        this._buffer = buffer;
    }
    /**
     * @return {!AsyncIterableIterator<T>}
     */
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            let /** @type {number} */ i = 0;
            try {
                while (1) {
                    let /** @type {boolean} */ hasValue = false, /** @type {T} */ current = ({});
                    if (i >= this._buffer.count) {
                        if (!this._stopped) {
                            try {
                                let /** @type {!IteratorResult<T>} */ next = yield __await(this._source.next());
                                hasValue = !next.done;
                                if (hasValue) {
                                    current = next.value;
                                }
                            }
                            catch (e) {
                                this._error = e;
                                this._stopped = true;
                            }
                        }
                        if (this._stopped) {
                            throw this._error;
                        }
                        if (hasValue) {
                            this._buffer.push(current);
                        }
                    }
                    else {
                        hasValue = true;
                    }
                    if (hasValue) {
                        yield this._buffer.get(i);
                    }
                    else {
                        break;
                    }
                    i++;
                }
            }
            finally {
                this._buffer.done();
            }
        });
    }
}
function MemoizeAsyncBuffer_tsickle_Closure_declarations() {
    /** @type {!AsyncIterator<T>} */
    MemoizeAsyncBuffer.prototype._source;
    /** @type {!tsickle_forward_declare_2.IRefCountList<T>} */
    MemoizeAsyncBuffer.prototype._buffer;
    /** @type {?} */
    MemoizeAsyncBuffer.prototype._error;
    /** @type {boolean} */
    MemoizeAsyncBuffer.prototype._stopped;
}
/**
 * @template TSource, TResult
 * @param {!AsyncIterable<TSource>} source
 * @param {number=} readerCount
 * @param {function(!AsyncIterable<TSource>): !AsyncIterable<TResult>=} selector
 * @return {!tsickle_forward_declare_1.AsyncIterableX<(TSource|TResult)>}
 */
function memoize(source, readerCount = -1, selector) {
    if (readerCount === -1 && !selector) {
        return new MemoizeAsyncBuffer(source[Symbol.asyncIterator](), new _refcountlist_1.MaxRefCountList());
    }
    if (readerCount !== -1 && !selector) {
        return new MemoizeAsyncBuffer(source[Symbol.asyncIterator](), new _refcountlist_1.RefCountList(readerCount));
    }
    return create_1.create(() => ((selector))(memoize(source, readerCount))[Symbol.asyncIterator]());
}
exports.memoize = memoize;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL21lbW9pemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILG9EQUx1QjtBQU12QixNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsMkNBQTJDLENBQUMsQ0FOaEQ7QUFPbEQsNkRBTnFEO0FBT3JELE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxvREFBb0QsQ0FBQyxDQVBsQjtBQVF6RixxQ0FQZTtBQVFmLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO0FBQzFHOztHQUVHO0FBVEgsd0JBQTJCLFNBQVEsOEJBQWtCO0lBZXJEOzs7T0FHRztJQVpELFlBQVksTUFBd0IsRUFBQyxNQUF5QjtRQWM1RCxLQWJLLEVBQUUsQ0FBQztRQUhILGFBQVMsR0FBVyxLQUFNLENBQUE7UUFpQi9CLElBYkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO1FBY3RCLElBYkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO0lBY3hCLENBQUM7SUFDSDs7T0FFRztJQWRNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQzs7WUFnQjNCLElBQUkscUJBZkQsQ0FBQSxDQUFFLEdBQUUsQ0FBRSxDQUFDO1lBZ0JWLElBZkcsQ0FBRTtnQkFnQkgsT0FmTyxDQUFDLEVBQUMsQ0FBRTtvQkFnQlQsSUFBSSxzQkFmRCxDQUFBLFFBQVMsR0FBRSxLQUFNLEVBQUEsZ0JBQUMsQ0FBQSxPQUFRLEdBQUEsQ0FBTSxFQUFBLENBQUUsQ0FBQztvQkFnQnRDLEVBQUUsQ0FBQyxDQWZDLENBQUMsSUFBRyxJQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUU7d0JBZ0I1QixFQUFFLENBQUMsQ0FmQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQSxDQUFFOzRCQWdCbkIsSUFmRyxDQUFFO2dDQWdCSCxJQUFJ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c291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuYXN5bmNpdGVyYWJsZVwiKTtcbmltcG9ydCB7IElSZWZDb3VudExpc3QsIE1heFJlZkNvdW50TGlzdCwgUmVmQ291bnRMaXN0IH0gZnJvbSAnLi4vaXRlcmFibGUvX3JlZmNvdW50bGlzdCc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8yID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pdGVyYWJsZS5fcmVmY291bnRsaXN0XCIpO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnLi9jcmVhdGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMyA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuYXN5bmNpdGVyYWJsZS5jcmVhdGVcIik7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIE1lbW9pemVBc3luY0J1ZmZlcjxUPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFQ+IHtcbnByaXZhdGUgX3NvdXJjZTogQXN5bmNJdGVyYXRvcjxUPjtcbnByaXZhdGUgX2J1ZmZlcjogSVJlZkNvdW50TGlzdDxUPjtcbnByaXZhdGUgX2Vycm9yOiBhbnk7XG5wcml2YXRlIF9zdG9wcGVkOiBib29sZWFuID0gZmFsc2U7XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmF0b3I8VD59IHNvdXJjZVxuICogQHBhcmFtIHshdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMi5JUmVmQ291bnRMaXN0PFQ+fSBidWZmZXJcbiAqL1xuY29uc3RydWN0b3Ioc291cmNlOiBBc3luY0l0ZXJhdG9yPFQ+LCBidWZmZXI6IElSZWZDb3VudExpc3Q8VD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9idWZmZXIgPSBidWZmZXI7XG4gIH1cbi8qKlxuICogQHJldHVybiB7IUFzeW5jSXRlcmFibGVJdGVyYXRvcjxUPn1cbiAqL1xuYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBpID0gMDtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgbGV0IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gaGFzVmFsdWUgPSBmYWxzZSwgLyoqIEB0eXBlIHtUfSAqLyBjdXJyZW50ID0gLyoqIEB0eXBlIHtUfSAqLygoIDxUPnt9KSk7XG4gICAgICAgIGlmIChpID49IHRoaXMuX2J1ZmZlci5jb3VudCkge1xuICAgICAgICAgIGlmICghdGhpcy5fc3RvcHBlZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IC8qKiBAdHlwZSB7IUl0ZXJhdG9yUmVzdWx0PFQ+fSAqLyBuZXh0ID0gYXdhaXQgdGhpcy5fc291cmNlLm5leHQoKTtcbiAgICAgICAgICAgICAgaGFzVmFsdWUgPSAhbmV4dC5kb25lO1xuICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUpIHsgY3VycmVudCA9IG5leHQudmFsdWU7IH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKCAvKiogQHR5cGUgez99ICovZSkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGU7XG4gICAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzVmFsdWUpIHsgdGhpcy5fYnVmZmVyLnB1c2goY3VycmVudCk7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLl9idWZmZXIuZ2V0KGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9idWZmZXIuZG9uZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBNZW1vaXplQXN5bmNCdWZmZXJfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7IUFzeW5jSXRlcmF0b3I8VD59ICovXG5NZW1vaXplQXN5bmNCdWZmZXIucHJvdG90eXBlLl9zb3VyY2U7XG4vKiogQHR5cGUgeyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8yLklSZWZDb3VudExpc3Q8VD59ICovXG5NZW1vaXplQXN5bmNCdWZmZXIucHJvdG90eXBlLl9idWZmZXI7XG4vKiogQHR5cGUgez99ICovXG5NZW1vaXplQXN5bmNCdWZmZXIucHJvdG90eXBlLl9lcnJvcjtcbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbk1lbW9pemVBc3luY0J1ZmZlci5wcm90b3R5cGUuX3N0b3BwZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplPFRTb3VyY2U+KFxuICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICByZWFkZXJDb3VudD86IG51bWJlcik6IEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8VFNvdXJjZSwgVFJlc3VsdD4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIHJlYWRlckNvdW50PzogbnVtYmVyLFxuICAgIHNlbGVjdG9yPzogKHZhbHVlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KSA9PiBBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+KTogQXN5bmNJdGVyYWJsZVg8VFJlc3VsdD47XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlLCBUUmVzdWx0XG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmVhZGVyQ291bnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oIUFzeW5jSXRlcmFibGU8VFNvdXJjZT4pOiAhQXN5bmNJdGVyYWJsZTxUUmVzdWx0Pj19IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHshdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMS5Bc3luY0l0ZXJhYmxlWDwoVFNvdXJjZXxUUmVzdWx0KT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplPFRTb3VyY2UsIFRSZXN1bHQgPSBUU291cmNlPihcbiAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgcmVhZGVyQ291bnQ6IG51bWJlciA9IC0xLFxuICAgIHNlbGVjdG9yPzogKHZhbHVlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KSA9PiBBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+KTogQXN5bmNJdGVyYWJsZVg8VFNvdXJjZSB8IFRSZXN1bHQ+IHtcbiAgaWYgKHJlYWRlckNvdW50ID09PSAtMSAmJiAhc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IE1lbW9pemVBc3luY0J1ZmZlcjxUU291cmNlPihzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIG5ldyBNYXhSZWZDb3VudExpc3Q8VFNvdXJjZT4oKSk7XG4gIH1cblxuICBpZiAocmVhZGVyQ291bnQgIT09IC0xICYmICFzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgTWVtb2l6ZUFzeW5jQnVmZmVyPFRTb3VyY2U+KHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSwgbmV3IFJlZkNvdW50TGlzdDxUU291cmNlPihyZWFkZXJDb3VudCkpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZTxUU291cmNlIHwgVFJlc3VsdD4oKCkgPT4gLyoqIEB0eXBlIHtmdW5jdGlvbighQXN5bmNJdGVyYWJsZTxUU291cmNlPik6ICFBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+fSAqLygoIHNlbGVjdG9yKSkobWVtb2l6ZShzb3VyY2UsIHJlYWRlckNvdW50KSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpO1xufVxuIl19