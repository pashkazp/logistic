goog.module('targets.es2015.cls.asynciterable.chain'); exports = {}; var module = {id: 'targets/es2015/cls/asynciterable/chain.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es2015.cls.asynciterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
/**
 * @template TResult
 */
class ChainAsyncIterable extends asynciterable_1.AsyncIterableX {
    /**
     * @param {!AsyncIterable<TResult>} result
     */
    constructor(result) {
        super();
        this._result = result;
    }
    /**
     * @return {!AsyncIterator<TResult>}
     */
    [Symbol.asyncIterator]() {
        return this._result[Symbol.asyncIterator]();
    }
}
function ChainAsyncIterable_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TResult>} */
    ChainAsyncIterable.prototype._result;
}
/**
 * Returns an async iterable sequence that is the result of invoking the selector on the source sequence,
 * without sharing subscriptions.  This operator allows for a fluent style of writing queries that use
 * the same sequence multiple times.
 * the source sequence as many times as needed, without sharing subscriptions to the source sequence.
 * @template TSource, TResult
 * @param {!AsyncIterable<TSource>} source
 * @param {function(!AsyncIterable<TSource>): !AsyncIterable<TResult>} selector
 * @return {!tsickle_forward_declare_1.AsyncIterableX<TResult>} An async iterable sequence that contains the elements of a sequence produced by multicasting the source
 * sequence within a selector function.
 */
function chain(source, selector) {
    return new ChainAsyncIterable(selector(source));
}
exports.chain = chain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL2NoYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRzs7QUFFSCxvREFMdUI7QUFNdkIsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7QUFDbkc7O0dBRUc7QUFQSCx3QkFBaUMsU0FBUSw4QkFBd0I7SUFVakU7O09BRUc7SUFURCxZQUFZLE1BQThCO1FBV3hDLEtBVkssRUFBRSxDQUFDO1FBV1IsSUFWSSxDQUFDLE9BQU8sR0FBRSxNQUFPLENBQUM7SUFXeEIsQ0FBQztJQUNIOztPQUVHO0lBWEQsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDO1FBYXBCLE1BWk0sQ0FBQSxJQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO0lBYTlDLENBWkM7Q0FDSDtBQWNBO0lBQ0Esc0NBQXNDO0lBQ3RDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7QUFDckMsQ0FBQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFqQkgsZUFtQkksTUFsQjhCLEVBbUI5QixRQWxCb0U7SUFtQnRFLE1BbEJNLENBQUEsSUFBSSxrQkFBbUIsQ0FBVSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQW1CM0QsQ0FsQkM7QUFKRCxzQkFJQyIsImZpbGUiOiJjaGFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbmltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5hc3luY2l0ZXJhYmxlXCIpO1xuLyoqXG4gKiBAdGVtcGxhdGUgVFJlc3VsdFxuICovXG5jbGFzcyBDaGFpbkFzeW5jSXRlcmFibGU8VFJlc3VsdD4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUUmVzdWx0PiB7XG5wcml2YXRlIF9yZXN1bHQ6IEFzeW5jSXRlcmFibGU8VFJlc3VsdD47XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFJlc3VsdD59IHJlc3VsdFxuICovXG5jb25zdHJ1Y3RvcihyZXN1bHQ6IEFzeW5jSXRlcmFibGU8VFJlc3VsdD4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHJlc3VsdDtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshQXN5bmNJdGVyYXRvcjxUUmVzdWx0Pn1cbiAqL1xuW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIENoYWluQXN5bmNJdGVyYWJsZV90c2lja2xlX0Nsb3N1cmVfZGVjbGFyYXRpb25zKCkge1xuLyoqIEB0eXBlIHshQXN5bmNJdGVyYWJsZTxUUmVzdWx0Pn0gKi9cbkNoYWluQXN5bmNJdGVyYWJsZS5wcm90b3R5cGUuX3Jlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhYmxlIHNlcXVlbmNlIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3Igb24gdGhlIHNvdXJjZSBzZXF1ZW5jZSxcbiAqIHdpdGhvdXQgc2hhcmluZyBzdWJzY3JpcHRpb25zLiAgVGhpcyBvcGVyYXRvciBhbGxvd3MgZm9yIGEgZmx1ZW50IHN0eWxlIG9mIHdyaXRpbmcgcXVlcmllcyB0aGF0IHVzZVxuICogdGhlIHNhbWUgc2VxdWVuY2UgbXVsdGlwbGUgdGltZXMuXG4gKiB0aGUgc291cmNlIHNlcXVlbmNlIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IHNoYXJpbmcgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICogQHRlbXBsYXRlIFRTb3VyY2UsIFRSZXN1bHRcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbighQXN5bmNJdGVyYWJsZTxUU291cmNlPik6ICFBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+fSBzZWxlY3RvclxuICogQHJldHVybiB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuQXN5bmNJdGVyYWJsZVg8VFJlc3VsdD59IEFuIGFzeW5jIGl0ZXJhYmxlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIG9mIGEgc2VxdWVuY2UgcHJvZHVjZWQgYnkgbXVsdGljYXN0aW5nIHRoZSBzb3VyY2VcbiAqIHNlcXVlbmNlIHdpdGhpbiBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhaW48VFNvdXJjZSwgVFJlc3VsdD4oXG4gICAgc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIHNlbGVjdG9yOiAoc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KSA9PiBBc3luY0l0ZXJhYmxlPFRSZXN1bHQ+KTogQXN5bmNJdGVyYWJsZVg8VFJlc3VsdD4ge1xuICByZXR1cm4gbmV3IENoYWluQXN5bmNJdGVyYWJsZTxUUmVzdWx0PihzZWxlY3Rvcihzb3VyY2UpKTtcbn1cbiJdfQ==