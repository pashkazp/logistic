goog.module('targets.es2015.cls.asynciterable.buffer'); exports = {}; var module = {id: 'targets/es2015/cls/asynciterable/buffer.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es2015.cls.asynciterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
/**
 * @template TSource
 */
class BufferAsyncIterable extends asynciterable_1.AsyncIterableX {
    /**
     * @param {!AsyncIterable<TSource>} source
     * @param {number} count
     * @param {number} skip
     */
    constructor(source, count, skip) {
        super();
        this._source = source;
        this._count = count;
        this._skip = skip;
    }
    /**
     * @return {!AsyncIterableIterator<!Array<TSource>>}
     */
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            let /** @type {!Array<!Array<TSource>>} */ buffers = [], /** @type {number} */ i = 0;
            try {
                for (var _a = __asyncValues(this._source), _b; _b = yield __await(_a.next()), !_b.done;) {
                    let /** @type {TSource} */ item = yield __await(_b.value);
                    if (i % this._skip === 0) {
                        buffers.push([]);
                    }
                    for (let /** @type {!Array<TSource>} */ buffer of buffers) {
                        buffer.push(item);
                    }
                    if (buffers.length > 0 && buffers[0].length === this._count) {
                        yield ((buffers.shift()));
                    }
                    i++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) yield __await(_c.call(_a));
                }
                finally { if (e_1) throw e_1.error; }
            }
            while (buffers.length > 0) {
                yield ((buffers.shift()));
            }
            var e_1, _c;
        });
    }
}
function BufferAsyncIterable_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TSource>} */
    BufferAsyncIterable.prototype._source;
    /** @type {number} */
    BufferAsyncIterable.prototype._count;
    /** @type {number} */
    BufferAsyncIterable.prototype._skip;
}
/**
 * @template TSource
 * @param {!AsyncIterable<TSource>} source
 * @param {number} count
 * @param {number=} skip
 * @return {!tsickle_forward_declare_1.AsyncIterableX<!Array<TSource>>}
 */
function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferAsyncIterable(source, count, skip);
}
exports.buffer = buffer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7O0FBRUgsb0RBTHVCO0FBTXZCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0FBQ25HOztHQUVHO0FBUEgseUJBQWtDLFNBQVEsOEJBQTBCO0lBWXBFOzs7O09BSUc7SUFYRCxZQWFJLE1BWjhCLEVBYTlCLEtBWmEsRUFhYixJQVpZO1FBYVosS0FaSyxFQUFFLENBQUM7UUFhVixJQVpJLENBQUMsT0FBTyxHQUFFLE1BQU8sQ0FBQztRQWF0QixJQVpJLENBQUMsTUFBTSxHQUFFLEtBQU0sQ0FBQztRQWFwQixJQVpJLENBQUMsS0FBSyxHQUFFLElBQUssQ0FBQztJQWFwQixDQUFDO0lBQ0g7O09BRUc7SUFiTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7O1lBZ0IzQixJQUFJLHNDQWRELENBQUEsT0FBUSxHQUFlLEVBQUcsRUFBQSxxQkFBQyxDQUFBLENBQUcsR0FBRSxDQUFFLENBQUM7O2dCQWV0QyxHQWRHLENBQUEsQ0FBbUIsSUFBQSxLQUFBLGNBQUEsSUFBSyxDQUFDLE9BQU8sQ0FBQSxJQUFBO29CQUF4QixJQUFBLHNCQUFHLENBQUEsSUFBSywwQkFBQSxDQUFBO29CQWVqQixFQUFFLENBQUMsQ0FkQyxDQUFDLEdBQUUsSUFBSyxDQUFDLEtBQUssS0FBSSxDQUFFLENBQUMsQ0FBQSxDQUFFO3dCQWV6QixPQWRPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQWVuQixDQWRDO29CQWdCRCxHQUFHLENBQUMsQ0FkQyxJQUFBLDhCQUFHLENBQUEsTUFBTyxJQUFHLE9BQVEsQ0FBQyxDQUFBLENBQUU7d0JBZTNCLE1BZE0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBZXBCLENBZEM7b0JBZ0JELEVBQUUsQ0FBQyxDQWRDLE9BQU8sQ0FBQyxNQUFNLEdBQUUsQ0FBRSxJQUFHLE9BQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUksSUFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFBLENBQUU7d0JBZTVELE1BQW9DLENBQUMsQ0FkaEMsT0FBUSxDQUFDLEtBQUssRUFBQSxDQUFBLENBQUcsQ0FBQztvQkFlekIsQ0FkQztvQkFnQkQsQ0FkQyxFQUFFLENBQUM7aUJBQ0w7Ozs7Ozs7OztZQWdCRCxPQWRPLE9BQU8sQ0FBQyxNQUFNLEdBQUUsQ0FBRSxFQUFDLENBQUU7Z0JBZTFCLE1BQW9DLENBQUMsQ0FkaEMsT0FBUSxDQUFDLEtBQUssRUFBQSxDQUFBLENBQUcsQ0FBQztZQWV6QixDQWRDOztRQWVILENBZEM7S0FBQTtDQUNIO0FBZ0JBO0lBQ0Esc0NBQXNDO0lBQ3RDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFDdEMscUJBQXFCO0lBQ3JCLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7SUFDckMscUJBQXFCO0lBQ3JCLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7QUFDcEMsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQTdCSCxnQkErQkksTUE5QjhCLEVBK0I5QixLQTlCYSxFQStCYixJQTlCYTtJQStCZixFQUFFLENBQUMsQ0E5QkMsSUFBSSxJQUFHLElBQUssQ0FBQyxDQUFBLENBQUU7UUFBQSxJQUFLLEdBQUUsS0FBTSxDQUFDO0lBQUEsQ0FBRTtJQStCbkMsTUE5Qk0sQ0FBQSxJQUFJLG1CQUFvQixDQUFVLE1BQU0sRUFBQyxLQUFNLEVBQUMsSUFBSyxDQUFDLENBQUM7QUErQi9ELENBOUJDO0FBTkQsd0JBTUMiLCJmaWxlIjoiYnVmZmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuaW1wb3J0IHsgQXN5bmNJdGVyYWJsZVggfSBmcm9tICcuLi9hc3luY2l0ZXJhYmxlJztcbmNvbnN0IHRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEgPSBnb29nLmZvcndhcmREZWNsYXJlKFwiX1VzZXJzLnB0YXlsb3IuZGV2Lml4anMuc3JjLmFzeW5jaXRlcmFibGVcIik7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmNsYXNzIEJ1ZmZlckFzeW5jSXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUU291cmNlW10+IHtcbnByaXZhdGUgX3NvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPjtcbnByaXZhdGUgX2NvdW50OiBudW1iZXI7XG5wcml2YXRlIF9za2lwOiBudW1iZXI7XG4vKipcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2tpcFxuICovXG5jb25zdHJ1Y3RvcihcbiAgICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICAgIGNvdW50OiBudW1iZXIsXG4gICAgICBza2lwOiBudW1iZXIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgdGhpcy5fc2tpcCA9IHNraXA7XG4gIH1cbi8qKlxuICogQHJldHVybiB7IUFzeW5jSXRlcmFibGVJdGVyYXRvcjwhQXJyYXk8VFNvdXJjZT4+fVxuICovXG5hc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcblxuICAgIGxldCAvKiogQHR5cGUgeyFBcnJheTwhQXJyYXk8VFNvdXJjZT4+fSAqLyBidWZmZXJzOiBUU291cmNlW11bXSA9IFtdLCAvKiogQHR5cGUge251bWJlcn0gKi8gIGkgPSAwO1xuICAgIGZvciBhd2FpdCAobGV0IC8qKiBAdHlwZSB7VFNvdXJjZX0gKi8gaXRlbSBvZiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChpICUgdGhpcy5fc2tpcCA9PT0gMCkge1xuICAgICAgICBidWZmZXJzLnB1c2goW10pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCAvKiogQHR5cGUgeyFBcnJheTxUU291cmNlPn0gKi8gYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+IDAgJiYgYnVmZmVyc1swXS5sZW5ndGggPT09IHRoaXMuX2NvdW50KSB7XG4gICAgICAgIHlpZWxkIC8qKiBAdHlwZSB7IUFycmF5PFRTb3VyY2U+fSAqLygoIGJ1ZmZlcnMuc2hpZnQoKSkpO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgd2hpbGUgKGJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgeWllbGQgLyoqIEB0eXBlIHshQXJyYXk8VFNvdXJjZT59ICovKCggYnVmZmVycy5zaGlmdCgpKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckFzeW5jSXRlcmFibGVfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59ICovXG5CdWZmZXJBc3luY0l0ZXJhYmxlLnByb3RvdHlwZS5fc291cmNlO1xuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5CdWZmZXJBc3luY0l0ZXJhYmxlLnByb3RvdHlwZS5fY291bnQ7XG4vKiogQHR5cGUge251bWJlcn0gKi9cbkJ1ZmZlckFzeW5jSXRlcmFibGUucHJvdG90eXBlLl9za2lwO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtudW1iZXI9fSBza2lwXG4gKiBAcmV0dXJuIHshdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMS5Bc3luY0l0ZXJhYmxlWDwhQXJyYXk8VFNvdXJjZT4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyPFRTb3VyY2U+KFxuICAgIHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIHNraXA/OiBudW1iZXIpOiBBc3luY0l0ZXJhYmxlWDxUU291cmNlW10+IHtcbiAgaWYgKHNraXAgPT0gbnVsbCkgeyBza2lwID0gY291bnQ7IH1cbiAgcmV0dXJuIG5ldyBCdWZmZXJBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSwgY291bnQsIHNraXApO1xufVxuIl19