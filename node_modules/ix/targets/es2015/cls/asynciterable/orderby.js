goog.module('targets.es2015.cls.asynciterable.orderby'); exports = {}; var module = {id: 'targets/es2015/cls/asynciterable/orderby.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.es2015.cls.asynciterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
var toarray_1 = goog.require('targets.es2015.cls.asynciterable.toarray');
const tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable.toarray");
var sorter_1 = goog.require('targets.es2015.cls.internal.sorter');
const tsickle_forward_declare_3 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.internal.sorter");
/**
 * @abstract
 * @template TSource
 */
class OrderedAsyncIterableBaseX extends asynciterable_1.AsyncIterableX {
    /**
     * @param {!AsyncIterable<TSource>} source
     */
    constructor(source) {
        super();
        this._source = source;
    }
    /**
     * @return {!AsyncIterableIterator<TSource>}
     */
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            const /** @type {!Array<TSource>} */ array = yield __await(toarray_1.toArray(this._source));
            const /** @type {number} */ len = array.length;
            const /** @type {!Array<number>} */ indices = new Array(len);
            for (let /** @type {number} */ i = 0, /** @type {number} */ len = array.length; i < len; i++) {
                indices[i] = i;
            }
            indices.sort(this._getSorter(array));
            for (const /** @type {number} */ index of indices) {
                yield array[index];
            }
        });
    }
    /**
     * @template TKey
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number=} comparer
     * @return {!OrderedAsyncIterableBaseX}
     */
    thenBy(keySelector, comparer = sorter_1.sorter) {
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedAsyncIterableX(this._source, keySelector, comparer, false, this);
    }
    /**
     * @template TKey
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number=} comparer
     * @return {!OrderedAsyncIterableBaseX}
     */
    thenByDescending(keySelector, comparer = sorter_1.sorter) {
        /* tslint:disable-next-line: no-use-before-declare */
        return new OrderedAsyncIterableX(this._source, keySelector, comparer, true, this);
    }
}
exports.OrderedAsyncIterableBaseX = OrderedAsyncIterableBaseX;
function OrderedAsyncIterableBaseX_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TSource>} */
    OrderedAsyncIterableBaseX.prototype._source;
    /**
     * @abstract
     * @param {!Array<TSource>} elements
     * @param {function(number, number): number=} next
     * @return {function(number, number): number}
     */
    OrderedAsyncIterableBaseX.prototype._getSorter = function (elements, next) { };
}
/**
 * @template TKey, TSource
 */
class OrderedAsyncIterableX extends OrderedAsyncIterableBaseX {
    /**
     * @param {!AsyncIterable<TSource>} source
     * @param {function(TSource): TKey} keySelector
     * @param {function(TKey, TKey): number} comparer
     * @param {boolean} descending
     * @param {!OrderedAsyncIterableBaseX<TSource>=} parent
     */
    constructor(source, keySelector, comparer, descending, parent) {
        super(source);
        this._keySelector = keySelector;
        this._comparer = comparer;
        this._descending = descending;
        this._parent = parent;
    }
    /**
     * @param {!Array<TSource>} elements
     * @param {function(number, number): number=} next
     * @return {function(number, number): number}
     */
    _getSorter(elements, next) {
        const /** @type {!Array<TKey>} */ keys = elements.map(this._keySelector);
        const /** @type {function(TKey, TKey): number} */ comparer = this._comparer;
        const /** @type {!OrderedAsyncIterableBaseX<TSource>} */ parent = this._parent;
        const /** @type {boolean} */ descending = this._descending;
        const /** @type {function(number, number): number} */ sorter = (x, y) => {
            const /** @type {number} */ result = comparer(keys[x], keys[y]);
            if (result === 0) {
                return next ? next(x, y) : x - y;
            }
            return descending ? -result : result;
        };
        return parent ? parent._getSorter(elements, sorter) : sorter;
    }
}
exports.OrderedAsyncIterableX = OrderedAsyncIterableX;
function OrderedAsyncIterableX_tsickle_Closure_declarations() {
    /** @type {function(TSource): TKey} */
    OrderedAsyncIterableX.prototype._keySelector;
    /** @type {function(TKey, TKey): number} */
    OrderedAsyncIterableX.prototype._comparer;
    /** @type {boolean} */
    OrderedAsyncIterableX.prototype._descending;
    /** @type {!OrderedAsyncIterableBaseX<TSource>} */
    OrderedAsyncIterableX.prototype._parent;
}
/**
 * @template TKey, TSource
 * @param {!AsyncIterable<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function orderBy(source, keySelector, comparer = sorter_1.sorter) {
    return new OrderedAsyncIterableX(source, keySelector, comparer, false);
}
exports.orderBy = orderBy;
/**
 * @template TKey, TSource
 * @param {!AsyncIterable<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function orderByDescending(source, keySelector, comparer = sorter_1.sorter) {
    return new OrderedAsyncIterableX(source, keySelector, comparer, true);
}
exports.orderByDescending = orderByDescending;
/**
 * @template TKey, TSource
 * @param {!OrderedAsyncIterableBaseX<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function thenBy(source, keySelector, comparer = sorter_1.sorter) {
    return new OrderedAsyncIterableX(source._source, keySelector, comparer, false, source);
}
exports.thenBy = thenBy;
/**
 * @template TKey, TSource
 * @param {!OrderedAsyncIterableBaseX<TSource>} source
 * @param {function(TSource): TKey} keySelector
 * @param {function(TKey, TKey): number=} comparer
 * @return {!OrderedAsyncIterableX<TKey, TSource>}
 */
function thenByDescending(source, keySelector, comparer = sorter_1.sorter) {
    return new OrderedAsyncIterableX(source._source, keySelector, comparer, true, source);
}
exports.thenByDescending = thenByDescending;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL29yZGVyYnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILG9EQUx1QjtBQU12QixNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsMkNBQTJDLENBQUMsQ0FOaEQ7QUFPbEQsdUNBTmdCO0FBT2hCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtREFBbUQsQ0FBQyxDQVB0RTtBQVFwQywrQ0FQZ0M7QUFRaEMsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7QUFDckc7OztHQUdHO0FBVkgsK0JBQXdELFNBQVEsOEJBQXdCO0lBYXhGOztPQUVHO0lBWkQsWUFBWSxNQUE4QjtRQWN4QyxLQWJLLEVBQUUsQ0FBQztRQWNSLElBYkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO0lBY3hCLENBQUM7SUFDSDs7T0FFRztJQWRNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQzs7WUFnQjNCLE1BQU0sOEJBZkQsQ0FBQSxLQUFNLEdBQUUsY0FBTSxpQkFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQSxDQUFDO1lBZ0IxQyxNQUFNLHFCQWZELENBQUEsR0FBSSxHQUFFLEtBQU0sQ0FBQyxNQUFNLENBQUM7WUFnQnpCLE1BQU0sNkJBZkQsQ0FBQSxPQUFRLEdBQUUsSUFBSSxLQUFNLENBQVMsR0FBRyxDQUFDLENBQUM7WUFnQnZDLEdBQUcsQ0FBQyxDQWZDLElBQUEscUJBQUcsQ0FBQSxDQUFFLEdBQUUsQ0FBRSxFQUFBLHFCQUFDLENBQUEsR0FBSSxHQUFFLEtBQU0sQ0FBQyxNQUFNLEVBQUMsQ0FBRSxHQUFFLEdBQUksRUFBQyxDQUFFLEVBQUUsRUFBQyxDQUFFO2dCQWdCakQsT0FmTyxDQUFDLENBQUMsQ0FBQyxHQUFFLENBQUUsQ0FBQztZQWdCakIsQ0FmQztZQWlCRCxPQWZPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQWdCckMsR0FBRyxDQUFDLENBZkMsTUFBQSxxQkFBSyxDQUFBLEtBQU0sSUFBRyxPQUFRLENBQUMsQ0FBQSxDQUFFO2dCQWdCNUIsTUFmSyxLQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFnQnJCLENBZkM7UUFnQkgsQ0FBQztLQUFBO0lBQ0g7Ozs7O09BS0c7SUFuQkQsTUFBTSxDQXFCRixXQXBCb0MsRUFxQnBDLFdBcEI0QyxlQUFjO1FBcUI1RCxxREFBcUQ7UUFDckQsTUFwQk0sQ0FBQSxJQUFJLHFCQUFzQixDQUFnQixJQUFJLENBQUMsT0FBTyxFQUFDLFdBQVksRUFBQyxRQUFTLEVBQUMsS0FBTSxFQUFDLElBQUssQ0FBQyxDQUFDO0lBcUJwRyxDQUFDO0lBQ0g7Ozs7O09BS0c7SUF4QkQsZ0JBQWdCLENBMEJaLFdBekJvQyxFQTBCcEMsV0F6QjRDLGVBQWM7UUEwQjVELHFEQUFxRDtRQUNyRCxNQXpCTSxDQUFBLElBQUkscUJBQXNCLENBQWdCLElBQUksQ0FBQyxPQUFPLEVBQUMsV0FBWSxFQUFDLFFBQVMsRUFBQyxJQUFLLEVBQUMsSUFBSyxDQUFDLENBQUM7SUEwQm5HLENBekJDO0NBS0g7QUF2Q0EsOERBdUNBO0FBMkJBO0lBQ0Esc0NBQXNDO0lBQ3RDLHlCQUF5QixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFFNUM7Ozs7O09BS0c7SUFDSCx5QkFBeUIsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVMsUUFBUSxFQUFFLElBQUksSUFBRyxDQUFDLENBQUM7QUFDN0UsQ0FBQztBQUVEOztHQUVHO0FBeENILDJCQUFpRCxTQUFRLHlCQUFtQztJQThDNUY7Ozs7OztPQU1HO0lBOUNELFlBZ0RJLE1BL0M4QixFQWdEOUIsV0EvQ29DLEVBZ0RwQyxRQS9DMEMsRUFnRDFDLFVBL0NtQixFQWdEbkIsTUEvQzJDO1FBZ0Q3QyxLQS9DSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBZ0RkLElBL0NJLENBQUMsWUFBWSxHQUFFLFdBQVksQ0FBQztRQWdEaEMsSUEvQ0ksQ0FBQyxTQUFTLEdBQUUsUUFBUyxDQUFDO1FBZ0QxQixJQS9DSSxDQUFDLFdBQVcsR0FBRSxVQUFXLENBQUM7UUFnRDlCLElBL0NJLENBQUMsT0FBTyxHQUFFLE1BQU8sQ0FBQztJQWdEeEIsQ0FBQztJQUNIOzs7O09BSUc7SUFsREQsVUFBVSxDQW9ETixRQW5EbUIsRUFvRG5CLElBbkR1QztRQW9EekMsTUFBTSwyQkFuREQsQ0FBQSxJQUFLLEdBQUUsUUFBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFvRDdDLE1BQU0sMkNBbkRELENBQUEsUUFBUyxHQUFFLElBQUssQ0FBQyxTQUFTLENBQUM7UUFvRGhDLE1BQU0sa0RBbkRELENBQUEsTUFBTyxHQUFFLElBQUssQ0FBQyxPQUFPLENBQUM7UUFvRDVCLE1BQU0sc0JBbkRELENBQUEsVUFBVyxHQUFFLElBQUssQ0FBQyxXQUFXLENBQUM7UUFvRHBDLE1BQU0sK0NBbkRELENBQUEsTUFBTyxHQUFFLENBQUUsQ0FBUyxFQUFDLENBQVU7WUFvRGxDLE1BQU0scUJBbkRELENBQUEsTUFBTyxHQUFFLFFBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUMsSUFBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFvRDFDLEVBQUUsQ0FBQyxDQW5EQyxNQUFNLEtBQUksQ0FBRSxDQUFDLENBQUEsQ0FBRTtnQkFvRGpCLE1BbkRNLENBQUEsSUFBSyxHQUFFLElBQUssQ0FBQyxDQUFDLEVBQUMsQ0FBRSxDQUFDLEdBQUUsQ0FBRSxHQUFFLENBQUUsQ0FBQztZQW9EbkMsQ0FuREM7WUFxREQsTUFuRE0sQ0FBQSxVQUFXLEdBQUUsQ0FBRSxNQUFNLEdBQUUsTUFBTyxDQUFDO1FBb0R2QyxDQW5EQyxDQUFDO1FBcURGLE1BbkRNLENBQUEsTUFBTyxHQUFFLE1BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFDLE1BQU8sQ0FBQyxHQUFFLE1BQU8sQ0FBQztJQW9EL0QsQ0FuREM7Q0FDSDtBQXJDQSxzREFxQ0E7QUFxREE7SUFDQSxzQ0FBc0M7SUFDdEMscUJBQXFCLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQztJQUM3QywyQ0FBMkM7SUFDM0MscUJBQXFCLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQztJQUMxQyxzQkFBc0I7SUFDdEIscUJBQXFCLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztJQUM1QyxrREFBa0Q7SUFDbEQscUJBQXFCLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztBQUN4QyxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBcEVILGlCQXNFTSxNQXJFOEIsRUFzRTlCLFdBckVvQyxFQXNFcEMsV0FyRTRDLGVBQWM7SUFzRTlELE1BckVNLENBQUEsSUFBSSxxQkFBc0IsQ0FBZ0IsTUFBTSxFQUFDLFdBQVksRUFBQyxRQUFTLEVBQUMsS0FBTSxDQUFDLENBQUM7QUFzRXhGLENBQUM7QUExRUQsMEJBMEVDO0FBQ0Q7Ozs7OztHQU1HO0FBMUVILDJCQTRFTSxNQTNFOEIsRUE0RTlCLFdBM0VvQyxFQTRFcEMsV0EzRTRDLGVBQWM7SUE0RTlELE1BM0VNLENBQUEsSUFBSSxxQkFBc0IsQ0FBZ0IsTUFBTSxFQUFDLFdBQVksRUFBQyxRQUFTLEVBQUMsSUFBSyxDQUFDLENBQUM7QUE0RXZGLENBQUM7QUFoRkQsOENBZ0ZDO0FBQ0Q7Ozs7OztHQU1HO0FBaEZILGdCQWtGTSxNQWpGMEMsRUFrRjFDLFdBakZvQyxFQWtGcEMsV0FqRjRDLGVBQWM7SUFrRjlELE1BakZNLENBQUEsSUFBSSxxQkFBc0IsQ0FBZ0IsTUFBTSxDQUFDLE9BQU8sRUFBQyxXQUFZLEVBQUMsUUFBUyxFQUFDLEtBQU0sRUFBQyxNQUFPLENBQUMsQ0FBQztBQWtGeEcsQ0FBQztBQXRGRCx3QkFzRkM7QUFDRDs7Ozs7O0dBTUc7QUF0RkgsMEJBd0ZNLE1BdkYwQyxFQXdGMUMsV0F2Rm9DLEVBd0ZwQyxXQXZGNEMsZUFBYztJQXdGOUQsTUF2Rk0sQ0FBQSxJQUFJLHFCQUFzQixDQUFnQixNQUFNLENBQUMsT0FBTyxFQUFDLFdBQVksRUFBQyxRQUFTLEVBQUMsSUFBSyxFQUFDLE1BQU8sQ0FBQyxDQUFDO0FBd0Z2RyxDQXZGQztBQUxELDRDQUtDIiwiZmlsZSI6Im9yZGVyYnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuYXN5bmNpdGVyYWJsZVwiKTtcbmltcG9ydCB7IHRvQXJyYXkgfSBmcm9tICcuL3RvYXJyYXknO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMiA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuYXN5bmNpdGVyYWJsZS50b2FycmF5XCIpO1xuaW1wb3J0IHsgc29ydGVyIGFzIGRlZmF1bHRTb3J0ZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9zb3J0ZXInO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMyA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaW50ZXJuYWwuc29ydGVyXCIpO1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+IGV4dGVuZHMgQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBfc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+O1xuLyoqXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqL1xuY29uc3RydWN0b3Ioc291cmNlOiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gIH1cbi8qKlxuICogQHJldHVybiB7IUFzeW5jSXRlcmFibGVJdGVyYXRvcjxUU291cmNlPn1cbiAqL1xuYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgLyoqIEB0eXBlIHshQXJyYXk8VFNvdXJjZT59ICovIGFycmF5ID0gYXdhaXQgdG9BcnJheSh0aGlzLl9zb3VyY2UpO1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3QgLyoqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn0gKi8gaW5kaWNlcyA9IG5ldyBBcnJheTxudW1iZXI+KGxlbik7XG4gICAgZm9yIChsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGkgPSAwLCAvKiogQHR5cGUge251bWJlcn0gKi8gbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGluZGljZXNbaV0gPSBpO1xuICAgIH1cblxuICAgIGluZGljZXMuc29ydCh0aGlzLl9nZXRTb3J0ZXIoYXJyYXkpKTtcbiAgICBmb3IgKGNvbnN0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBpbmRleCBvZiBpbmRpY2VzKSB7XG4gICAgICB5aWVsZCBhcnJheVtpbmRleF07XG4gICAgfVxuICB9XG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSBrZXlTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyPX0gY29tcGFyZXJcbiAqIEByZXR1cm4geyFPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYfVxuICovXG50aGVuQnk8VEtleT4oXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPiB7XG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11c2UtYmVmb3JlLWRlY2xhcmUgKi9cbiAgICByZXR1cm4gbmV3IE9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPih0aGlzLl9zb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgZmFsc2UsIHRoaXMpO1xuICB9XG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSBrZXlTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyPX0gY29tcGFyZXJcbiAqIEByZXR1cm4geyFPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYfVxuICovXG50aGVuQnlEZXNjZW5kaW5nPFRLZXk+KFxuICAgICAga2V5U2VsZWN0b3I6IChpdGVtOiBUU291cmNlKSA9PiBUS2V5LFxuICAgICAgY29tcGFyZXI6IChmc3Q6IFRLZXksIHNuZDogVEtleSkgPT4gbnVtYmVyID0gZGVmYXVsdFNvcnRlcik6IE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4ge1xuICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4odGhpcy5fc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIHRydWUsIHRoaXMpO1xuICB9XG5cbiAgYWJzdHJhY3QgX2dldFNvcnRlcihcbiAgICBlbGVtZW50czogVFNvdXJjZVtdLFxuICAgIG5leHQ/OiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IG51bWJlcik6ICh4OiBudW1iZXIsIHk6IG51bWJlcikgPT4gbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUgeyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSAqL1xuT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWC5wcm90b3R5cGUuX3NvdXJjZTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7IUFycmF5PFRTb3VyY2U+fSBlbGVtZW50c1xuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6IG51bWJlcj19IG5leHRcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogbnVtYmVyfVxuICovXG5PcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYLnByb3RvdHlwZS5fZ2V0U29ydGVyID0gZnVuY3Rpb24oZWxlbWVudHMsIG5leHQpIHt9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5LCBUU291cmNlXG4gKi9cbmV4cG9ydCBjbGFzcyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4gZXh0ZW5kcyBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+IHtcbnByaXZhdGUgX2tleVNlbGVjdG9yOiAoaXRlbTogVFNvdXJjZSkgPT4gVEtleTtcbnByaXZhdGUgX2NvbXBhcmVyOiAoZnN0OiBUS2V5LCBzbmQ6IFRLZXkpID0+IG51bWJlcjtcbnByaXZhdGUgX2Rlc2NlbmRpbmc6IGJvb2xlYW47XG5wcml2YXRlIF9wYXJlbnQ/OiBPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+O1xuLyoqXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXJ9IGNvbXBhcmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlc2NlbmRpbmdcbiAqIEBwYXJhbSB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT49fSBwYXJlbnRcbiAqL1xuY29uc3RydWN0b3IoXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIsXG4gICAgICBkZXNjZW5kaW5nOiBib29sZWFuLFxuICAgICAgcGFyZW50PzogT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPikge1xuICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgdGhpcy5fa2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICB0aGlzLl9jb21wYXJlciA9IGNvbXBhcmVyO1xuICAgIHRoaXMuX2Rlc2NlbmRpbmcgPSBkZXNjZW5kaW5nO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgfVxuLyoqXG4gKiBAcGFyYW0geyFBcnJheTxUU291cmNlPn0gZWxlbWVudHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiBudW1iZXI9fSBuZXh0XG4gKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6IG51bWJlcn1cbiAqL1xuX2dldFNvcnRlcihcbiAgICAgIGVsZW1lbnRzOiBUU291cmNlW10sXG4gICAgICBuZXh0PzogKHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiBudW1iZXIpOiAoeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IG51bWJlciB7XG4gICAgY29uc3QgLyoqIEB0eXBlIHshQXJyYXk8VEtleT59ICovIGtleXMgPSBlbGVtZW50cy5tYXAodGhpcy5fa2V5U2VsZWN0b3IpO1xuICAgIGNvbnN0IC8qKiBAdHlwZSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcn0gKi8gY29tcGFyZXIgPSB0aGlzLl9jb21wYXJlcjtcbiAgICBjb25zdCAvKiogQHR5cGUgeyFPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+fSAqLyBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgY29uc3QgLyoqIEB0eXBlIHtib29sZWFufSAqLyBkZXNjZW5kaW5nID0gdGhpcy5fZGVzY2VuZGluZztcbiAgICBjb25zdCAvKiogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogbnVtYmVyfSAqLyBzb3J0ZXIgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgY29uc3QgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHJlc3VsdCA9IGNvbXBhcmVyKGtleXNbeF0sIGtleXNbeV0pO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV4dCA/IG5leHQoeCwgeSkgOiB4IC0geTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2NlbmRpbmcgPyAtcmVzdWx0IDogcmVzdWx0O1xuICAgIH07XG5cbiAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50Ll9nZXRTb3J0ZXIoZWxlbWVudHMsIHNvcnRlcikgOiBzb3J0ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gT3JkZXJlZEFzeW5jSXRlcmFibGVYX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSAqL1xuT3JkZXJlZEFzeW5jSXRlcmFibGVYLnByb3RvdHlwZS5fa2V5U2VsZWN0b3I7XG4vKiogQHR5cGUge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXJ9ICovXG5PcmRlcmVkQXN5bmNJdGVyYWJsZVgucHJvdG90eXBlLl9jb21wYXJlcjtcbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbk9yZGVyZWRBc3luY0l0ZXJhYmxlWC5wcm90b3R5cGUuX2Rlc2NlbmRpbmc7XG4vKiogQHR5cGUgeyFPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+fSAqL1xuT3JkZXJlZEFzeW5jSXRlcmFibGVYLnByb3RvdHlwZS5fcGFyZW50O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5LCBUU291cmNlXG4gKiBAcGFyYW0geyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yZGVyQnk8VEtleSwgVFNvdXJjZT4oXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIGZhbHNlKTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRLZXksIFRTb3VyY2VcbiAqIEBwYXJhbSB7IUFzeW5jSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbihUU291cmNlKTogVEtleX0ga2V5U2VsZWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVEtleSwgVEtleSk6IG51bWJlcj19IGNvbXBhcmVyXG4gKiBAcmV0dXJuIHshT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JkZXJCeURlc2NlbmRpbmc8VEtleSwgVFNvdXJjZT4oXG4gICAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIsIHRydWUpO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVEtleSwgVFNvdXJjZVxuICogQHBhcmFtIHshT3JkZXJlZEFzeW5jSXRlcmFibGVCYXNlWDxUU291cmNlPn0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRTb3VyY2UpOiBUS2V5fSBrZXlTZWxlY3RvclxuICogQHBhcmFtIHtmdW5jdGlvbihUS2V5LCBUS2V5KTogbnVtYmVyPX0gY29tcGFyZXJcbiAqIEByZXR1cm4geyFPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aGVuQnk8VEtleSwgVFNvdXJjZT4oXG4gICAgICBzb3VyY2U6IE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4oc291cmNlLl9zb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgZmFsc2UsIHNvdXJjZSk7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUS2V5LCBUU291cmNlXG4gKiBAcGFyYW0geyFPcmRlcmVkQXN5bmNJdGVyYWJsZUJhc2VYPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVFNvdXJjZSk6IFRLZXl9IGtleVNlbGVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRLZXksIFRLZXkpOiBudW1iZXI9fSBjb21wYXJlclxuICogQHJldHVybiB7IU9yZGVyZWRBc3luY0l0ZXJhYmxlWDxUS2V5LCBUU291cmNlPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRoZW5CeURlc2NlbmRpbmc8VEtleSwgVFNvdXJjZT4oXG4gICAgICBzb3VyY2U6IE9yZGVyZWRBc3luY0l0ZXJhYmxlQmFzZVg8VFNvdXJjZT4sXG4gICAgICBrZXlTZWxlY3RvcjogKGl0ZW06IFRTb3VyY2UpID0+IFRLZXksXG4gICAgICBjb21wYXJlcjogKGZzdDogVEtleSwgc25kOiBUS2V5KSA9PiBudW1iZXIgPSBkZWZhdWx0U29ydGVyKTogT3JkZXJlZEFzeW5jSXRlcmFibGVYPFRLZXksIFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBPcmRlcmVkQXN5bmNJdGVyYWJsZVg8VEtleSwgVFNvdXJjZT4oc291cmNlLl9zb3VyY2UsIGtleVNlbGVjdG9yLCBjb21wYXJlciwgdHJ1ZSwgc291cmNlKTtcbn1cbiJdfQ==