import { defer } from './defer';
import { empty } from './empty';
/**
 * Returns a sequence from a dictionary based on the result of evaluating a selector function.
 * @example
 * const map = new Map([
 *   [1, [1, 2, 3]],
 *   [2, [2, 3, 4]],
 *   [3, [4, 5, 6]]
 * ]);
 * const result = case(
 *   () => 2,
 *   map,
 *   [5, 6, 7]
 * );
 * const result = Ix.Iterable.case(
 *   () => 2,
 *   map,
 *   [5, 6, 7]
 * );
 * for (const item of result) {
 *   console.log(result);
 * }
 * @param {function(): TSource} selector Selector function used to pick a sequence from the given sources.
 * @param {Map<TSource, Iterable<TResult>>} sources Dictionary mapping selector values onto resulting sequences.
 * @param {Iterable<TResult>} [defaultSource] Default sequence to return in case there's no corresponding source
 * for the computed selector value.  If not specified, defaults to an empty sequence.
 * @return {Iterable<TResult>} The source sequence corresponding with the evaluated selector value; otherwise, the default source.
 */
export function _case(selector, sources, defaultSource = empty()) {
    return defer(() => {
        const key = selector();
        return sources.has(key) ? sources.get(key) : defaultSource;
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2Nhc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBCRztBQUNILE1BQU0sZ0JBQ0YsUUFBdUIsRUFDdkIsT0FBd0MsRUFDeEMsZ0JBQW1DLEtBQUssRUFBVztJQUNyRCxNQUFNLENBQUMsS0FBSyxDQUFVO1FBQ3BCLE1BQU0sR0FBRyxHQUFHLFFBQVEsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFFLEdBQUcsYUFBYSxDQUFDO0lBQzlELENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsImZpbGUiOiJpdGVyYWJsZS9jYXNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuaW1wb3J0IHsgZGVmZXIgfSBmcm9tICcuL2RlZmVyJztcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAnLi9lbXB0eSc7XG5cbi8qKlxuICogUmV0dXJucyBhIHNlcXVlbmNlIGZyb20gYSBkaWN0aW9uYXJ5IGJhc2VkIG9uIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhIHNlbGVjdG9yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1xuICogICBbMSwgWzEsIDIsIDNdXSxcbiAqICAgWzIsIFsyLCAzLCA0XV0sXG4gKiAgIFszLCBbNCwgNSwgNl1dXG4gKiBdKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGNhc2UoXG4gKiAgICgpID0+IDIsXG4gKiAgIG1hcCxcbiAqICAgWzUsIDYsIDddXG4gKiApO1xuICogY29uc3QgcmVzdWx0ID0gSXguSXRlcmFibGUuY2FzZShcbiAqICAgKCkgPT4gMixcbiAqICAgbWFwLFxuICogICBbNSwgNiwgN11cbiAqICk7XG4gKiBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IFRTb3VyY2V9IHNlbGVjdG9yIFNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gcGljayBhIHNlcXVlbmNlIGZyb20gdGhlIGdpdmVuIHNvdXJjZXMuXG4gKiBAcGFyYW0ge01hcDxUU291cmNlLCBJdGVyYWJsZTxUUmVzdWx0Pj59IHNvdXJjZXMgRGljdGlvbmFyeSBtYXBwaW5nIHNlbGVjdG9yIHZhbHVlcyBvbnRvIHJlc3VsdGluZyBzZXF1ZW5jZXMuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFRSZXN1bHQ+fSBbZGVmYXVsdFNvdXJjZV0gRGVmYXVsdCBzZXF1ZW5jZSB0byByZXR1cm4gaW4gY2FzZSB0aGVyZSdzIG5vIGNvcnJlc3BvbmRpbmcgc291cmNlXG4gKiBmb3IgdGhlIGNvbXB1dGVkIHNlbGVjdG9yIHZhbHVlLiAgSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gYW4gZW1wdHkgc2VxdWVuY2UuXG4gKiBAcmV0dXJuIHtJdGVyYWJsZTxUUmVzdWx0Pn0gVGhlIHNvdXJjZSBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHdpdGggdGhlIGV2YWx1YXRlZCBzZWxlY3RvciB2YWx1ZTsgb3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCBzb3VyY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2FzZTxUU291cmNlLCBUUmVzdWx0PihcbiAgICBzZWxlY3RvcjogKCkgPT4gVFNvdXJjZSxcbiAgICBzb3VyY2VzOiBNYXA8VFNvdXJjZSwgSXRlcmFibGU8VFJlc3VsdD4+LFxuICAgIGRlZmF1bHRTb3VyY2U6IEl0ZXJhYmxlPFRSZXN1bHQ+ID0gZW1wdHk8VFJlc3VsdD4oKSk6IEl0ZXJhYmxlWDxUUmVzdWx0PiB7XG4gIHJldHVybiBkZWZlcjxUUmVzdWx0PigoKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0b3IoKTtcbiAgICByZXR1cm4gc291cmNlcy5oYXMoa2V5KSA/IHNvdXJjZXMuZ2V0KGtleSkhIDogZGVmYXVsdFNvdXJjZTtcbiAgfSk7XG59XG4iXX0=
