import { IterableX } from '../iterable';
import { arrayIndexOf } from '../internal/arrayindexof';
import { comparer as defaultComparer } from '../internal/comparer';
class ExceptIterable extends IterableX {
    constructor(first, second, comparer) {
        super();
        this._first = first;
        this._second = second;
        this._comparer = comparer;
    }
    *[Symbol.iterator]() {
        let map = [];
        for (let secondItem of this._second) {
            map.push(secondItem);
        }
        for (let firstItem of this._first) {
            if (arrayIndexOf(map, firstItem, this._comparer) === -1) {
                map.push(firstItem);
                yield firstItem;
            }
        }
    }
}
/**
 * Produces the set difference of two sequences by using the an equality comparer to compare values.
 * @param {Iterable<T>} first A sequence whose elements that are not also in second will be returned.
 * @param {Iterable<T>} second A sequence whose elements that also occur in the first sequence will cause those
 * elements to be removed from the returned sequence.
 * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.
 * @return {Iterable<T>} A sequence that contains the set difference of the elements of two sequences.
 */
export function except(first, second, comparer = defaultComparer) {
    return new ExceptIterable(first, second, comparer);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2V4Y2VwdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsUUFBUSxJQUFJLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRW5FLG9CQUE4QixTQUFRLFNBQWtCO0lBS3RELFlBQVksS0FBd0IsRUFBRSxNQUF5QixFQUFFLFFBQTZDO1FBQzVHLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7SUFDNUIsQ0FBQztJQUVELENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBQ2hCLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztRQUNiLEdBQUcsQ0FBQyxDQUFDLElBQUksVUFBVSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkIsQ0FBQztRQUVELEdBQUcsQ0FBQyxDQUFDLElBQUksU0FBUyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hELEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3BCLE1BQU0sU0FBUyxDQUFDO1lBQ2xCLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0saUJBQ0YsS0FBd0IsRUFDeEIsTUFBeUIsRUFDekIsV0FBZ0QsZUFBZTtJQUNqRSxNQUFNLENBQUMsSUFBSSxjQUFjLENBQVUsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUM5RCxDQUFDIiwiZmlsZSI6Iml0ZXJhYmxlL2V4Y2VwdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZXJhYmxlWCB9IGZyb20gJy4uL2l0ZXJhYmxlJztcbmltcG9ydCB7IGFycmF5SW5kZXhPZiB9IGZyb20gJy4uL2ludGVybmFsL2FycmF5aW5kZXhvZic7XG5pbXBvcnQgeyBjb21wYXJlciBhcyBkZWZhdWx0Q29tcGFyZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9jb21wYXJlcic7XG5cbmNsYXNzIEV4Y2VwdEl0ZXJhYmxlPFRTb3VyY2U+IGV4dGVuZHMgSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcHJpdmF0ZSBfZmlyc3Q6IEl0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9zZWNvbmQ6IEl0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9jb21wYXJlcjogKHg6IFRTb3VyY2UsIHk6IFRTb3VyY2UpID0+IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoZmlyc3Q6IEl0ZXJhYmxlPFRTb3VyY2U+LCBzZWNvbmQ6IEl0ZXJhYmxlPFRTb3VyY2U+LCBjb21wYXJlcjogKHg6IFRTb3VyY2UsIHk6IFRTb3VyY2UpID0+IGJvb2xlYW4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2ZpcnN0ID0gZmlyc3Q7XG4gICAgdGhpcy5fc2Vjb25kID0gc2Vjb25kO1xuICAgIHRoaXMuX2NvbXBhcmVyID0gY29tcGFyZXI7XG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IG1hcCA9IFtdO1xuICAgIGZvciAobGV0IHNlY29uZEl0ZW0gb2YgdGhpcy5fc2Vjb25kKSB7XG4gICAgICBtYXAucHVzaChzZWNvbmRJdGVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBmaXJzdEl0ZW0gb2YgdGhpcy5fZmlyc3QpIHtcbiAgICAgIGlmIChhcnJheUluZGV4T2YobWFwLCBmaXJzdEl0ZW0sIHRoaXMuX2NvbXBhcmVyKSA9PT0gLTEpIHtcbiAgICAgICAgbWFwLnB1c2goZmlyc3RJdGVtKTtcbiAgICAgICAgeWllbGQgZmlyc3RJdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFByb2R1Y2VzIHRoZSBzZXQgZGlmZmVyZW5jZSBvZiB0d28gc2VxdWVuY2VzIGJ5IHVzaW5nIHRoZSBhbiBlcXVhbGl0eSBjb21wYXJlciB0byBjb21wYXJlIHZhbHVlcy5cbiAqIEBwYXJhbSB7SXRlcmFibGU8VD59IGZpcnN0IEEgc2VxdWVuY2Ugd2hvc2UgZWxlbWVudHMgdGhhdCBhcmUgbm90IGFsc28gaW4gc2Vjb25kIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBzZWNvbmQgQSBzZXF1ZW5jZSB3aG9zZSBlbGVtZW50cyB0aGF0IGFsc28gb2NjdXIgaW4gdGhlIGZpcnN0IHNlcXVlbmNlIHdpbGwgY2F1c2UgdGhvc2VcbiAqIGVsZW1lbnRzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgcmV0dXJuZWQgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHg6IFRLZXksIHk6IFRLZXkpOiBib29sZWFufSBbY29tcGFyZXJdIENvbXBhcmVyIHVzZWQgdG8gY29tcGFyZSBrZXkgdmFsdWVzLlxuICogQHJldHVybiB7SXRlcmFibGU8VD59IEEgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgc2V0IGRpZmZlcmVuY2Ugb2YgdGhlIGVsZW1lbnRzIG9mIHR3byBzZXF1ZW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNlcHQ8VFNvdXJjZT4oXG4gICAgZmlyc3Q6IEl0ZXJhYmxlPFRTb3VyY2U+LFxuICAgIHNlY29uZDogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgY29tcGFyZXI6ICh4OiBUU291cmNlLCB5OiBUU291cmNlKSA9PiBib29sZWFuID0gZGVmYXVsdENvbXBhcmVyKTogSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBFeGNlcHRJdGVyYWJsZTxUU291cmNlPihmaXJzdCwgc2Vjb25kLCBjb21wYXJlcik7XG59XG4iXX0=
