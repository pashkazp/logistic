import { IterableX } from '../iterable';
class BufferIterable extends IterableX {
    constructor(source, count, skip) {
        super();
        this._source = source;
        this._count = count;
        this._skip = skip;
    }
    *[Symbol.iterator]() {
        let buffers = [], i = 0;
        for (let item of this._source) {
            if (i % this._skip === 0) {
                buffers.push([]);
            }
            for (let buffer of buffers) {
                buffer.push(item);
            }
            if (buffers.length > 0 && buffers[0].length === this._count) {
                yield buffers.shift();
            }
            i++;
        }
        while (buffers.length > 0) {
            yield buffers.shift();
        }
    }
}
/**
 * Generates a sequence of buffers over the source sequence, with specified length and possible overlap.
 * @example <caption>Creates a sequence of buffers with and without skip</caption>
 * const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
 *
 * // Without skip
 * const result = buffer(source, 5);
 * const result = Ix.Iterable.from(source).buffer(5);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2, 3, 4]
 * // => [5, 6, 7, 8, 9]
 *
 * // With skip
 * const result = buffer(source, 3, 4);
 * const result = Ix.Iterable.from(source).buffer(3, 4);
 * for (const item of result) {
 *   console.log(result);
 * }
 * // => [0, 1, 2]
 * // => [4, 5, 6]
 * // => [8, 9]
 * @param {Iterabel<TSource>} source Source sequence
 * @param {number} count Number of elements for allocated buffers.
 * @param {number} [skip] Number of elements to skip between the start of consecutive buffers. If not specified, defaults
 * to the count.
 * @return {IterableX<TSource>[]} Sequence of buffers containing source sequence elements
 */
export function buffer(source, count, skip) {
    if (skip == null) {
        skip = count;
    }
    return new BufferIterable(source, count, skip);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2J1ZmZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRXhDLG9CQUE4QixTQUFRLFNBQW9CO0lBS3hELFlBQVksTUFBeUIsRUFBRSxLQUFhLEVBQUUsSUFBWTtRQUNoRSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNoQixJQUFJLE9BQU8sR0FBZ0IsRUFBRSxFQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7WUFDOUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNuQixDQUFDO1lBRUQsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDM0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNwQixDQUFDO1lBRUQsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDNUQsTUFBTSxPQUFPLENBQUMsS0FBSyxFQUFHLENBQUM7WUFDekIsQ0FBQztZQUVELENBQUMsRUFBRSxDQUFDO1FBQ04sQ0FBQztRQUVELE9BQU8sT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMxQixNQUFNLE9BQU8sQ0FBQyxLQUFLLEVBQUcsQ0FBQztRQUN6QixDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFDSCxNQUFNLGlCQUNGLE1BQXlCLEVBQ3pCLEtBQWEsRUFDYixJQUFhO0lBQ2YsRUFBRSxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO0lBQUMsQ0FBQztJQUNwQyxNQUFNLENBQUMsSUFBSSxjQUFjLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNoRCxDQUFDIiwiZmlsZSI6Iml0ZXJhYmxlL2J1ZmZlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZXJhYmxlWCB9IGZyb20gJy4uL2l0ZXJhYmxlJztcblxuY2xhc3MgQnVmZmVySXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZVtdPiB7XG4gIHByaXZhdGUgX3NvdXJjZTogSXRlcmFibGU8VFNvdXJjZT47XG4gIHByaXZhdGUgX2NvdW50OiBudW1iZXI7XG4gIHByaXZhdGUgX3NraXA6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LCBjb3VudDogbnVtYmVyLCBza2lwOiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIHRoaXMuX3NraXAgPSBza2lwO1xuICB9XG5cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCBidWZmZXJzOiBUU291cmNlW11bXSA9IFtdLCAgaSA9IDA7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGlmIChpICUgdGhpcy5fc2tpcCA9PT0gMCkge1xuICAgICAgICBidWZmZXJzLnB1c2goW10pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCAmJiBidWZmZXJzWzBdLmxlbmd0aCA9PT0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgeWllbGQgYnVmZmVycy5zaGlmdCgpITtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHdoaWxlIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHlpZWxkIGJ1ZmZlcnMuc2hpZnQoKSE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2VxdWVuY2Ugb2YgYnVmZmVycyBvdmVyIHRoZSBzb3VyY2Ugc2VxdWVuY2UsIHdpdGggc3BlY2lmaWVkIGxlbmd0aCBhbmQgcG9zc2libGUgb3ZlcmxhcC5cbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZXMgYSBzZXF1ZW5jZSBvZiBidWZmZXJzIHdpdGggYW5kIHdpdGhvdXQgc2tpcDwvY2FwdGlvbj5cbiAqIGNvbnN0IHNvdXJjZSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAwXTtcbiAqXG4gKiAvLyBXaXRob3V0IHNraXBcbiAqIGNvbnN0IHJlc3VsdCA9IGJ1ZmZlcihzb3VyY2UsIDUpO1xuICogY29uc3QgcmVzdWx0ID0gSXguSXRlcmFibGUuZnJvbShzb3VyY2UpLmJ1ZmZlcig1KTtcbiAqIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAqICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIH1cbiAqIC8vID0+IFswLCAxLCAyLCAzLCA0XVxuICogLy8gPT4gWzUsIDYsIDcsIDgsIDldXG4gKlxuICogLy8gV2l0aCBza2lwXG4gKiBjb25zdCByZXN1bHQgPSBidWZmZXIoc291cmNlLCAzLCA0KTtcbiAqIGNvbnN0IHJlc3VsdCA9IEl4Lkl0ZXJhYmxlLmZyb20oc291cmNlKS5idWZmZXIoMywgNCk7XG4gKiBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiB9XG4gKiAvLyA9PiBbMCwgMSwgMl1cbiAqIC8vID0+IFs0LCA1LCA2XVxuICogLy8gPT4gWzgsIDldXG4gKiBAcGFyYW0ge0l0ZXJhYmVsPFRTb3VyY2U+fSBzb3VyY2UgU291cmNlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgTnVtYmVyIG9mIGVsZW1lbnRzIGZvciBhbGxvY2F0ZWQgYnVmZmVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpcF0gTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYmV0d2VlbiB0aGUgc3RhcnQgb2YgY29uc2VjdXRpdmUgYnVmZmVycy4gSWYgbm90IHNwZWNpZmllZCwgZGVmYXVsdHNcbiAqIHRvIHRoZSBjb3VudC5cbiAqIEByZXR1cm4ge0l0ZXJhYmxlWDxUU291cmNlPltdfSBTZXF1ZW5jZSBvZiBidWZmZXJzIGNvbnRhaW5pbmcgc291cmNlIHNlcXVlbmNlIGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXI8VFNvdXJjZT4oXG4gICAgc291cmNlOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIHNraXA/OiBudW1iZXIpOiBJdGVyYWJsZVg8VFNvdXJjZVtdPiB7XG4gIGlmIChza2lwID09IG51bGwpIHsgc2tpcCA9IGNvdW50OyB9XG4gcmV0dXJuIG5ldyBCdWZmZXJJdGVyYWJsZShzb3VyY2UsIGNvdW50LCBza2lwKTtcbn1cbiJdfQ==
