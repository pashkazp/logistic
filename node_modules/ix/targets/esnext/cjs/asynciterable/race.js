Object.defineProperty(exports, "__esModule", { value: true });
const asynciterable_1 = require("../asynciterable");
class RaceAsyncIterable extends asynciterable_1.AsyncIterableX {
    constructor(left, right) {
        super();
        this._left = left;
        this._right = right;
    }
    async *[Symbol.asyncIterator]() {
        const leftIt = this._left[Symbol.asyncIterator](), rightIt = this._right[Symbol.asyncIterator]();
        let leftWins = false, rightWins = false;
        const { value, done } = await Promise.race([
            leftIt.next().then(x => { leftWins = true; return x; }),
            rightIt.next().then(x => { rightWins = true; return x; }),
        ]);
        if (!done) {
            yield value;
        }
        let resultIterator, otherIterator;
        if (leftWins) {
            resultIterator = leftIt;
            otherIterator = rightIt;
        }
        else {
            resultIterator = rightIt;
            otherIterator = leftIt;
        }
        // Cancel/finish other iterator
        if (otherIterator.return) {
            await otherIterator.return();
        }
        let next;
        while (!(next = await resultIterator.next()).done) {
            yield next.value;
        }
    }
}
/**
 * Propagates the async sequence that reacts first.
 * @param {AsyncIterable<T>} left First async sequence.
 * @param {AsyncIterable<T>} right Second async sequence.
 * @return {AsyncIterable<T>} An async sequence that surfaces either of the given sequences, whichever reacted first.
 */
function race(left, right) {
    return new RaceAsyncIterable(left, right);
}
exports.race = race;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvcmFjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0RBQWtEO0FBRWxELHVCQUFpQyxTQUFRLDhCQUF1QjtJQUk5RCxZQUFZLElBQTRCLEVBQUUsS0FBNkI7UUFDckUsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQsS0FBSyxFQUFFLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQztRQUMzQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDO1FBQ2pHLElBQUksUUFBUSxHQUFHLEtBQUssRUFBRSxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3hDLE1BQU0sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ3pDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZELE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFELENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNWLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztRQUVELElBQUksY0FBc0MsRUFBRSxhQUFxQyxDQUFDO1FBQ2xGLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixjQUFjLEdBQUcsTUFBTSxDQUFDO1lBQ3hCLGFBQWEsR0FBRyxPQUFPLENBQUM7UUFDMUIsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sY0FBYyxHQUFHLE9BQU8sQ0FBQztZQUN6QixhQUFhLEdBQUcsTUFBTSxDQUFDO1FBQ3pCLENBQUM7UUFFRCwrQkFBK0I7UUFDL0IsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFBQyxNQUFNLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUFDLENBQUM7UUFFM0QsSUFBSSxJQUFJLENBQUM7UUFDVCxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNsRCxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDbkIsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVEOzs7OztHQUtHO0FBQ0gsY0FDSSxJQUE0QixFQUM1QixLQUE2QjtJQUMvQixNQUFNLENBQUMsSUFBSSxpQkFBaUIsQ0FBVSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDckQsQ0FBQztBQUpELG9CQUlDIiwiZmlsZSI6ImFzeW5jaXRlcmFibGUvcmFjZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5cbmNsYXNzIFJhY2VBc3luY0l0ZXJhYmxlPFRTb3VyY2U+IGV4dGVuZHMgQXN5bmNJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBwcml2YXRlIF9sZWZ0OiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9yaWdodDogQXN5bmNJdGVyYWJsZTxUU291cmNlPjtcblxuICBjb25zdHJ1Y3RvcihsZWZ0OiBBc3luY0l0ZXJhYmxlPFRTb3VyY2U+LCByaWdodDogQXN5bmNJdGVyYWJsZTxUU291cmNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgfVxuXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IGxlZnRJdCA9IHRoaXMuX2xlZnRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCksIHJpZ2h0SXQgPSB0aGlzLl9yaWdodFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICBsZXQgbGVmdFdpbnMgPSBmYWxzZSwgcmlnaHRXaW5zID0gZmFsc2U7XG4gICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgIGxlZnRJdC5uZXh0KCkudGhlbih4ID0+IHsgbGVmdFdpbnMgPSB0cnVlOyByZXR1cm4geDsgfSksXG4gICAgICByaWdodEl0Lm5leHQoKS50aGVuKHggPT4geyByaWdodFdpbnMgPSB0cnVlOyByZXR1cm4geDsgfSksXG4gICAgXSk7XG5cbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgIHlpZWxkIHZhbHVlO1xuICAgIH1cblxuICAgIGxldCByZXN1bHRJdGVyYXRvcjogQXN5bmNJdGVyYXRvcjxUU291cmNlPiwgb3RoZXJJdGVyYXRvcjogQXN5bmNJdGVyYXRvcjxUU291cmNlPjtcbiAgICBpZiAobGVmdFdpbnMpIHtcbiAgICAgIHJlc3VsdEl0ZXJhdG9yID0gbGVmdEl0O1xuICAgICAgb3RoZXJJdGVyYXRvciA9IHJpZ2h0SXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdEl0ZXJhdG9yID0gcmlnaHRJdDtcbiAgICAgIG90aGVySXRlcmF0b3IgPSBsZWZ0SXQ7XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsL2ZpbmlzaCBvdGhlciBpdGVyYXRvclxuICAgIGlmIChvdGhlckl0ZXJhdG9yLnJldHVybikgeyBhd2FpdCBvdGhlckl0ZXJhdG9yLnJldHVybigpOyB9XG5cbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoIShuZXh0ID0gYXdhaXQgcmVzdWx0SXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICB5aWVsZCBuZXh0LnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFByb3BhZ2F0ZXMgdGhlIGFzeW5jIHNlcXVlbmNlIHRoYXQgcmVhY3RzIGZpcnN0LlxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPFQ+fSBsZWZ0IEZpcnN0IGFzeW5jIHNlcXVlbmNlLlxuICogQHBhcmFtIHtBc3luY0l0ZXJhYmxlPFQ+fSByaWdodCBTZWNvbmQgYXN5bmMgc2VxdWVuY2UuXG4gKiBAcmV0dXJuIHtBc3luY0l0ZXJhYmxlPFQ+fSBBbiBhc3luYyBzZXF1ZW5jZSB0aGF0IHN1cmZhY2VzIGVpdGhlciBvZiB0aGUgZ2l2ZW4gc2VxdWVuY2VzLCB3aGljaGV2ZXIgcmVhY3RlZCBmaXJzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhY2U8VFNvdXJjZT4oXG4gICAgbGVmdDogQXN5bmNJdGVyYWJsZTxUU291cmNlPixcbiAgICByaWdodDogQXN5bmNJdGVyYWJsZTxUU291cmNlPik6IEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBSYWNlQXN5bmNJdGVyYWJsZTxUU291cmNlPihsZWZ0LCByaWdodCk7XG59XG4iXX0=
