Object.defineProperty(exports, "__esModule", { value: true });
const iterable_1 = require("../iterable");
const identity_1 = require("../internal/identity");
const comparer_1 = require("../internal/comparer");
class DistinctUntilChangedIterable extends iterable_1.IterableX {
    constructor(source, keySelector, comparer) {
        super();
        this._source = source;
        this._keySelector = keySelector;
        this._comparer = comparer;
    }
    *[Symbol.iterator]() {
        let currentKey = {}, hasCurrentKey = false;
        for (let item of this._source) {
            let key = this._keySelector(item);
            let comparerEquals = false;
            if (hasCurrentKey) {
                comparerEquals = this._comparer(currentKey, key);
            }
            if (!hasCurrentKey || !comparerEquals) {
                hasCurrentKey = true;
                currentKey = key;
                yield item;
            }
        }
    }
}
/**
 * Returns consecutive distinct elements based on a key value by using the specified equality comparer to compare key values.
 * @param {Iterable<TSource>} source Source sequence.
 * @param {function(value: TSource): TKey} [keySelector] Key selector.
 * @param {function(x: TKey, y: TKey): boolean} [comparer] Comparer used to compare key values.
 * @return {Iterable<TSource>} Sequence without adjacent non-distinct elements.
 */
function distinctUntilChanged(source, keySelector = identity_1.identity, comparer = comparer_1.comparer) {
    return new DistinctUntilChangedIterable(source, keySelector, comparer);
}
exports.distinctUntilChanged = distinctUntilChanged;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2Rpc3RpbmN0dW50aWxjaGFuZ2VkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSwwQ0FBd0M7QUFDeEMsbURBQWdEO0FBQ2hELG1EQUFtRTtBQUVuRSxrQ0FBa0QsU0FBUSxvQkFBa0I7SUFLMUUsWUFDSSxNQUF5QixFQUN6QixXQUFxQyxFQUNyQyxRQUFnRDtRQUNsRCxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO0lBQzVCLENBQUM7SUFFRCxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNoQixJQUFJLFVBQVUsR0FBUyxFQUFFLEVBQUUsYUFBYSxHQUFHLEtBQUssQ0FBQztRQUNqRCxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xDLElBQUksY0FBYyxHQUFHLEtBQUssQ0FBQztZQUMzQixFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO2dCQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUFDLENBQUM7WUFDeEUsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxhQUFhLEdBQUcsSUFBSSxDQUFDO2dCQUNyQixVQUFVLEdBQUcsR0FBRyxDQUFDO2dCQUNqQixNQUFNLElBQUksQ0FBQztZQUNiLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsOEJBQ0ksTUFBeUIsRUFDekIsY0FBd0MsbUJBQVEsRUFDaEQsV0FBbUQsbUJBQWU7SUFDcEUsTUFBTSxDQUFDLElBQUksNEJBQTRCLENBQWdCLE1BQU0sRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDeEYsQ0FBQztBQUxELG9EQUtDIiwiZmlsZSI6Iml0ZXJhYmxlL2Rpc3RpbmN0dW50aWxjaGFuZ2VkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuLi9pbnRlcm5hbC9pZGVudGl0eSc7XG5pbXBvcnQgeyBjb21wYXJlciBhcyBkZWZhdWx0Q29tcGFyZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9jb21wYXJlcic7XG5cbmNsYXNzIERpc3RpbmN0VW50aWxDaGFuZ2VkSXRlcmFibGU8VFNvdXJjZSwgVEtleT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBwcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9rZXlTZWxlY3RvcjogKHZhbHVlOiBUU291cmNlKSA9PiBUS2V5O1xuICBwcml2YXRlIF9jb21wYXJlcjogKHg6IFRLZXksIHk6IFRLZXkpID0+IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LFxuICAgICAga2V5U2VsZWN0b3I6ICh2YWx1ZTogVFNvdXJjZSkgPT4gVEtleSxcbiAgICAgIGNvbXBhcmVyOiAoZmlyc3Q6IFRLZXksIHNlY29uZDogVEtleSkgPT4gYm9vbGVhbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX2tleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgdGhpcy5fY29tcGFyZXIgPSBjb21wYXJlcjtcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgY3VycmVudEtleSA9IDxUS2V5Pnt9LCBoYXNDdXJyZW50S2V5ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9zb3VyY2UpIHtcbiAgICAgIGxldCBrZXkgPSB0aGlzLl9rZXlTZWxlY3RvcihpdGVtKTtcbiAgICAgIGxldCBjb21wYXJlckVxdWFscyA9IGZhbHNlO1xuICAgICAgaWYgKGhhc0N1cnJlbnRLZXkpIHsgY29tcGFyZXJFcXVhbHMgPSB0aGlzLl9jb21wYXJlcihjdXJyZW50S2V5LCBrZXkpOyB9XG4gICAgICBpZiAoIWhhc0N1cnJlbnRLZXkgfHwgIWNvbXBhcmVyRXF1YWxzKSB7XG4gICAgICAgIGhhc0N1cnJlbnRLZXkgPSB0cnVlO1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5O1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgY29uc2VjdXRpdmUgZGlzdGluY3QgZWxlbWVudHMgYmFzZWQgb24gYSBrZXkgdmFsdWUgYnkgdXNpbmcgdGhlIHNwZWNpZmllZCBlcXVhbGl0eSBjb21wYXJlciB0byBjb21wYXJlIGtleSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2UgU291cmNlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVFNvdXJjZSk6IFRLZXl9IFtrZXlTZWxlY3Rvcl0gS2V5IHNlbGVjdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbih4OiBUS2V5LCB5OiBUS2V5KTogYm9vbGVhbn0gW2NvbXBhcmVyXSBDb21wYXJlciB1c2VkIHRvIGNvbXBhcmUga2V5IHZhbHVlcy5cbiAqIEByZXR1cm4ge0l0ZXJhYmxlPFRTb3VyY2U+fSBTZXF1ZW5jZSB3aXRob3V0IGFkamFjZW50IG5vbi1kaXN0aW5jdCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkPFRTb3VyY2UsIFRLZXk+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAga2V5U2VsZWN0b3I6ICh2YWx1ZTogVFNvdXJjZSkgPT4gVEtleSA9IGlkZW50aXR5LFxuICAgIGNvbXBhcmVyOiAoZmlyc3Q6IFRLZXksIHNlY29uZDogVEtleSkgPT4gYm9vbGVhbiA9IGRlZmF1bHRDb21wYXJlcik6ICBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkSXRlcmFibGU8VFNvdXJjZSwgVEtleT4oc291cmNlLCBrZXlTZWxlY3RvciwgY29tcGFyZXIpO1xufVxuIl19
