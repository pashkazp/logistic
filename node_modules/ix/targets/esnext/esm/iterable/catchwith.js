import { IterableX } from '../iterable';
import { returnIterator } from '../internal/returniterator';
class CatchWithIterable extends IterableX {
    constructor(source, handler) {
        super();
        this._source = source;
        this._handler = handler;
    }
    *[Symbol.iterator]() {
        let err, hasError = false, it = this._source[Symbol.iterator]();
        while (1) {
            let c = {};
            try {
                c = it.next();
                if (c.done) {
                    returnIterator(it);
                    break;
                }
            }
            catch (e) {
                err = this._handler(e);
                hasError = true;
                returnIterator(it);
                break;
            }
            yield c.value;
        }
        if (hasError) {
            for (let item of err) {
                yield item;
            }
        }
    }
}
/**
 * Creates a sequence that corresponds to the source sequence, concatenating it with the sequence resulting from
 * calling an exception handler function in case of an error.
 * @param {Iterable<TSource>} source Source sequence
 * @param {function(error: any): Iterable<TSource>} handler Handler to invoke when an exception of the specified type occurs.
 * @return {Iterable<TSource>} Source sequence, concatenated with an exception handler result sequence in case of an error.
 */
export function catchWith(source, handler) {
    return new CatchWithIterable(source, handler);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIml0ZXJhYmxlL2NhdGNod2l0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUU1RCx1QkFBaUMsU0FBUSxTQUFrQjtJQUl6RCxZQUFZLE1BQXlCLEVBQUUsT0FBMEM7UUFDL0UsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUN0QixJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztJQUMxQixDQUFDO0lBRUQsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDaEIsSUFBSSxHQUFrQyxFQUFFLFFBQVEsR0FBRyxLQUFLLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDL0YsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNULElBQUksQ0FBQyxHQUE0QixFQUFFLENBQUM7WUFFcEMsSUFBSSxDQUFDO2dCQUNILENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ2QsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7b0JBQ1gsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUNuQixLQUFLLENBQUM7Z0JBQ1IsQ0FBQztZQUNILENBQUM7WUFBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNYLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN2QixRQUFRLEdBQUcsSUFBSSxDQUFDO2dCQUNoQixjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ25CLEtBQUssQ0FBQztZQUNSLENBQUM7WUFFRCxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDaEIsQ0FBQztRQUVELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxHQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUN0QixNQUFNLElBQUksQ0FBQztZQUNiLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxvQkFDRixNQUF5QixFQUN6QixPQUEwQztJQUM1QyxNQUFNLENBQUMsSUFBSSxpQkFBaUIsQ0FBVSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDekQsQ0FBQyIsImZpbGUiOiJpdGVyYWJsZS9jYXRjaHdpdGguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5pbXBvcnQgeyByZXR1cm5JdGVyYXRvciB9IGZyb20gJy4uL2ludGVybmFsL3JldHVybml0ZXJhdG9yJztcblxuY2xhc3MgQ2F0Y2hXaXRoSXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICBwcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+O1xuICBwcml2YXRlIF9oYW5kbGVyOiAoZXJyb3I6IGFueSkgPT4gSXRlcmFibGU8VFNvdXJjZT47XG5cbiAgY29uc3RydWN0b3Ioc291cmNlOiBJdGVyYWJsZTxUU291cmNlPiwgaGFuZGxlcjogKGVycm9yOiBhbnkpID0+IEl0ZXJhYmxlPFRTb3VyY2U+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgbGV0IGVycjogSXRlcmFibGU8VFNvdXJjZT4gfCB1bmRlZmluZWQsIGhhc0Vycm9yID0gZmFsc2UsIGl0ID0gdGhpcy5fc291cmNlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgbGV0IGMgPSA8SXRlcmF0b3JSZXN1bHQ8VFNvdXJjZT4+e307XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGMgPSBpdC5uZXh0KCk7XG4gICAgICAgIGlmIChjLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm5JdGVyYXRvcihpdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gdGhpcy5faGFuZGxlcihlKTtcbiAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm5JdGVyYXRvcihpdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCBjLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgZm9yIChsZXQgaXRlbSBvZiBlcnIhKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlcXVlbmNlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHNvdXJjZSBzZXF1ZW5jZSwgY29uY2F0ZW5hdGluZyBpdCB3aXRoIHRoZSBzZXF1ZW5jZSByZXN1bHRpbmcgZnJvbVxuICogY2FsbGluZyBhbiBleGNlcHRpb24gaGFuZGxlciBmdW5jdGlvbiBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtJdGVyYWJsZTxUU291cmNlPn0gc291cmNlIFNvdXJjZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcjogYW55KTogSXRlcmFibGU8VFNvdXJjZT59IGhhbmRsZXIgSGFuZGxlciB0byBpbnZva2Ugd2hlbiBhbiBleGNlcHRpb24gb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cbiAqIEByZXR1cm4ge0l0ZXJhYmxlPFRTb3VyY2U+fSBTb3VyY2Ugc2VxdWVuY2UsIGNvbmNhdGVuYXRlZCB3aXRoIGFuIGV4Y2VwdGlvbiBoYW5kbGVyIHJlc3VsdCBzZXF1ZW5jZSBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2F0Y2hXaXRoPFRTb3VyY2U+KFxuICAgIHNvdXJjZTogSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgaGFuZGxlcjogKGVycm9yOiBhbnkpID0+IEl0ZXJhYmxlPFRTb3VyY2U+KTogSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcmV0dXJuIG5ldyBDYXRjaFdpdGhJdGVyYWJsZTxUU291cmNlPihzb3VyY2UsIGhhbmRsZXIpO1xufVxuIl19
