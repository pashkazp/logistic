import { AsyncIterableX } from '../asynciterable';
class RaceAsyncIterable extends AsyncIterableX {
    constructor(left, right) {
        super();
        this._left = left;
        this._right = right;
    }
    async *[Symbol.asyncIterator]() {
        const leftIt = this._left[Symbol.asyncIterator](), rightIt = this._right[Symbol.asyncIterator]();
        let leftWins = false, rightWins = false;
        const { value, done } = await Promise.race([
            leftIt.next().then(x => { leftWins = true; return x; }),
            rightIt.next().then(x => { rightWins = true; return x; }),
        ]);
        if (!done) {
            yield value;
        }
        let resultIterator, otherIterator;
        if (leftWins) {
            resultIterator = leftIt;
            otherIterator = rightIt;
        }
        else {
            resultIterator = rightIt;
            otherIterator = leftIt;
        }
        // Cancel/finish other iterator
        if (otherIterator.return) {
            await otherIterator.return();
        }
        let next;
        while (!(next = await resultIterator.next()).done) {
            yield next.value;
        }
    }
}
/**
 * Propagates the async sequence that reacts first.
 * @param {AsyncIterable<T>} left First async sequence.
 * @param {AsyncIterable<T>} right Second async sequence.
 * @return {AsyncIterable<T>} An async sequence that surfaces either of the given sequences, whichever reacted first.
 */
export function race(left, right) {
    return new RaceAsyncIterable(left, right);
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jaXRlcmFibGUvcmFjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFbEQsdUJBQWlDLFNBQVEsY0FBdUI7SUFJOUQsWUFBWSxJQUE0QixFQUFFLEtBQTZCO1FBQ3JFLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVELEtBQUssRUFBRSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7UUFDM0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztRQUNqRyxJQUFJLFFBQVEsR0FBRyxLQUFLLEVBQUUsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN4QyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQztZQUN6QyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RCxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxRCxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDVixNQUFNLEtBQUssQ0FBQztRQUNkLENBQUM7UUFFRCxJQUFJLGNBQXNDLEVBQUUsYUFBcUMsQ0FBQztRQUNsRixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsY0FBYyxHQUFHLE1BQU0sQ0FBQztZQUN4QixhQUFhLEdBQUcsT0FBTyxDQUFDO1FBQzFCLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLGNBQWMsR0FBRyxPQUFPLENBQUM7WUFDekIsYUFBYSxHQUFHLE1BQU0sQ0FBQztRQUN6QixDQUFDO1FBRUQsK0JBQStCO1FBQy9CLEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQUMsTUFBTSxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7UUFBQyxDQUFDO1FBRTNELElBQUksSUFBSSxDQUFDO1FBQ1QsT0FBTyxDQUFDLENBQUMsSUFBSSxHQUFHLE1BQU0sY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbEQsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sZUFDRixJQUE0QixFQUM1QixLQUE2QjtJQUMvQixNQUFNLENBQUMsSUFBSSxpQkFBaUIsQ0FBVSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDckQsQ0FBQyIsImZpbGUiOiJhc3luY2l0ZXJhYmxlL3JhY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0l0ZXJhYmxlWCB9IGZyb20gJy4uL2FzeW5jaXRlcmFibGUnO1xuXG5jbGFzcyBSYWNlQXN5bmNJdGVyYWJsZTxUU291cmNlPiBleHRlbmRzIEFzeW5jSXRlcmFibGVYPFRTb3VyY2U+IHtcbiAgcHJpdmF0ZSBfbGVmdDogQXN5bmNJdGVyYWJsZTxUU291cmNlPjtcbiAgcHJpdmF0ZSBfcmlnaHQ6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT47XG5cbiAgY29uc3RydWN0b3IobGVmdDogQXN5bmNJdGVyYWJsZTxUU291cmNlPiwgcmlnaHQ6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgIHRoaXMuX3JpZ2h0ID0gcmlnaHQ7XG4gIH1cblxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBsZWZ0SXQgPSB0aGlzLl9sZWZ0W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLCByaWdodEl0ID0gdGhpcy5fcmlnaHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgbGV0IGxlZnRXaW5zID0gZmFsc2UsIHJpZ2h0V2lucyA9IGZhbHNlO1xuICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICBsZWZ0SXQubmV4dCgpLnRoZW4oeCA9PiB7IGxlZnRXaW5zID0gdHJ1ZTsgcmV0dXJuIHg7IH0pLFxuICAgICAgcmlnaHRJdC5uZXh0KCkudGhlbih4ID0+IHsgcmlnaHRXaW5zID0gdHJ1ZTsgcmV0dXJuIHg7IH0pLFxuICAgIF0pO1xuXG4gICAgaWYgKCFkb25lKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0SXRlcmF0b3I6IEFzeW5jSXRlcmF0b3I8VFNvdXJjZT4sIG90aGVySXRlcmF0b3I6IEFzeW5jSXRlcmF0b3I8VFNvdXJjZT47XG4gICAgaWYgKGxlZnRXaW5zKSB7XG4gICAgICByZXN1bHRJdGVyYXRvciA9IGxlZnRJdDtcbiAgICAgIG90aGVySXRlcmF0b3IgPSByaWdodEl0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRJdGVyYXRvciA9IHJpZ2h0SXQ7XG4gICAgICBvdGhlckl0ZXJhdG9yID0gbGVmdEl0O1xuICAgIH1cblxuICAgIC8vIENhbmNlbC9maW5pc2ggb3RoZXIgaXRlcmF0b3JcbiAgICBpZiAob3RoZXJJdGVyYXRvci5yZXR1cm4pIHsgYXdhaXQgb3RoZXJJdGVyYXRvci5yZXR1cm4oKTsgfVxuXG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKCEobmV4dCA9IGF3YWl0IHJlc3VsdEl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgeWllbGQgbmV4dC52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9wYWdhdGVzIHRoZSBhc3luYyBzZXF1ZW5jZSB0aGF0IHJlYWN0cyBmaXJzdC5cbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPn0gbGVmdCBGaXJzdCBhc3luYyBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7QXN5bmNJdGVyYWJsZTxUPn0gcmlnaHQgU2Vjb25kIGFzeW5jIHNlcXVlbmNlLlxuICogQHJldHVybiB7QXN5bmNJdGVyYWJsZTxUPn0gQW4gYXN5bmMgc2VxdWVuY2UgdGhhdCBzdXJmYWNlcyBlaXRoZXIgb2YgdGhlIGdpdmVuIHNlcXVlbmNlcywgd2hpY2hldmVyIHJlYWN0ZWQgZmlyc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYWNlPFRTb3VyY2U+KFxuICAgIGxlZnQ6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4sXG4gICAgcmlnaHQ6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4pOiBBc3luY0l0ZXJhYmxlWDxUU291cmNlPiB7XG4gIHJldHVybiBuZXcgUmFjZUFzeW5jSXRlcmFibGU8VFNvdXJjZT4obGVmdCwgcmlnaHQpO1xufVxuIl19
