goog.module('targets.esnext.cls.iterable.catchwith'); exports = {}; var module = {id: 'targets/esnext/cls/iterable/catchwith.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.esnext.cls.iterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
var returniterator_1 = goog.require('targets.esnext.cls.internal.returniterator');
const tsickle_forward_declare_2 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.internal.returniterator");
/**
 * @template TSource
 */
class CatchWithIterable extends iterable_1.IterableX {
    /**
     * @param {!Iterable<TSource>} source
     * @param {function(?): !Iterable<TSource>} handler
     */
    constructor(source, handler) {
        super();
        this._source = source;
        this._handler = handler;
    }
    /**
     * @return {!IterableIterator<TSource>}
     */
    *[Symbol.iterator]() {
        let /** @type {!Iterable<TSource>} */ err, /** @type {boolean} */ hasError = false, /** @type {!Iterator<TSource>} */ it = this._source[Symbol.iterator]();
        while (1) {
            let /** @type {!IteratorResult<TSource>} */ c = ({});
            try {
                c = it.next();
                if (c.done) {
                    returniterator_1.returnIterator(it);
                    break;
                }
            }
            catch (e) {
                err = this._handler(e);
                hasError = true;
                returniterator_1.returnIterator(it);
                break;
            }
            yield c.value;
        }
        if (hasError) {
            for (let /** @type {TSource} */ item of ((err))) {
                yield item;
            }
        }
    }
}
function CatchWithIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<TSource>} */
    CatchWithIterable.prototype._source;
    /** @type {function(?): !Iterable<TSource>} */
    CatchWithIterable.prototype._handler;
}
/**
 * Creates a sequence that corresponds to the source sequence, concatenating it with the sequence resulting from
 * calling an exception handler function in case of an error.
 * @template TSource
 * @param {!Iterable<TSource>} source
 * @param {function(?): !Iterable<TSource>} handler
 * @return {!tsickle_forward_declare_1.IterableX<TSource>}
 */
function catchWith(source, handler) {
    return new CatchWithIterable(source, handler);
}
exports.catchWith = catchWith;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9jYXRjaHdpdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztHQUdHOztBQUVILDBDQUxrQjtBQU1sQixNQUFNLHlCQUF5QixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsc0NBQXNDLENBQUMsQ0FOckQ7QUFPeEMsK0RBTnVCO0FBT3ZCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0FBQzdHOztHQUVHO0FBUkgsdUJBQWdDLFNBQVEsb0JBQW1CO0lBWTNEOzs7T0FHRztJQVhELFlBQVksTUFBeUIsRUFBQyxPQUEyQztRQWEvRSxLQVpLLEVBQUUsQ0FBQztRQWFSLElBWkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO1FBYXRCLElBWkksQ0FBQyxRQUFRLEdBQUUsT0FBUSxDQUFDO0lBYTFCLENBQUM7SUFDSDs7T0FFRztJQWJELENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBZWhCLElBQUksaUNBZEQsQ0FBQSxHQUFtQyxFQUFBLHNCQUFDLENBQUEsUUFBUyxHQUFFLEtBQU0sRUFBQSxpQ0FBQyxDQUFBLEVBQUcsR0FBRSxJQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBZS9GLE9BZE8sQ0FBQyxFQUFDLENBQUU7WUFlVCxJQUFJLHVDQWRELENBQUEsQ0FBRSxHQUFBLENBQTRCLEVBQUEsQ0FBRSxDQUFDO1lBZ0JwQyxJQWRHLENBQUU7Z0JBZUgsQ0FkQyxHQUFFLEVBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFlZCxFQUFFLENBQUMsQ0FkQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUEsQ0FBRTtvQkFlWCwrQkFkYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQWVuQixLQUFLLENBZEM7Z0JBZVIsQ0FkQztZQWVILENBZEM7WUFBQSxLQUFBLENBQUEsQ0FBUSxDQUFDLENBQUMsQ0FBQSxDQUFFO2dCQWVYLEdBZEcsR0FBRSxJQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQWV2QixRQWRRLEdBQUUsSUFBSyxDQUFDO2dCQWVoQiwrQkFkYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQWVuQixLQUFLLENBZEM7WUFlUixDQWRDO1lBZ0JELE1BZEssQ0FBRSxDQUFDLEtBQUssQ0FBQztRQWVoQixDQWRDO1FBZ0JELEVBQUUsQ0FBQyxDQWRDLFFBQVEsQ0FBQyxDQUFBLENBQUU7WUFlYixHQUFHLENBQUMsQ0FkQyxJQUFBLHNCQUFHLENBQUEsSUFBSyxJQUFBLENBQUEsQ0FBRyxHQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBRTtnQkFldEIsTUFkSyxJQUFLLENBQUM7WUFlYixDQWRDO1FBZUgsQ0FkQztJQWVILENBZEM7Q0FDSDtBQWdCQTtJQUNBLGlDQUFpQztJQUNqQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBQ3BDLDhDQUE4QztJQUM5QyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBQ3JDLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBckJILG1CQXVCSSxNQXRCeUIsRUF1QnpCLE9BdEIwQztJQXVCNUMsTUF0Qk0sQ0FBQSxJQUFJLGlCQUFrQixDQUFVLE1BQU0sRUFBQyxPQUFRLENBQUMsQ0FBQztBQXVCekQsQ0F0QkM7QUFKRCw4QkFJQyIsImZpbGUiOiJjYXRjaHdpdGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pdGVyYWJsZVwiKTtcbmltcG9ydCB7IHJldHVybkl0ZXJhdG9yIH0gZnJvbSAnLi4vaW50ZXJuYWwvcmV0dXJuaXRlcmF0b3InO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMiA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaW50ZXJuYWwucmV0dXJuaXRlcmF0b3JcIik7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmNsYXNzIENhdGNoV2l0aEl0ZXJhYmxlPFRTb3VyY2U+IGV4dGVuZHMgSXRlcmFibGVYPFRTb3VyY2U+IHtcbnByaXZhdGUgX3NvdXJjZTogSXRlcmFibGU8VFNvdXJjZT47XG5wcml2YXRlIF9oYW5kbGVyOiAoZXJyb3I6IGFueSkgPT4gSXRlcmFibGU8VFNvdXJjZT47XG4vKipcbiAqIEBwYXJhbSB7IUl0ZXJhYmxlPFRTb3VyY2U+fSBzb3VyY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ICFJdGVyYWJsZTxUU291cmNlPn0gaGFuZGxlclxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LCBoYW5kbGVyOiAoZXJyb3I6IGFueSkgPT4gSXRlcmFibGU8VFNvdXJjZT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuLyoqXG4gKiBAcmV0dXJuIHshSXRlcmFibGVJdGVyYXRvcjxUU291cmNlPn1cbiAqL1xuKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGxldCAvKiogQHR5cGUgeyFJdGVyYWJsZTxUU291cmNlPn0gKi8gZXJyOiBJdGVyYWJsZTxUU291cmNlPiB8IHVuZGVmaW5lZCwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBoYXNFcnJvciA9IGZhbHNlLCAvKiogQHR5cGUgeyFJdGVyYXRvcjxUU291cmNlPn0gKi8gaXQgPSB0aGlzLl9zb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBsZXQgLyoqIEB0eXBlIHshSXRlcmF0b3JSZXN1bHQ8VFNvdXJjZT59ICovIGMgPSAvKiogQHR5cGUgeyFJdGVyYXRvclJlc3VsdDxUU291cmNlPn0gKi8oKCA8SXRlcmF0b3JSZXN1bHQ8VFNvdXJjZT4+e30pKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYyA9IGl0Lm5leHQoKTtcbiAgICAgICAgaWYgKGMuZG9uZSkge1xuICAgICAgICAgIHJldHVybkl0ZXJhdG9yKGl0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoIC8qKiBAdHlwZSB7P30gKi9lKSB7XG4gICAgICAgIGVyciA9IHRoaXMuX2hhbmRsZXIoZSk7XG4gICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuSXRlcmF0b3IoaXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgeWllbGQgYy52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgIGZvciAobGV0IC8qKiBAdHlwZSB7VFNvdXJjZX0gKi8gaXRlbSBvZiAvKiogQHR5cGUgeyFJdGVyYWJsZTxUU291cmNlPn0gKi8oKCBlcnIpKSkge1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDYXRjaFdpdGhJdGVyYWJsZV90c2lja2xlX0Nsb3N1cmVfZGVjbGFyYXRpb25zKCkge1xuLyoqIEB0eXBlIHshSXRlcmFibGU8VFNvdXJjZT59ICovXG5DYXRjaFdpdGhJdGVyYWJsZS5wcm90b3R5cGUuX3NvdXJjZTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oPyk6ICFJdGVyYWJsZTxUU291cmNlPn0gKi9cbkNhdGNoV2l0aEl0ZXJhYmxlLnByb3RvdHlwZS5faGFuZGxlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VxdWVuY2UgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc291cmNlIHNlcXVlbmNlLCBjb25jYXRlbmF0aW5nIGl0IHdpdGggdGhlIHNlcXVlbmNlIHJlc3VsdGluZyBmcm9tXG4gKiBjYWxsaW5nIGFuIGV4Y2VwdGlvbiBoYW5kbGVyIGZ1bmN0aW9uIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gKiBAdGVtcGxhdGUgVFNvdXJjZVxuICogQHBhcmFtIHshSXRlcmFibGU8VFNvdXJjZT59IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbig/KTogIUl0ZXJhYmxlPFRTb3VyY2U+fSBoYW5kbGVyXG4gKiBAcmV0dXJuIHshdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMS5JdGVyYWJsZVg8VFNvdXJjZT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXRjaFdpdGg8VFNvdXJjZT4oXG4gICAgc291cmNlOiBJdGVyYWJsZTxUU291cmNlPixcbiAgICBoYW5kbGVyOiAoZXJyb3I6IGFueSkgPT4gSXRlcmFibGU8VFNvdXJjZT4pOiBJdGVyYWJsZVg8VFNvdXJjZT4ge1xuICByZXR1cm4gbmV3IENhdGNoV2l0aEl0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSwgaGFuZGxlcik7XG59XG4iXX0=