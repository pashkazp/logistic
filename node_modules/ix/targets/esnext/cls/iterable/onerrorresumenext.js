goog.module('targets.esnext.cls.iterable.onerrorresumenext'); exports = {}; var module = {id: 'targets/esnext/cls/iterable/onerrorresumenext.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.esnext.cls.iterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
/**
 * @template TSource
 */
class OnErrorResumeNextIterable extends iterable_1.IterableX {
    /**
     * @param {!Iterable<!Iterable<TSource>>} source
     */
    constructor(source) {
        super();
        this._source = source;
    }
    /**
     * @return {!IterableIterator<TSource>}
     */
    *[Symbol.iterator]() {
        for (let /** @type {!Iterable<TSource>} */ item of this._source) {
            let /** @type {!Iterator<TSource>} */ it = item[Symbol.iterator]();
            while (1) {
                let /** @type {?} */ next;
                try {
                    next = it.next();
                }
                catch (e) {
                    break;
                }
                if (next.done) {
                    break;
                }
                yield next.value;
            }
        }
    }
}
function OnErrorResumeNextIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<!Iterable<TSource>>} */
    OnErrorResumeNextIterable.prototype._source;
}
/**
 * @template T
 * @param {!Iterable<T>} source
 * @param {...!Iterable<T>} args
 * @return {!tsickle_forward_declare_1.IterableX<T>}
 */
function onErrorResumeNext(source, ...args) {
    return new OnErrorResumeNextIterable([source, ...args]);
}
exports.onErrorResumeNext = onErrorResumeNext;
/**
 * @template T
 * @param {...!Iterable<T>} source
 * @return {!tsickle_forward_declare_1.IterableX<T>}
 */
function onErrorResumeNextStatic(...source) {
    return new OnErrorResumeNextIterable(source);
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9vbmVycm9ycmVzdW1lbmV4dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7O0FBRUgsMENBTGtCO0FBTWxCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0FBQzlGOztHQUVHO0FBUEgsK0JBQXdDLFNBQVEsb0JBQW1CO0lBVW5FOztPQUVHO0lBVEQsWUFBWSxNQUFtQztRQVc3QyxLQVZLLEVBQUUsQ0FBQztRQVdSLElBVkksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO0lBV3hCLENBQUM7SUFDSDs7T0FFRztJQVhELENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBYWhCLEdBQUcsQ0FBQyxDQVpDLElBQUEsaUNBQUcsQ0FBQSxJQUFLLElBQUcsSUFBSyxDQUFDLE9BQU8sQ0FBQyxDQUFBLENBQUU7WUFhOUIsSUFBSSxpQ0FaRCxDQUFBLEVBQUcsR0FBRSxJQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFhakMsT0FaTyxDQUFDLEVBQUMsQ0FBRTtnQkFhVCxJQUFJLGdCQVpELENBQUEsSUFBSyxDQUFDO2dCQWFULElBWkcsQ0FBRTtvQkFhSCxJQVpJLEdBQUUsRUFBRyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQWFuQixDQVpDO2dCQUFBLEtBQUEsQ0FBQSxDQUFRLENBQUMsQ0FBQyxDQUFBLENBQUU7b0JBYVgsS0FBSyxDQVpDO2dCQWFSLENBWkM7Z0JBY0QsRUFBRSxDQUFDLENBWkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBLENBQUU7b0JBQUEsS0FBQSxDQUFPO2dCQUFBLENBQUU7Z0JBYXpCLE1BWkssSUFBSyxDQUFDLEtBQUssQ0FBQztZQWFuQixDQVpDO1FBYUgsQ0FaQztJQWFILENBWkM7Q0FDSDtBQWNBO0lBQ0EsNENBQTRDO0lBQzVDLHlCQUF5QixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7QUFDNUMsQ0FBQztBQUVEOzs7OztHQUtHO0FBdEJILDJCQUFxQyxNQUFtQixFQUFDLEdBQUksSUFBbUI7SUF3QjlFLE1BdkJNLENBQUEsSUFBSSx5QkFBMEIsQ0FBSSxDQUFDLE1BQU0sRUFBQyxHQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7QUF3QjdELENBQUM7QUF6QkQsOENBeUJDO0FBQ0Q7Ozs7R0FJRztBQTFCSCxpQ0FBMkMsR0FBRyxNQUFxQjtJQTRCakUsTUEzQk0sQ0FBQSxJQUFJLHlCQUEwQixDQUFJLE1BQU0sQ0FBQyxDQUFDO0FBNEJsRCxDQTNCQztBQUZELDBEQUVDIiwiZmlsZSI6Im9uZXJyb3JyZXN1bWVuZXh0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuaW1wb3J0IHsgSXRlcmFibGVYIH0gZnJvbSAnLi4vaXRlcmFibGUnO1xuY29uc3QgdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMSA9IGdvb2cuZm9yd2FyZERlY2xhcmUoXCJfVXNlcnMucHRheWxvci5kZXYuaXhqcy5zcmMuaXRlcmFibGVcIik7XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmNsYXNzIE9uRXJyb3JSZXN1bWVOZXh0SXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBJdGVyYWJsZVg8VFNvdXJjZT4ge1xucHJpdmF0ZSBfc291cmNlOiBJdGVyYWJsZTxJdGVyYWJsZTxUU291cmNlPj47XG4vKipcbiAqIEBwYXJhbSB7IUl0ZXJhYmxlPCFJdGVyYWJsZTxUU291cmNlPj59IHNvdXJjZVxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPEl0ZXJhYmxlPFRTb3VyY2U+Pikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB9XG4vKipcbiAqIEByZXR1cm4geyFJdGVyYWJsZUl0ZXJhdG9yPFRTb3VyY2U+fVxuICovXG4qW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgLyoqIEB0eXBlIHshSXRlcmFibGU8VFNvdXJjZT59ICovIGl0ZW0gb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICBsZXQgLyoqIEB0eXBlIHshSXRlcmF0b3I8VFNvdXJjZT59ICovIGl0ID0gaXRlbVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBsZXQgLyoqIEB0eXBlIHs/fSAqLyBuZXh0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHQgPSBpdC5uZXh0KCk7XG4gICAgICAgIH0gY2F0Y2ggKCAvKiogQHR5cGUgez99ICovZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQuZG9uZSkgeyBicmVhazsgfVxuICAgICAgICB5aWVsZCBuZXh0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBPbkVycm9yUmVzdW1lTmV4dEl0ZXJhYmxlX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUgeyFJdGVyYWJsZTwhSXRlcmFibGU8VFNvdXJjZT4+fSAqL1xuT25FcnJvclJlc3VtZU5leHRJdGVyYWJsZS5wcm90b3R5cGUuX3NvdXJjZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHshSXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHsuLi4hSXRlcmFibGU8VD59IGFyZ3NcbiAqIEByZXR1cm4geyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xLkl0ZXJhYmxlWDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQ+KHNvdXJjZTogSXRlcmFibGU8VD4sIC4uLmFyZ3M6IEl0ZXJhYmxlPFQ+W10pOiBJdGVyYWJsZVg8VD4ge1xuICByZXR1cm4gbmV3IE9uRXJyb3JSZXN1bWVOZXh0SXRlcmFibGU8VD4oW3NvdXJjZSwgLi4uYXJnc10pO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsuLi4hSXRlcmFibGU8VD59IHNvdXJjZVxuICogQHJldHVybiB7IXRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuSXRlcmFibGVYPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHRTdGF0aWM8VD4oLi4uc291cmNlOiBJdGVyYWJsZTxUPltdKTogSXRlcmFibGVYPFQ+IHtcbiAgcmV0dXJuIG5ldyBPbkVycm9yUmVzdW1lTmV4dEl0ZXJhYmxlPFQ+KHNvdXJjZSk7XG59XG4iXX0=