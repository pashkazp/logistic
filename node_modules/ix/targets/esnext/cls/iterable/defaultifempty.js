goog.module('targets.esnext.cls.iterable.defaultifempty'); exports = {}; var module = {id: 'targets/esnext/cls/iterable/defaultifempty.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var iterable_1 = goog.require('targets.esnext.cls.iterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.iterable");
/**
 * @template TSource
 */
class DefaultIfEmptyIterable extends iterable_1.IterableX {
    /**
     * @param {!Iterable<TSource>} source
     * @param {TSource} defaultValue
     */
    constructor(source, defaultValue) {
        super();
        this._source = source;
        this._defaultValue = defaultValue;
    }
    /**
     * @return {!IterableIterator<TSource>}
     */
    *[Symbol.iterator]() {
        let /** @type {number} */ state = 1;
        for (let /** @type {TSource} */ item of this._source) {
            state = 2;
            yield item;
        }
        if (state === 1) {
            yield this._defaultValue;
        }
    }
}
function DefaultIfEmptyIterable_tsickle_Closure_declarations() {
    /** @type {!Iterable<TSource>} */
    DefaultIfEmptyIterable.prototype._source;
    /** @type {TSource} */
    DefaultIfEmptyIterable.prototype._defaultValue;
}
/**
 * Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.
 * @template T
 * @param {!Iterable<T>} source
 * @param {T} defaultValue
 * @return {!tsickle_forward_declare_1.IterableX<T>} An that contains the default value if source is empty; otherwise, source.
 */
function defaultIfEmpty(source, defaultValue) {
    return new DefaultIfEmptyIterable(source, defaultValue);
}
exports.defaultIfEmpty = defaultIfEmpty;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pdGVyYWJsZS9kZWZhdWx0aWZlbXB0eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7O0FBRUgsMENBTGtCO0FBTWxCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO0FBQzlGOztHQUVHO0FBUEgsNEJBQXFDLFNBQVEsb0JBQW1CO0lBV2hFOzs7T0FHRztJQVZELFlBQVksTUFBeUIsRUFBQyxZQUFzQjtRQVkxRCxLQVhLLEVBQUUsQ0FBQztRQVlSLElBWEksQ0FBQyxPQUFPLEdBQUUsTUFBTyxDQUFDO1FBWXRCLElBWEksQ0FBQyxhQUFhLEdBQUUsWUFBYSxDQUFDO0lBWXBDLENBQUM7SUFDSDs7T0FFRztJQVpELENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBY2hCLElBQUkscUJBYkQsQ0FBQSxLQUFNLEdBQUUsQ0FBRSxDQUFDO1FBY2QsR0FBRyxDQUFDLENBYkMsSUFBQSxzQkFBRyxDQUFBLElBQUssSUFBRyxJQUFLLENBQUMsT0FBTyxDQUFDLENBQUEsQ0FBRTtZQWM5QixLQWJLLEdBQUUsQ0FBRSxDQUFDO1lBY1YsTUFiSyxJQUFLLENBQUM7UUFjYixDQWJDO1FBY0QsRUFBRSxDQUFDLENBYkMsS0FBSyxLQUFJLENBQUUsQ0FBQyxDQUFBLENBQUU7WUFjaEIsTUFiSyxJQUFLLENBQUMsYUFBYSxDQUFDO1FBYzNCLENBYkM7SUFjSCxDQWJDO0NBQ0g7QUFlQTtJQUNBLGlDQUFpQztJQUNqQyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBQ3pDLHNCQUFzQjtJQUN0QixzQkFBc0IsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDO0FBQy9DLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFwQkgsd0JBQWtDLE1BQW1CLEVBQUMsWUFBZ0I7SUFzQnBFLE1BckJNLENBQUEsSUFBSSxzQkFBdUIsQ0FBSSxNQUFNLEVBQUMsWUFBYSxDQUFDLENBQUM7QUFzQjdELENBckJDO0FBRkQsd0NBRUMiLCJmaWxlIjoiZGVmYXVsdGlmZW1wdHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5pbXBvcnQgeyBJdGVyYWJsZVggfSBmcm9tICcuLi9pdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5pdGVyYWJsZVwiKTtcbi8qKlxuICogQHRlbXBsYXRlIFRTb3VyY2VcbiAqL1xuY2xhc3MgRGVmYXVsdElmRW1wdHlJdGVyYWJsZTxUU291cmNlPiBleHRlbmRzIEl0ZXJhYmxlWDxUU291cmNlPiB7XG5wcml2YXRlIF9zb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+O1xucHJpdmF0ZSBfZGVmYXVsdFZhbHVlOiBUU291cmNlO1xuLyoqXG4gKiBAcGFyYW0geyFJdGVyYWJsZTxUU291cmNlPn0gc291cmNlXG4gKiBAcGFyYW0ge1RTb3VyY2V9IGRlZmF1bHRWYWx1ZVxuICovXG5jb25zdHJ1Y3Rvcihzb3VyY2U6IEl0ZXJhYmxlPFRTb3VyY2U+LCBkZWZhdWx0VmFsdWU6IFRTb3VyY2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cbi8qKlxuICogQHJldHVybiB7IUl0ZXJhYmxlSXRlcmF0b3I8VFNvdXJjZT59XG4gKi9cbipbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHN0YXRlID0gMTtcbiAgICBmb3IgKGxldCAvKiogQHR5cGUge1RTb3VyY2V9ICovIGl0ZW0gb2YgdGhpcy5fc291cmNlKSB7XG4gICAgICBzdGF0ZSA9IDI7XG4gICAgICB5aWVsZCBpdGVtO1xuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgIHlpZWxkIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gRGVmYXVsdElmRW1wdHlJdGVyYWJsZV90c2lja2xlX0Nsb3N1cmVfZGVjbGFyYXRpb25zKCkge1xuLyoqIEB0eXBlIHshSXRlcmFibGU8VFNvdXJjZT59ICovXG5EZWZhdWx0SWZFbXB0eUl0ZXJhYmxlLnByb3RvdHlwZS5fc291cmNlO1xuLyoqIEB0eXBlIHtUU291cmNlfSAqL1xuRGVmYXVsdElmRW1wdHlJdGVyYWJsZS5wcm90b3R5cGUuX2RlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgc3BlY2lmaWVkIHNlcXVlbmNlIG9yIHRoZSB0eXBlIHBhcmFtZXRlcidzIGRlZmF1bHQgdmFsdWUgaW4gYSBzaW5nbGV0b24gY29sbGVjdGlvbiBpZiB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHshSXRlcmFibGU8VD59IHNvdXJjZVxuICogQHBhcmFtIHtUfSBkZWZhdWx0VmFsdWVcbiAqIEByZXR1cm4geyF0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xLkl0ZXJhYmxlWDxUPn0gQW4gdGhhdCBjb250YWlucyB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBzb3VyY2UgaXMgZW1wdHk7IG90aGVyd2lzZSwgc291cmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdElmRW1wdHk8VD4oc291cmNlOiBJdGVyYWJsZTxUPiwgZGVmYXVsdFZhbHVlOiBUKTogSXRlcmFibGVYPFQ+IHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0SWZFbXB0eUl0ZXJhYmxlPFQ+KHNvdXJjZSwgZGVmYXVsdFZhbHVlKTtcbn1cbiJdfQ==