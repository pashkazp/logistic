goog.module('targets.esnext.cls.asynciterable.timeinterval'); exports = {}; var module = {id: 'targets/esnext/cls/asynciterable/timeinterval.js'};/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var asynciterable_1 = goog.require('targets.esnext.cls.asynciterable');
const tsickle_forward_declare_1 = goog.forwardDeclare("_Users.ptaylor.dev.ixjs.src.asynciterable");
/**
 * @record
 * @template T
 */
function TimeInterval() { }
exports.TimeInterval = TimeInterval;
function TimeInterval_tsickle_Closure_declarations() {
    /** @type {T} */
    TimeInterval.prototype.value;
    /** @type {number} */
    TimeInterval.prototype.elapsed;
}
/**
 * @template TSource
 */
class TimeIntervalAsyncIterable extends asynciterable_1.AsyncIterableX {
    /**
     * @param {!AsyncIterable<TSource>} source
     */
    constructor(source) {
        super();
        this._source = source;
    }
    /**
     * @return {!AsyncIterableIterator<?>}
     */
    async *[Symbol.asyncIterator]() {
        let /** @type {number} */ last = Date.now();
        for await (let /** @type {TSource} */ item of this._source) {
            const /** @type {number} */ now = Date.now();
            const /** @type {number} */ span = now - last;
            last = now;
            yield { value: item, elapsed: span };
        }
    }
}
function TimeIntervalAsyncIterable_tsickle_Closure_declarations() {
    /** @type {!AsyncIterable<TSource>} */
    TimeIntervalAsyncIterable.prototype._source;
}
/**
 * @template TSource
 * @param {!AsyncIterable<TSource>} source
 * @return {!tsickle_forward_declare_1.AsyncIterableX<!TimeInterval<TSource>>}
 */
function timeInterval(source) {
    return new TimeIntervalAsyncIterable(source);
}
exports.timeInterval = timeInterval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hc3luY2l0ZXJhYmxlL3RpbWVpbnRlcnZhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7O0FBRUgsb0RBTHVCO0FBTXZCLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0FBQ25HOzs7R0FHRztBQUNILDBCQUFnQyxDQUFDO0FBQWpDLG9DQUFpQztBQUdqQztJQUNBLGdCQUFnQjtJQUNoQixZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUM3QixxQkFBcUI7SUFDckIsWUFBWSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7QUFDL0IsQ0FBQztBQU9EOztHQUVHO0FBckJILCtCQUF3QyxTQUFRLDhCQUFzQztJQXdCdEY7O09BRUc7SUF2QkQsWUFBWSxNQUE4QjtRQXlCeEMsS0F4QkssRUFBRSxDQUFDO1FBeUJSLElBeEJJLENBQUMsT0FBTyxHQUFFLE1BQU8sQ0FBQztJQXlCeEIsQ0FBQztJQUNIOztPQUVHO0lBekJELEtBQUssRUFBRSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7UUEyQjNCLElBQUkscUJBMUJELENBQUEsSUFBSyxHQUFFLElBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQTJCdEIsR0ExQkcsQ0FBQSxLQUFNLENBQU4sQ0FBUSxJQUFBLHNCQUFHLENBQUEsSUFBSyxJQUFHLElBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQSxDQUFFO1lBMkJwQyxNQUFNLHFCQTFCRCxDQUFBLEdBQUksR0FBRSxJQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7WUEyQnZCLE1BQU0scUJBMUJELENBQUEsSUFBSyxHQUFFLEdBQUksR0FBRSxJQUFLLENBQUM7WUEyQnhCLElBMUJJLEdBQUUsR0FBSSxDQUFDO1lBMkJYLE1BMUJLLEVBQUUsS0FBTSxFQUFDLElBQUssRUFBQyxPQUFRLEVBQUMsSUFBSyxFQUFFLENBQUM7UUEyQnZDLENBMUJDO0lBMkJILENBMUJDO0NBQ0g7QUE0QkE7SUFDQSxzQ0FBc0M7SUFDdEMseUJBQXlCLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztBQUM1QyxDQUFDO0FBRUQ7Ozs7R0FJRztBQW5DSCxzQkFxQ0ksTUFwQzhCO0lBcUNoQyxNQXBDTSxDQUFBLElBQUkseUJBQTBCLENBQVUsTUFBTSxDQUFDLENBQUM7QUFxQ3hELENBQUM7QUF2Q0Qsb0NBdUNDIiwiZmlsZSI6InRpbWVpbnRlcnZhbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG5cbmltcG9ydCB7IEFzeW5jSXRlcmFibGVYIH0gZnJvbSAnLi4vYXN5bmNpdGVyYWJsZSc7XG5jb25zdCB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8xID0gZ29vZy5mb3J3YXJkRGVjbGFyZShcIl9Vc2Vycy5wdGF5bG9yLmRldi5peGpzLnNyYy5hc3luY2l0ZXJhYmxlXCIpO1xuLyoqXG4gKiBAcmVjb3JkXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gVGltZUludGVydmFsKCkge31cblxuXG5mdW5jdGlvbiBUaW1lSW50ZXJ2YWxfdHNpY2tsZV9DbG9zdXJlX2RlY2xhcmF0aW9ucygpIHtcbi8qKiBAdHlwZSB7VH0gKi9cblRpbWVJbnRlcnZhbC5wcm90b3R5cGUudmFsdWU7XG4vKiogQHR5cGUge251bWJlcn0gKi9cblRpbWVJbnRlcnZhbC5wcm90b3R5cGUuZWxhcHNlZDtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVJbnRlcnZhbDxUPiB7XG4gIHZhbHVlOiBUO1xuICBlbGFwc2VkOiBudW1iZXI7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUU291cmNlXG4gKi9cbmNsYXNzIFRpbWVJbnRlcnZhbEFzeW5jSXRlcmFibGU8VFNvdXJjZT4gZXh0ZW5kcyBBc3luY0l0ZXJhYmxlWDxUaW1lSW50ZXJ2YWw8VFNvdXJjZT4+IHtcbnByaXZhdGUgX3NvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPjtcbi8qKlxuICogQHBhcmFtIHshQXN5bmNJdGVyYWJsZTxUU291cmNlPn0gc291cmNlXG4gKi9cbmNvbnN0cnVjdG9yKHNvdXJjZTogQXN5bmNJdGVyYWJsZTxUU291cmNlPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICB9XG4vKipcbiAqIEByZXR1cm4geyFBc3luY0l0ZXJhYmxlSXRlcmF0b3I8Pz59XG4gKi9cbmFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gbGFzdCA9IERhdGUubm93KCk7XG4gICAgZm9yIGF3YWl0IChsZXQgLyoqIEB0eXBlIHtUU291cmNlfSAqLyBpdGVtIG9mIHRoaXMuX3NvdXJjZSkge1xuICAgICAgY29uc3QgLyoqIEB0eXBlIHtudW1iZXJ9ICovIG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCAvKiogQHR5cGUge251bWJlcn0gKi8gc3BhbiA9IG5vdyAtIGxhc3Q7XG4gICAgICBsYXN0ID0gbm93O1xuICAgICAgeWllbGQgeyB2YWx1ZTogaXRlbSwgZWxhcHNlZDogc3BhbiB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBUaW1lSW50ZXJ2YWxBc3luY0l0ZXJhYmxlX3RzaWNrbGVfQ2xvc3VyZV9kZWNsYXJhdGlvbnMoKSB7XG4vKiogQHR5cGUgeyFBc3luY0l0ZXJhYmxlPFRTb3VyY2U+fSAqL1xuVGltZUludGVydmFsQXN5bmNJdGVyYWJsZS5wcm90b3R5cGUuX3NvdXJjZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFNvdXJjZVxuICogQHBhcmFtIHshQXN5bmNJdGVyYWJsZTxUU291cmNlPn0gc291cmNlXG4gKiBAcmV0dXJuIHshdHNpY2tsZV9mb3J3YXJkX2RlY2xhcmVfMS5Bc3luY0l0ZXJhYmxlWDwhVGltZUludGVydmFsPFRTb3VyY2U+Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVJbnRlcnZhbDxUU291cmNlPihcbiAgICBzb3VyY2U6IEFzeW5jSXRlcmFibGU8VFNvdXJjZT4pOiBBc3luY0l0ZXJhYmxlWDxUaW1lSW50ZXJ2YWw8VFNvdXJjZT4+IHtcbiAgcmV0dXJuIG5ldyBUaW1lSW50ZXJ2YWxBc3luY0l0ZXJhYmxlPFRTb3VyY2U+KHNvdXJjZSk7XG59Il19